---
title: 编译器警告 C4800 - C5999
ms.date: 04/21/2019
f1_keywords:
- C4808
- C4809
- C4825
- C4827
- C4837
- C4841
- C4842
- C4843
- C4844
- C4845
- C4846
- C4847
- C4848
- C4854
- C4855
- C4856
- C4857
- C4872
- C4880
- C4881
- C4882
- C4916
- C4921
- C4934
- C4954
- C4955
- C4963
- C4966
- C4970
- C4971
- C4973
- C4974
- C4981
- C4987
- C4988
- C4989
- C4990
- C4991
- C4992
- C4998
- C5022
- C5023
- C5024
- C5025
- C5026
- C5027
- C5028
- C5029
- C5030
- C5031
- C5032
- C5033
- C5034
- C5035
- C5036
- C5037
- C5039
- C5040
- C5041
- C5042
- C5043
- C5044
- C5047
- C5048
- C5049
- C5050
- C5051
- C5052
- C5053
- C5054
- C5055
- C5056
- C5057
- C5058
- C5059
- C5060
- C5061
- C5062
- C5063
- C5100
- C5101
- C5102
- C5103
- C5104
- C5106
- C5107
- C5108
- C5200
- C5201
- C5202
- C5203
- C5204
- C5205
- C5206
- C5207
helpviewer_keywords:
- C4808
- C4809
- C4825
- C4827
- C4837
- C4841
- C4842
- C4843
- C4844
- C4845
- C4846
- C4847
- C4848
- C4854
- C4855
- C4856
- C4857
- C4872
- C4880
- C4881
- C4882
- C4916
- C4921
- C4934
- C4954
- C4955
- C4963
- C4966
- C4970
- C4971
- C4973
- C4974
- C4981
- C4987
- C4988
- C4989
- C4990
- C4991
- C4992
- C4998
- C5022
- C5023
- C5024
- C5025
- C5026
- C5027
- C5028
- C5029
- C5030
- C5031
- C5032
- C5033
- C5034
- C5035
- C5036
- C5037
- C5039
- C5040
- C5041
- C5042
- C5043
- C5044
- C5047
- C5048
- C5049
- C5050
- C5051
- C5052
- C5053
- C5054
- C5055
- C5056
- C5057
- C5058
- C5059
- C5060
- C5061
- C5062
- C5063
- C5100
- C5101
- C5102
- C5103
- C5104
- C5106
- C5107
- C5108
- C5200
- C5201
- C5202
- C5203
- C5204
- C5205
- C5206
- C5207
ms.openlocfilehash: 71a924982a1375f378e6935859aae05f0298bd22
ms.sourcegitcommit: 00af3df3331854b23693ee844e5e7c10c8b05a90
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/20/2020
ms.locfileid: "86491396"
---
# <a name="compiler-warnings-c4800-through-c5999"></a>编译器警告 C4800 - C5999

文档的本节中的文章介绍了编译器生成的一小部分警告消息。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="warning-messages"></a>警告消息

| 警告 | Message |
|--|--|
| [编译器警告（等级4） C4800](compiler-warning-level-3-c4800.md) | 从 "*type*" 隐式转换为 `bool` 。 可能的信息丢失 |
| [编译器警告（等级 1）C4803](compiler-warning-level-1-c4803.md) | "*method*"： raise 方法的存储类与事件 "*event*" 的存储类不同 |
| [编译器警告（等级 1）C4804](compiler-warning-level-1-c4804.md) | "*operation*"：在操作中使用类型 "" 不安全 `bool` |
| [编译器警告（等级 1）C4805](compiler-warning-level-1-c4805.md) | "*operation*"：在操作中类型 "*type1*" 和类型 "*type2*" 的混合不安全 |
| [编译器警告（等级 1）C4806](compiler-warning-level-1-c4806.md) | "*operation*"：不安全的操作：不能将类型 "*type1*" 的值提升为类型 "*type2*"，不能等于给定的常量 |
| [编译器警告（等级 1）C4807](compiler-warning-level-1-c4807.md) | "*operation*"：类型 "*type1*" 和 "*type2*" 类型的带符号位域的混合不安全 |
| 编译器警告（等级1） C4808 | `case`"*value*" 不是 `switch` "" 类型的条件的有效值 `bool` |
| 编译器警告（等级1） C4809 | `switch`语句具有冗余的 " `default` " 标签; 给定所有可能的 " `case` " 标签 |
| [编译器警告（等级 1）C4810](compiler-warning-level-1-c4810.md) | 值 `pragma pack(show)` = = n |
| [编译器警告（等级 1）C4811](compiler-warning-level-1-c4811.md) | `pragma conform(forScope, show)`  ==  *值*的值 |
| [编译器警告（等级 1）C4812](compiler-warning-level-1-c4812.md) | 过时的声明样式：请改用 "*new_syntax*" |
| [编译器警告（等级 1）C4813](compiler-warning-level-1-c4813.md) | "*function*"：局部类的友元函数以前必须已经声明 |
| [编译器警告（等级 4）C4816](compiler-warning-level-4-c4816.md) | "*param*"：参数具有一个零大小的数组，该数组将被截断（除非该对象通过引用传递） |
| [编译器警告（等级 1）C4817](compiler-warning-level-1-c4817.md) | "*member*"：非法使用 "." 访问此成员;编译器替换为 "->" |
| [编译器警告（等级 1）C4819](compiler-warning-level-1-c4819.md) | 该文件包含不能在当前代码页（数字）中表示的字符。 以 Unicode 格式保存该文件以防止数据丢失 |
| [编译器警告（等级 4）C4820](compiler-warning-level-4-c4820.md) | 在构造 "*member_name*" 后添加了 "*bytes*" 字节填充 |
| [编译器警告（等级 1）C4821](compiler-warning-level-1-c4821.md) | 无法确定 Unicode 编码类型，请用签名（BOM）保存文件 |
| [编译器警告（等级 1）C4822](compiler-warning-level-1-c4822.md) | "成员函数"：局部类成员函数没有主体 |
| [编译器警告（等级 3）C4823](compiler-warning-level-3-c4823.md) | "*function*"：使用钉住指针，但未启用展开语义。 请考虑使用`/EHa` |
| 编译器警告（等级2） C4826 | 从 "*type1*" 到 "*type2*" 的转换是带符号扩展的。 这可能导致意外的运行时行为。 |
| 编译器警告（等级3） C4827 | `ToString`带有0个参数的公共 "" 方法应标记为 `virtual` 和`override` |
| [编译器警告（等级 1）C4829](compiler-warning-level-1-c4829.md) | 要运行的参数可能不正确 `main` 。 考虑 " `int main(Platform::Array<Platform::String^>^ argv)` " |
| [编译器警告（等级 1）C4835](compiler-warning-level-1-c4835.md) | "*variable*"：在主机程序集中首次执行托管代码时，导出数据的初始值设定项将不会运行 |
| 编译器警告（等级4） C4837 | 检测到三元组： " `??` *character*" 替换为 "*character*" |
| [编译器警告（等级 1）C4838](compiler-warning-level-1-c4838.md) | 从 "*type_1*" 转换到 "*type_2*" 需要收缩转换 |
| [编译器警告（等级 3）C4839](compiler-warning-level-3-c4839.md) | 类 "*type*" 作为可变参数函数的参数的非标准用法 |
| [编译器警告（等级 4）C4840](compiler-warning-level-4-c4840.md) | 类 "*type*" 作为可变参数函数的参数的不可移植使用 |
| 编译器警告（等级4） C4841 | 使用的非标准扩展：在中使用的复合成员指示符`offsetof` |
| 编译器警告（等级4） C4842 | `offsetof`使用多重继承应用到类型的 "" 的结果不保证在编译器版本之间保持一致 |
| 编译器警告 C4843 | "*type1*"：对数组或函数类型的引用的异常处理程序不可访问，请改用 "*type2*" |
| 编译器警告 C4844 | " `export module` *`module_name`* `;` " 现在是用于声明模块接口的首选语法 |
| 编译器警告（等级4） C4845 | `__declspec(no_init_all)`如果 `/d1initall[0|1|2|3]` 未在命令行上指定 ""，则忽略 "" |
| 编译器警告（等级4） C4846 | "*value*" 不是 "" 的有效参数 `/d1initall` ：已忽略命令行标志 |
| 编译器警告（等级4） C4847 | " `__declspec(no_init_all)` " 只能应用于函数、类类型或局部变量：忽略 |
| 编译器警告（等级1） C4848 | `no_unique_address`c + + 17 及更早版本中的标准特性 "" 的支持是一个供应商扩展 |
| 编译器警告 C4854 | 绑定取消引用 null 指针到引用具有未定义的行为 |
| 编译器警告 C4855 | `this` `[=]` 已在 "version" 中弃用了通过 "" 隐式捕获 "" |
| 编译器警告 C4856 | "*value*" 不是 "" 的有效参数 `/d1initAll:FillPattern` （值必须介于0到255之间）。 已忽略命令行标志 |
| 编译器警告 C4857 | C + +/CLI 模式不支持比 c + + 17 更高的版本的 c + +将语言设置为`/std:c++17` |
| [编译器警告（等级 4）C4866](c4866.md) | 对于调用*operator_name* ，编译器可能不会强制执行从左到右的计算顺序 |
| [编译器警告（错误） C4867](compiler-warning-c4867.md) | "*function*"：函数调用缺少参数列表;使用 "*call*" 创建指向成员的指针 |
| [编译器警告（等级4） C4868](compiler-warning-c4868.md) | "_file_（*line_number*）" 编译器不能在大括号内初始化列表中强制执行从左到右的计算顺序 |
| 编译器警告（等级2） C4872 | 编译的调用关系图时，检测到浮点数被零除 `concurrency::parallel_for_each` ： "*location*" |
| 编译器警告（等级1） C4880 | 从 "const *type_1*" 强制转换为 "*type_2*"：从指针或引用强制转换 constness 可能会导致 amp 限制函数中出现未定义的行为 |
| 编译器警告（等级4） C4881 | 对于 `tile_static` 变量 "*variable-name*"，将不会调用构造函数和/或析构函数 |
| 编译器警告（等级1） C4882 | 不推荐将使用非常量调用运算符的函子传递给 `concurrency::parallel_for_each` |
| [编译器警告 C4900](compiler-warning-level-1-c4900.md) | "*Tool1*" 版本 "*version1*" 和 "*tool2*" 版本 "*version2*" 之间的 Il 不匹配 |
| [编译器警告（等级 1）C4905](compiler-warning-level-1-c4905.md) | 宽字符串文本强制转换为 " `LPSTR` " |
| [编译器警告（等级 1）C4906](compiler-warning-level-1-c4906.md) | 字符串文本强制转换为 " `LPWSTR` " |
| [编译器警告（等级 1）C4910](compiler-warning-level-1-c4910.md) | " \<identifier> ：" __declspec （dllexport） "和" extern "在显式实例化上不兼容 |
| [编译器警告（等级 1）C4912](compiler-warning-level-1-c4912.md) | "*attribute*"：特性在嵌套 UDT 上具有未定义的行为 |
| [编译器警告（等级 4）C4913](compiler-warning-level-4-c4913.md) | 存在用户定义的二进制运算符 " `,` "，但没有重载可以转换所有操作数，使用了默认的内置二进制运算符 " `,` " |
| 编译器警告（等级1） C4916 | 若要具有 `dispid` "*description*"：必须通过接口引入 |
| [编译器警告（等级 1）C4917](compiler-warning-level-1-c4917.md) | "*声明符*"： GUID 只能与类、接口或命名空间关联 |
| [编译器警告（等级 4）C4918](compiler-warning-level-4-c4918.md) | "*character*"：杂注优化列表中的无效字符 |
| [编译器警告（等级 1）C4920](compiler-warning-level-1-c4920.md) | 枚举枚举*名称*成员*member_1* = 在枚举*枚举名称*中*value_1*已显示为*member_2* = *value_2* |
| 编译器警告（等级3） C4921 | "*description*"：不应多次指定特性值 "*attribute*" |
| [编译器警告（等级 1）C4925](compiler-warning-level-1-c4925.md) | "*method*"：不能从脚本调用调度接口方法 |
| [编译器警告（等级 1）C4926](compiler-warning-level-1-c4926.md) | "*identifier*"：已定义符号：忽略特性 |
| [编译器警告（等级 1）C4927](compiler-warning-level-1-c4927.md) | 非法转换;已隐式应用了多个用户定义的转换 |
| [编译器警告（等级 1）C4928](compiler-warning-level-1-c4928.md) | 副本初始化非法；隐式应用了多个用户定义的转换 |
| [编译器警告（等级 1）C4929](compiler-warning-level-1-c4929.md) | "*file*"：类型库包含联合;忽略 "embedded_idl" 限定符 |
| [编译器警告（等级 1）C4930](compiler-warning-level-1-c4930.md) | "*原型*"：未调用原型函数（是否是有意用变量定义的？） |
| [编译器警告（等级 4）C4931](compiler-warning-level-4-c4931.md) | 假定类型库是为*数字*位指针生成的 |
| [编译器警告（等级 4）C4932](compiler-warning-level-4-c4932.md) | `__identifier(`*标识符* `)`和 `__identifier(` *标识符* `)` 不区分 |
| 编译器警告（等级1） C4934 | " `__delegate(multicast)` " 已弃用，请改用 " `__delegate` " |
| [编译器警告（等级 1）C4935](compiler-warning-level-1-c4935.md) | 程序集访问说明符已从 "*access*" 修改 |
| [编译器警告（等级1，错误） C4936](compiler-warning-c4936.md) | 仅当用或编译时，才支持此 __declspec `/clr``/clr:pure` |
| [编译器警告（等级 4）C4937](compiler-warning-level-4-c4937.md) | "*text1*" 和 "*文本 2*" 作为 "*指令*" 的参数不可区分 |
| [编译器警告（等级 4）C4938](compiler-warning-level-4-c4938.md) | "*var*"：浮点缩减变量可能会导致或下的结果不一致 `/fp:strict``#pragma fenv_access` |
| [编译器警告 C4939](compiler-warning-level-1-c4939.md) | #pragma vtordisp 已被否决，并将在 Visual C++ 将来的版本移除 |
| [编译器警告（等级 1）C4944](compiler-warning-level-1-c4944.md) | "*symbol*"：无法从 "*assembly1*" 导入符号：因为当前范围内已存在 "*symbol*" |
| [编译器警告（等级 1）C4945](compiler-warning-level-1-c4945.md) | "*symbol*"：无法从 "*assembly1*" 导入符号：因为 "*symbol*" 已从另一个程序集 "*assembly2*" 导入 |
| [编译器警告（等级 1）C4946](compiler-warning-level-1-c4946.md) | `reinterpret_cast`在相关类之间使用： "*class1*" 和 "*class2*" |
| [编译器警告（等级 1）C4947](compiler-warning-level-1-c4947.md) | "*type_or_member*"：标记为过时 |
| [编译器警告（等级 2）C4948](compiler-warning-level-2-c4948.md) | "*访问器*" 的返回类型与相应的 setter 的最后一个参数类型不匹配 |
| [编译器警告（等级 1 和 4）C4949](compiler-warning-level-1-and-level-4-c4949.md) | `managed` `unmanaged` 仅当用 "" 编译时，杂注 "" 和 "" 才有意义 `/clr[:option]` |
| [编译器警告（等级1，错误） C4950](compiler-warning-c4950.md) | "*type_or_member*"：标记为过时 |
| [编译器警告（等级 1）C4951](compiler-warning-level-1-c4951.md) | 自收集配置文件数据后已编辑过 "*函数*"，未使用函数配置文件数据 |
| [编译器警告（等级 1）C4952](compiler-warning-level-1-c4952.md) | "*function*"：在程序数据库 "*.pgd-file*" 中找不到配置文件数据 |
| [编译器警告（等级 1）C4953](compiler-warning-level-1-c4953.md) | 自收集配置文件数据后已编辑被内联方 "*function*"，未使用配置文件数据 |
| 编译器警告 C4954 | "*function*"：未分析（包含 `__int64` switch 表达式） |
| 编译器警告 C4955 | "*import2*"：忽略导入;已从 "*import1*" 导入 |
| [编译器警告（等级1，错误） C4956](compiler-warning-c4956.md) | "*type*"：此类型是不可验证的 |
| [编译器警告（等级1，错误） C4957](compiler-warning-c4957.md) | "*cast*"：从 "*cast_from*" 到 "*cast_to*" 的显式强制转换是不可验证的 |
| [编译器警告（等级1，错误） C4958](compiler-warning-c4958.md) | "*operation*"：指针算法是不可验证的 |
| [编译器警告（等级1，错误） C4959](compiler-warning-c4959.md) | 无法在中定义非托管类型 "*type*"， `/clr:safe` 因为访问其成员会产生不可验证的代码 |
| [编译器警告（等级 4）C4960](compiler-warning-level-4-c4960.md) | "*function*" 太大，无法进行分析 |
| [编译器警告（等级1） C4961](compiler-warning-c4961.md) | 未将任何配置文件数据合并到 "*pgd 文件*"，已禁用按配置文件优化 |
| [编译器警告（等级4） C4962](compiler-warning-c4962.md) | "*function*"：已禁用按配置文件优化，因为优化导致配置文件数据变得不一致 |
| 编译器警告（等级1） C4963 | "*description*"：未找到配置文件数据;在检测的生成中使用了不同的编译器选项 |
| [编译器警告（等级 1）C4964](compiler-warning-level-1-c4964.md) | 未指定优化选项;不会收集配置文件信息 |
| [编译器警告（等级 1）C4965](compiler-warning-level-1-c4965.md) | 整数0的隐式框;使用 nullptr 或显式强制转换 |
| 编译器警告（等级1） C4966 | "*function*" 的 `__code_seg` 批注具有不受支持的段名称，已忽略批注 |
| 编译器警告 C4970 | 委托构造函数：由于 "*type*" 是静态的，因此忽略了目标对象 |
| 编译器警告（等级1） C4971 | 参数顺序： \<target object> \<target function> 对于委托构造函数，不推荐使用 \<target function> ，\<target object=""> |
| [编译器警告（等级1，错误） C4972](compiler-warning-c4972.md) | 直接修改取消装箱操作的结果或将其视为左值是不可验证的 |
| 编译器警告（等级1） C4973 | "*symbol*"：标记为已弃用 |
| 编译器警告（等级1） C4974 | "*symbol*"：标记为已弃用 |
| 编译器警告（等级3） C4981 | Warbird：标记为 __forceinline 的函数 "*function*" 未内联，因为该函数包含异常语义 |
| [编译器警告 C4984](compiler-warning-c4984.md) | " `if constexpr` " 是 c + + 17 语言扩展 |
| [编译器警告（等级 4）C4985](compiler-warning-level-4-c4985.md) | "*symbol_name*"：以前的声明上不存在特性。 |
| [编译器警告 C4986](compiler-warning-c4986.md) | "*声明*"：异常规范与前面的声明不匹配 |
| 编译器警告（等级4） C4987 | 使用了非标准扩展： " `throw (...)` " |
| 编译器警告（等级4） C4988 | "*variable*"：在类/函数范围外声明的变量 |
| 编译器警告（等级4） C4989 | "*type*"：类型包含冲突的定义。 |
| 编译器警告（等级3） C4990 | Warbird：*消息* |
| 编译器警告（等级3） C4991 | Warbird：函数 "*function*" 被标记为 `__forceinline` 未内联，因为被内联方的保护级别大于父级 |
| 编译器警告（等级3） C4992 | Warbird：函数 "*function name*" 标记为 `__forceinline` 未内联，因为该函数包含无法保护的内联程序集 |
| [编译器警告（等级 3）C4995](compiler-warning-level-3-c4995.md) | "*function*"：名称被标记为 #pragma 不推荐使用 |
| [编译器警告（等级 3）C4996](compiler-warning-level-3-c4996.md) | "已*弃用-声明*"：*弃用消息*（或 "已声明为不推荐使用"） |
| [编译器警告（等级 1）C4997](compiler-warning-level-1-c4997.md) | "*class*"：组件类不实现 COM 接口或伪接口 |
| 编译器警告（等级1） C4998 | 预期失败：*预期*（*值*） |
| [编译器警告 C4999](compiler-warning-level-1-c4999.md) | 未知警告请选择 Visual C++ "帮助" 菜单上的 "技术支持" 命令，或打开技术支持帮助文件以获取详细信息 |
| 编译器警告 C5022 | "*type*"：指定了多个移动构造函数 |
| 编译器警告 C5023 | "*type*"：指定了多个移动赋值运算符 |
| 编译器警告（等级4） C5024 | "*type*"：移动构造函数被隐式定义为已删除 |
| 编译器警告（等级4） C5025 | "*type*"：移动赋值运算符被隐式定义为已删除 |
| 编译器警告（等级1和等级4） C5026 | "*type*"：移动构造函数被隐式定义为已删除 |
| 编译器警告（等级1和等级4） C5027 | "*type*"：移动赋值运算符被隐式定义为已删除 |
| 编译器警告（等级1） C5028 | "*name*"：定义中未指定先前声明（*数字*）中指定的对齐方式 |
| 编译器警告（等级4） C5029 | 使用了非标准扩展： c + + 中的对齐属性只适用于变量、数据成员和标记类型 |
| 编译器警告（等级3） C5030 | 无法识别属性 "*attribute-name*" |
| 编译器警告（等级4） C5031 | `#pragma warning(pop)`：可能不匹配，正在弹出的警告状态已推送到其他文件中 |
| 编译器警告（等级4） C5032 | 检测到 `#pragma warning(push)` 没有对应的`#pragma warning(pop)` |
| 编译器警告（等级1） C5033 | "*存储类*" 不再是受支持的存储类 |
| 编译器警告 C5034 | 使用内部 "*内部*" 导致函数*函数名称*编译为来宾代码 |
| 编译器警告 C5035 | 使用功能 "*feature*" 导致函数*函数名称*编译为来宾代码 |
| 编译器警告（等级1） C5036 | 在用 `/hybrid:x86arm64` "*type1*" 编译到 "*type2*" 时，varargs 函数指针转换 |
| 编译器警告（错误） C5037 | "*member function*"：类模板成员的外定义不能有默认参数 |
| [编译器警告（等级4） C5038](c5038.md) | 数据成员 "*member1*" 将在数据成员 "*member2*" 后初始化 |
| 编译器警告（等级4） C5039 | "*function*"：指向在下传递到函数的可能引发函数的指针或引用 `extern C` `-EHc` 。 如果此函数引发异常，则可能出现未定义的行为。 |
| 编译器警告（等级3） C5040 | 动态异常规范仅在 c + + 14 及更早版本中有效;视为 noexcept （false） |
| 编译器警告（等级1） C5041 | "*定义*"：不需要对 constexpr 静态数据成员进行外定义，且在 c + + 17 中已弃用 |
| 编译器警告（等级3） C5042 | "*声明*"：不能在标准 c + + 中指定块范围内的函数声明;删除 "内联" 说明符 |
| 编译器警告（等级2） C5043 | "*规范*"：异常规范与前面的声明不匹配 |
| 编译器警告（等级4） C5044 | 命令行选项选项的参数 *-名称*指向不存在的路径 "*path-name*" |
| [编译器警告 C5045](c5045.md) | 如果指定了/Qspectre 开关，编译器将为内存加载插入 Spectre 缓解措施 |
| [编译器警告（等级 2）C5046](c5046.md) | "*function*"：未定义包含带有内部链接的类型的符号 |
| 编译器警告（等级1） C5047 | `__if_exists`不支持在模块中使用非标准模块 |
| 编译器警告（等级1） C5048 | 使用宏 "*macroname*" 可能会导致非确定性输出 |
| 编译器警告（等级1） C5049 | "*string*"：嵌入完整路径可能导致依赖于计算机的输出 |
| 编译器警告（等级1） C5050 | 导入模块 "*module_name*" 时可能不兼容的环境：*问题* |
| 编译器警告 C5051 | 特性 "attribute-name" 至少需要 "标准级别";掉 |
| 编译器警告 C5052 | 关键字 "关键字-name" 是在 c + + 中引入的 \<version> ，要求使用 "选项名" 命令行选项 |
| 编译器警告 C5053 | `explicit(<expr>)`c + + 17 及更早版本中对 "" 的支持是供应商扩展 |
| 编译器警告 C5054 | 运算符 "operator-name"：不同类型的枚举不推荐使用 |
| 编译器警告 C5055 | 运算符 "operator-name"：枚举和浮点类型之间不推荐使用 |
| 编译器警告 C5056 | 运算符 "operator-name"：数组类型已弃用 |
| 编译器警告 C5057 | 对 "name" 的标头单元引用已存在。  忽略标头单元 "标头名称" |
| 编译器警告 C5058 | 文件系统错误：找不到标头单元 "unit-name" 的头文件 "file name" |
| 编译器警告 C5059 | 当前不支持运行时检查和地址 sanitizer-正在禁用运行时检查 |
| 编译器警告 C5060 | `/Qpar`和 address sanitizer 当前不支持-禁用自动并行化 |
| 编译器警告 C5061 | 已弃用使用逗号运算符作为下标表达式 |
| 编译器警告 C5062 | 不再支持 "type-1" 和 "type-2" 之间的枚举直接列表初始化 |
| 编译器警告 C5063 | `std::is_constant_evaluated`在 manifestly 常量计算的表达式中，"" 的计算结果始终为 true |
| 编译器警告（等级1） C5100 | `__VA_ARGS__`保留以用于可变参数宏 |
| 编译器警告（等级1） C5101 | 类似于函数的宏参数列表中的预处理器指令的用法是未定义的行为 |
| 编译器警告（等级1） C5102 | 忽略无效的命令行宏定义 "*value*" |
| 编译器警告（等级1） C5103 | 粘贴 "*token1*" 和 "*token2*" 不会生成有效的预处理令牌 |
| 编译器警告（等级1） C5104 | 在宏替换列表中找到了 "*string1* `#` *string2*"，是否表示 "*string1* `""#` *string2*"？ |
| [编译器警告（等级 1）C5105](c5105.md) | 生成 "已定义" 的宏扩展具有未定义的行为 |
| 编译器警告（等级1） C5106 | 用不同的参数名称重新定义了宏 |
| 编译器警告（等级1） C5107 | 缺少终止 "*char*" 字符 |
| 编译器警告 C5108 | `__VA_OPT__`保留以用于可变参数宏 |
| 编译器警告 C5200 | 功能 "feature-name" 需要编译器标志 "option-name" |
| 编译器警告 C5201 | 模块声明只能在翻译单元的开头出现，除非使用全局模块片段 |
| 编译器警告 C5202 | 全局模块段只能包含预处理器指令 |
| 编译器警告 C5203 | 在 c + + 中，"explicit" 后带圆括号的声明符名称将被视为显式说明符 |
| 编译器警告 C5204 | "type name"：类有虚函数，但其普通析构函数不是虚拟的;从此类派生的对象的实例可能不能正确销毁 |
| 编译器警告 C5205 | 删除具有非虚拟析构函数的抽象类 "type name" 会导致未定义的行为 |
| 编译器警告 C5206 | 推导协同程序的返回类型是非标准扩展 |
| 编译器警告 C5207 | 简单要求断言表达式 "" 的有效性 `e->id` 。 你的意思是 " `{ e } -> id` " 吗？ 你可以使用 "" 禁止显示此警告 `{ e->id }` |
| [编译器警告（等级1） C5208](c5208.md) | 名称中使用的未命名类 `typedef` 不能声明非静态数据成员、成员枚举或成员类以外的成员 |

## <a name="see-also"></a>另请参阅

[C/c + + 编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器警告 C4000 - C5999](compiler-warnings-c4000-c5999.md)
