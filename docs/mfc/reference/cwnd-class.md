---
title: CWnd 类
ms.date: 11/19/2018
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
helpviewer_keywords:
- CWnd [MFC], CWnd
- CWnd [MFC], accDoDefaultAction
- CWnd [MFC], accHitTest
- CWnd [MFC], accLocation
- CWnd [MFC], accNavigate
- CWnd [MFC], accSelect
- CWnd [MFC], AnimateWindow
- CWnd [MFC], ArrangeIconicWindows
- CWnd [MFC], Attach
- CWnd [MFC], BeginModalState
- CWnd [MFC], BeginPaint
- CWnd [MFC], BindDefaultProperty
- CWnd [MFC], BindProperty
- CWnd [MFC], BringWindowToTop
- CWnd [MFC], CalcWindowRect
- CWnd [MFC], CancelToolTips
- CWnd [MFC], CenterWindow
- CWnd [MFC], ChangeClipboardChain
- CWnd [MFC], CheckDlgButton
- CWnd [MFC], CheckRadioButton
- CWnd [MFC], ChildWindowFromPoint
- CWnd [MFC], ClientToScreen
- CWnd [MFC], CloseWindow
- CWnd [MFC], ContinueModal
- CWnd [MFC], Create
- CWnd [MFC], CreateAccessibleProxy
- CWnd [MFC], CreateCaret
- CWnd [MFC], CreateControl
- CWnd [MFC], CreateEx
- CWnd [MFC], CreateGrayCaret
- CWnd [MFC], CreateSolidCaret
- CWnd [MFC], DeleteTempMap
- CWnd [MFC], DestroyWindow
- CWnd [MFC], Detach
- CWnd [MFC], DlgDirList
- CWnd [MFC], DlgDirListComboBox
- CWnd [MFC], DlgDirSelect
- CWnd [MFC], DlgDirSelectComboBox
- CWnd [MFC], DragAcceptFiles
- CWnd [MFC], DragDetect
- CWnd [MFC], DrawAnimatedRects
- CWnd [MFC], DrawCaption
- CWnd [MFC], DrawMenuBar
- CWnd [MFC], EnableActiveAccessibility
- CWnd [MFC], EnableDynamicLayout
- CWnd [MFC], EnableD2DSupport
- CWnd [MFC], EnableScrollBar
- CWnd [MFC], EnableScrollBarCtrl
- CWnd [MFC], EnableToolTips
- CWnd [MFC], EnableTrackingToolTips
- CWnd [MFC], EnableWindow
- CWnd [MFC], EndModalLoop
- CWnd [MFC], EndModalState
- CWnd [MFC], EndPaint
- CWnd [MFC], ExecuteDlgInit
- CWnd [MFC], FilterToolTipMessage
- CWnd [MFC], FindWindow
- CWnd [MFC], FindWindowEx
- CWnd [MFC], FlashWindow
- CWnd [MFC], FlashWindowEx
- CWnd [MFC], FromHandle
- CWnd [MFC], FromHandlePermanent
- CWnd [MFC], get_accChild
- CWnd [MFC], get_accChildCount
- CWnd [MFC], get_accDefaultAction
- CWnd [MFC], get_accDescription
- CWnd [MFC], get_accFocus
- CWnd [MFC], get_accHelp
- CWnd [MFC], get_accHelpTopic
- CWnd [MFC], get_accKeyboardShortcut
- CWnd [MFC], get_accName
- CWnd [MFC], get_accParent
- CWnd [MFC], get_accRole
- CWnd [MFC], get_accSelection
- CWnd [MFC], get_accState
- CWnd [MFC], get_accValue
- CWnd [MFC], GetActiveWindow
- CWnd [MFC], GetAncestor
- CWnd [MFC], GetCapture
- CWnd [MFC], GetCaretPos
- CWnd [MFC], GetCheckedRadioButton
- CWnd [MFC], GetClientRect
- CWnd [MFC], GetClipboardOwner
- CWnd [MFC], GetClipboardViewer
- CWnd [MFC], GetControlUnknown
- CWnd [MFC], GetDC
- CWnd [MFC], GetDCEx
- CWnd [MFC], GetDCRenderTarget
- CWnd [MFC], GetDescendantWindow
- CWnd [MFC], GetDesktopWindow
- CWnd [MFC], GetDlgCtrlID
- CWnd [MFC], GetDlgItem
- CWnd [MFC], GetDlgItemInt
- CWnd [MFC], GetDlgItemText
- CWnd [MFC], GetDSCCursor
- CWnd [MFC], GetDynamicLayout
- CWnd [MFC], GetExStyle
- CWnd [MFC], GetFocus
- CWnd [MFC], GetFont
- CWnd [MFC], GetForegroundWindow
- CWnd [MFC], GetIcon
- CWnd [MFC], GetLastActivePopup
- CWnd [MFC], GetLayeredWindowAttributes
- CWnd [MFC], GetMenu
- CWnd [MFC], GetNextDlgGroupItem
- CWnd [MFC], GetNextDlgTabItem
- CWnd [MFC], GetNextWindow
- CWnd [MFC], GetOleControlSite
- CWnd [MFC], GetOpenClipboardWindow
- CWnd [MFC], GetOwner
- CWnd [MFC], GetParent
- CWnd [MFC], GetParentFrame
- CWnd [MFC], GetParentOwner
- CWnd [MFC], GetProperty
- CWnd [MFC], GetRenderTarget
- CWnd [MFC], GetSafeHwnd
- CWnd [MFC], GetSafeOwner
- CWnd [MFC], GetScrollBarCtrl
- CWnd [MFC], GetScrollBarInfo
- CWnd [MFC], GetScrollInfo
- CWnd [MFC], GetScrollLimit
- CWnd [MFC], GetScrollPos
- CWnd [MFC], GetScrollRange
- CWnd [MFC], GetStyle
- CWnd [MFC], GetSystemMenu
- CWnd [MFC], GetTitleBarInfo
- CWnd [MFC], GetTopLevelFrame
- CWnd [MFC], GetTopLevelOwner
- CWnd [MFC], GetTopLevelParent
- CWnd [MFC], GetTopWindow
- CWnd [MFC], GetUpdateRect
- CWnd [MFC], GetUpdateRgn
- CWnd [MFC], GetWindow
- CWnd [MFC], GetWindowContextHelpId
- CWnd [MFC], GetWindowDC
- CWnd [MFC], GetWindowedChildCount
- CWnd [MFC], GetWindowInfo
- CWnd [MFC], GetWindowlessChildCount
- CWnd [MFC], GetWindowPlacement
- CWnd [MFC], GetWindowRect
- CWnd [MFC], GetWindowRgn
- CWnd [MFC], GetWindowText
- CWnd [MFC], GetWindowTextLength
- CWnd [MFC], HideCaret
- CWnd [MFC], HiliteMenuItem
- CWnd [MFC], HtmlHelp
- CWnd [MFC], Invalidate
- CWnd [MFC], InvalidateRect
- CWnd [MFC], InvalidateRgn
- CWnd [MFC], InvokeHelper
- CWnd [MFC], IsChild
- CWnd [MFC], IsD2DSupportEnabled
- CWnd [MFC], IsDialogMessage
- CWnd [MFC], IsDlgButtonChecked
- CWnd [MFC], IsDynamicLayoutEnabled
- CWnd [MFC], IsIconic
- CWnd [MFC], IsTouchWindow
- CWnd [MFC], IsWindowEnabled
- CWnd [MFC], IsWindowVisible
- CWnd [MFC], IsZoomed
- CWnd [MFC], KillTimer
- CWnd [MFC], LockWindowUpdate
- CWnd [MFC], MapWindowPoints
- CWnd [MFC], MessageBox
- CWnd [MFC], ModifyStyle
- CWnd [MFC], ModifyStyleEx
- CWnd [MFC], MoveWindow
- CWnd [MFC], NotifyWinEvent
- CWnd [MFC], OnAmbientProperty
- CWnd [MFC], OnDrawIconicThumbnailOrLivePreview
- CWnd [MFC], OnHelp
- CWnd [MFC], OnHelpFinder
- CWnd [MFC], OnHelpIndex
- CWnd [MFC], OnHelpUsing
- CWnd [MFC], OnToolHitTest
- CWnd [MFC], OpenClipboard
- CWnd [MFC], PaintWindowlessControls
- CWnd [MFC], PostMessage
- CWnd [MFC], PreCreateWindow
- CWnd [MFC], PreSubclassWindow
- CWnd [MFC], PreTranslateMessage
- CWnd [MFC], Print
- CWnd [MFC], PrintClient
- CWnd [MFC], PrintWindow
- CWnd [MFC], RedrawWindow
- CWnd [MFC], RegisterTouchWindow
- CWnd [MFC], ReleaseDC
- CWnd [MFC], RepositionBars
- CWnd [MFC], RunModalLoop
- CWnd [MFC], ScreenToClient
- CWnd [MFC], ScrollWindow
- CWnd [MFC], ScrollWindowEx
- CWnd [MFC], SendChildNotifyLastMsg
- CWnd [MFC], SendDlgItemMessage
- CWnd [MFC], SendMessage
- CWnd [MFC], SendMessageToDescendants
- CWnd [MFC], SendNotifyMessage
- CWnd [MFC], SetActiveWindow
- CWnd [MFC], SetCapture
- CWnd [MFC], SetCaretPos
- CWnd [MFC], SetClipboardViewer
- CWnd [MFC], SetDlgCtrlID
- CWnd [MFC], SetDlgItemInt
- CWnd [MFC], SetDlgItemText
- CWnd [MFC], SetFocus
- CWnd [MFC], SetFont
- CWnd [MFC], SetForegroundWindow
- CWnd [MFC], SetIcon
- CWnd [MFC], SetLayeredWindowAttributes
- CWnd [MFC], SetMenu
- CWnd [MFC], SetOwner
- CWnd [MFC], SetParent
- CWnd [MFC], SetProperty
- CWnd [MFC], SetRedraw
- CWnd [MFC], SetScrollInfo
- CWnd [MFC], SetScrollPos
- CWnd [MFC], SetScrollRange
- CWnd [MFC], SetTimer
- CWnd [MFC], SetWindowContextHelpId
- CWnd [MFC], SetWindowPlacement
- CWnd [MFC], SetWindowPos
- CWnd [MFC], SetWindowRgn
- CWnd [MFC], SetWindowText
- CWnd [MFC], ShowCaret
- CWnd [MFC], ShowOwnedPopups
- CWnd [MFC], ShowScrollBar
- CWnd [MFC], ShowWindow
- CWnd [MFC], SubclassDlgItem
- CWnd [MFC], SubclassWindow
- CWnd [MFC], UnlockWindowUpdate
- CWnd [MFC], UnsubclassWindow
- CWnd [MFC], UpdateData
- CWnd [MFC], UpdateDialogControls
- CWnd [MFC], UpdateLayeredWindow
- CWnd [MFC], UpdateWindow
- CWnd [MFC], ValidateRect
- CWnd [MFC], ValidateRgn
- CWnd [MFC], WindowFromPoint
- CWnd [MFC], WinHelp
- CWnd [MFC], Default
- CWnd [MFC], DefWindowProc
- CWnd [MFC], DoDataExchange
- CWnd [MFC], GetCurrentMessage
- CWnd [MFC], InitDynamicLayout
- CWnd [MFC], LoadDynamicLayoutResource
- CWnd [MFC], OnActivate
- CWnd [MFC], OnActivateApp
- CWnd [MFC], OnAppCommand
- CWnd [MFC], OnAskCbFormatName
- CWnd [MFC], OnCancelMode
- CWnd [MFC], OnCaptureChanged
- CWnd [MFC], OnChangeCbChain
- CWnd [MFC], OnChangeUIState
- CWnd [MFC], OnChar
- CWnd [MFC], OnCharToItem
- CWnd [MFC], OnChildActivate
- CWnd [MFC], OnChildNotify
- CWnd [MFC], OnClipboardUpdate
- CWnd [MFC], OnClose
- CWnd [MFC], OnColorizationColorChanged
- CWnd [MFC], OnCommand
- CWnd [MFC], OnCompacting
- CWnd [MFC], OnCompareItem
- CWnd [MFC], OnCompositionChanged
- CWnd [MFC], OnContextMenu
- CWnd [MFC], OnCopyData
- CWnd [MFC], OnCreate
- CWnd [MFC], OnCtlColor
- CWnd [MFC], OnDeadChar
- CWnd [MFC], OnDeleteItem
- CWnd [MFC], OnDestroy
- CWnd [MFC], OnDestroyClipboard
- CWnd [MFC], OnDeviceChange
- CWnd [MFC], OnDevModeChange
- CWnd [MFC], OnDrawClipboard
- CWnd [MFC], OnDrawItem
- CWnd [MFC], OnDropFiles
- CWnd [MFC], OnEnable
- CWnd [MFC], OnEndSession
- CWnd [MFC], OnEnterIdle
- CWnd [MFC], OnEnterMenuLoop
- CWnd [MFC], OnEnterSizeMove
- CWnd [MFC], OnEraseBkgnd
- CWnd [MFC], OnExitMenuLoop
- CWnd [MFC], OnExitSizeMove
- CWnd [MFC], OnFontChange
- CWnd [MFC], OnGetDlgCode
- CWnd [MFC], OnGetMinMaxInfo
- CWnd [MFC], OnHelpInfo
- CWnd [MFC], OnHotKey
- CWnd [MFC], OnHScroll
- CWnd [MFC], OnHScrollClipboard
- CWnd [MFC], OnIconEraseBkgnd
- CWnd [MFC], OnInitMenu
- CWnd [MFC], OnInitMenuPopup
- CWnd [MFC], OnInputDeviceChange
- CWnd [MFC], OnInputLangChange
- CWnd [MFC], OnInputLangChangeRequest
- CWnd [MFC], OnKeyDown
- CWnd [MFC], OnKeyUp
- CWnd [MFC], OnKillFocus
- CWnd [MFC], OnLButtonDblClk
- CWnd [MFC], OnLButtonDown
- CWnd [MFC], OnLButtonUp
- CWnd [MFC], OnMButtonDblClk
- CWnd [MFC], OnMButtonDown
- CWnd [MFC], OnMButtonUp
- CWnd [MFC], OnMDIActivate
- CWnd [MFC], OnMeasureItem
- CWnd [MFC], OnMenuChar
- CWnd [MFC], OnMenuDrag
- CWnd [MFC], OnMenuGetObject
- CWnd [MFC], OnMenuRButtonUp
- CWnd [MFC], OnMenuSelect
- CWnd [MFC], OnMouseActivate
- CWnd [MFC], OnMouseHover
- CWnd [MFC], OnMouseHWheel
- CWnd [MFC], OnMouseLeave
- CWnd [MFC], OnMouseMove
- CWnd [MFC], OnMouseWheel
- CWnd [MFC], OnMove
- CWnd [MFC], OnMoving
- CWnd [MFC], OnNcActivate
- CWnd [MFC], OnNcCalcSize
- CWnd [MFC], OnNcCreate
- CWnd [MFC], OnNcDestroy
- CWnd [MFC], OnNcHitTest
- CWnd [MFC], OnNcLButtonDblClk
- CWnd [MFC], OnNcLButtonDown
- CWnd [MFC], OnNcLButtonUp
- CWnd [MFC], OnNcMButtonDblClk
- CWnd [MFC], OnNcMButtonDown
- CWnd [MFC], OnNcMButtonUp
- CWnd [MFC], OnNcMouseHover
- CWnd [MFC], OnNcMouseLeave
- CWnd [MFC], OnNcMouseMove
- CWnd [MFC], OnNcPaint
- CWnd [MFC], OnNcRButtonDblClk
- CWnd [MFC], OnNcRButtonDown
- CWnd [MFC], OnNcRButtonUp
- CWnd [MFC], OnNcRenderingChanged
- CWnd [MFC], OnNcXButtonDblClk
- CWnd [MFC], OnNcXButtonDown
- CWnd [MFC], OnNcXButtonUp
- CWnd [MFC], OnNextMenu
- CWnd [MFC], OnNotify
- CWnd [MFC], OnNotifyFormat
- CWnd [MFC], OnPaint
- CWnd [MFC], OnPaintClipboard
- CWnd [MFC], OnPaletteChanged
- CWnd [MFC], OnPaletteIsChanging
- CWnd [MFC], OnParentNotify
- CWnd [MFC], OnPowerBroadcast
- CWnd [MFC], OnQueryDragIcon
- CWnd [MFC], OnQueryEndSession
- CWnd [MFC], OnQueryNewPalette
- CWnd [MFC], OnQueryOpen
- CWnd [MFC], OnQueryUIState
- CWnd [MFC], OnRawInput
- CWnd [MFC], OnRButtonDblClk
- CWnd [MFC], OnRButtonDown
- CWnd [MFC], OnRButtonUp
- CWnd [MFC], OnRenderAllFormats
- CWnd [MFC], OnRenderFormat
- CWnd [MFC], OnSessionChange
- CWnd [MFC], OnSetCursor
- CWnd [MFC], OnSetFocus
- CWnd [MFC], OnSettingChange
- CWnd [MFC], OnShowWindow
- CWnd [MFC], OnSize
- CWnd [MFC], OnSizeClipboard
- CWnd [MFC], OnSizing
- CWnd [MFC], OnSpoolerStatus
- CWnd [MFC], OnStyleChanged
- CWnd [MFC], OnStyleChanging
- CWnd [MFC], OnSysChar
- CWnd [MFC], OnSysColorChange
- CWnd [MFC], OnSysCommand
- CWnd [MFC], OnSysDeadChar
- CWnd [MFC], OnSysKeyDown
- CWnd [MFC], OnSysKeyUp
- CWnd [MFC], OnTCard
- CWnd [MFC], OnTimeChange
- CWnd [MFC], OnTimer
- CWnd [MFC], OnTouchInput
- CWnd [MFC], OnTouchInputs
- CWnd [MFC], OnUniChar
- CWnd [MFC], OnUnInitMenuPopup
- CWnd [MFC], OnUpdateUIState
- CWnd [MFC], OnUserChanged
- CWnd [MFC], OnVKeyToItem
- CWnd [MFC], OnVScroll
- CWnd [MFC], OnVScrollClipboard
- CWnd [MFC], OnWindowPosChanged
- CWnd [MFC], OnWindowPosChanging
- CWnd [MFC], OnWinIniChange
- CWnd [MFC], OnWndMsg
- CWnd [MFC], OnXButtonDblClk
- CWnd [MFC], OnXButtonDown
- CWnd [MFC], OnXButtonUp
- CWnd [MFC], PostNcDestroy
- CWnd [MFC], ReflectChildNotify
- CWnd [MFC], ReflectLastMsg
- CWnd [MFC], ResizeDynamicLayout
- CWnd [MFC], WindowProc
- CWnd [MFC], m_hWnd
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
ms.openlocfilehash: 12ba4cc28d94cbc2961475944c62d2e942b20c05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365934"
---
# <a name="cwnd-class"></a>CWnd 类

提供 Microsoft 基础类库中所有窗口类的基本功能。

## <a name="syntax"></a>语法

```
class CWnd : public CCmdTarget
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|[CWnd::CWnd](#cwnd)|构造 `CWnd` 对象。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由框架调用以执行对象的默认操作。|
|[CWnd::accHitTest](#acchittest)|由框架调用以检索屏幕上给定点处的子元素或子对象。|
|[CWnd::accLocation](#acclocation)|由框架调用以检索指定对象的当前屏幕位置。|
|[CWnd::accNavigate](#accnavigate)|由框架调用以移到容器内的另一个用户界面元素，如果可能还检索对象。|
|[CWnd::accSelect](#accselect)|由框架调用以修改选定内容或移动指定对象的键盘焦点。|
|[CWnd::AnimateWindow](#animatewindow)|对关联窗口对象进行动画处理。|
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化（图标）子窗口。|
|[CWnd::Attach](#attach)|将 Windows 句柄附加到 `CWnd` 对象。|
|[CWnd::BeginModalState](#beginmodalstate)|调用此成员函数以使框架窗口具有模式。|
|[CWnd::BeginPaint](#beginpaint)|为进行绘制准备好 `CWnd`。|
|[CWnd::BindDefaultProperty](#binddefaultproperty)|将调用对象的默认简单绑定属性（按照在类型库中进行的标记）绑定到与数据源控件关联的光标。|
|[CWnd::BindProperty](#bindproperty)|将数据绑定控件上的光标绑定属性绑定到数据源控件，并向 MFC 绑定管理器注册该关系。|
|[CWnd::BringWindowToTop](#bringwindowtotop)|将 `CWnd` 置于一堆重叠窗口的顶部。|
|[CWnd::CalcWindowRect](#calcwindowrect)|调用以从客户端矩形计算窗口矩形。|
|[CWnd::CancelToolTips](#canceltooltips)|禁用工具提示控件。|
|[CWnd::CenterWindow](#centerwindow)|使窗口相对于其父级居中。|
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|从剪贴板查看器链中移除 `CWnd`。|
|[CWnd::CheckDlgButton](#checkdlgbutton)|将复选标记置于按钮控件旁，或从按钮控件移除复选标记。|
|[CWnd::CheckRadioButton](#checkradiobutton)|选中指定单选按钮，并从指定按钮组中的所有其他单选按钮移除复选标记。|
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|确定哪些（如果有）子窗口包含指定点。|
|[CWnd::ClientToScreen](#clienttoscreen)|将显示中的给定点或矩形的客户端坐标转换为屏幕坐标。|
|[CWnd::CloseWindow](#closewindow)|最小化窗口。|
|[CWnd::ContinueModal](#continuemodal)|继续窗口的模式状态。|
|[CWnd::Create](#create)|创建并初始化与 `CWnd` 对象关联的子窗口。|
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|为指定对象创建 Active Accessibility 代理服务器。|
|[CWnd::CreateCaret](#createcaret)|为系统插入符号创建新形状并获取插入符号的所有权。|
|[CWnd::CreateControl](#createcontrol)|创建在 MFC 程序中由 `CWnd` 对象表示的 ActiveX 控件。|
|[CWnd::CreateEx](#createex)|创建 Windows 重叠、弹出或子窗口，并将它附加到 `CWnd` 对象。|
|[CWnd::CreateGrayCaret](#creategraycaret)|为系统插入符号创建灰色块并获取插入符号的所有权。|
|[CWnd::CreateSolidCaret](#createsolidcaret)|为系统插入符号创建实心块并获取插入符号的所有权。|
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 空闲时间处理程序自动调用，删除任何由 `FromHandle` 创建的临时 `CWnd` 对象。|
|[CWnd::DestroyWindow](#destroywindow)|销毁附加的 Windows 窗口。|
|[CWnd::Detach](#detach)|从 `CWnd` 对象分离 Windows 句柄并返回该句柄。|
|[CWnd::DlgDirList](#dlgdirlist)|使用文件或目录列表填充列表框。|
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用文件或目录列表填充组合框的列表框。|
|[CWnd::DlgDirSelect](#dlgdirselect)|从列表框检索当前所选内容。|
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|从组合框的列表框检索当前所选内容。|
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指示窗口将接受拖动的文件。|
|[CWnd::DragDetect](#dragdetect)|捕获鼠标并跟踪其移动，直到用户释放左键、按 ESC 键或将鼠标移动到围绕指定点的拖动矩形外部。|
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|绘制透明框架矩形并对它进行动画处理，以指示图标的打开或是窗口的最小化或最大化。|
|[CWnd::DrawCaption](#drawcaption)|绘制标题。|
|[CWnd::DrawMenuBar](#drawmenubar)|重绘菜单栏。|
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|启用用户定义的 `Active Accessibility` 函数。|
|[CWnd::EnableDynamicLayout](#enabledynamiclayout)|使子窗口的位置和大小可以在用户调整窗口大小时动态调整。|
|[CWnd::EnableD2DSupport](#enabled2dsupport)|启用或禁用窗口 `D2D` 支持。 在初始化主窗口之前调用此方法。|
|[CWnd::EnableScrollBar](#enablescrollbar)|启用或禁用滚动条的一个或两个箭头。|
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|启用或禁用同级滚动条控件。|
|[CWnd::EnableToolTips](#enabletooltips)|启用工具提示控件。|
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|在跟踪模式下启用工具提示控件。|
|[CWnd::EnableWindow](#enablewindow)|启用或禁用鼠标和键盘输入。|
|[CWnd::EndModalLoop](#endmodalloop)|启用窗口的模式状态。|
|[CWnd::EndModalState](#endmodalstate)|调用此成员函数以将框架窗口从有模式更改为无模式。|
|[CWnd::EndPaint](#endpaint)|标记绘制的末尾。|
|[CWnd::ExecuteDlgInit](#executedlginit)|启动对话框资源。|
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|检索与对话框中的控件关联的标题或文本。|
|[CWnd::FindWindow](#findwindow)|返回由其窗口名和窗口类标识的窗口的句柄。|
|[CWnd::FindWindowEx](#findwindowex)|返回由其窗口名和窗口类标识的窗口的句柄。|
|[CWnd::FlashWindow](#flashwindow)|使窗口闪烁一次。|
|[CWnd::FlashWindowEx](#flashwindowex)|使具有其他功能的窗口闪烁。|
|[CWnd::FromHandle](#fromhandle)|在提供了窗口的句柄时返回指向 `CWnd` 对象的指针。 如果 `CWnd` 对象未附加到该句柄，则会创建并附加一个临时 `CWnd` 对象。|
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|在提供了窗口的句柄时返回指向 `CWnd` 对象的指针。|
|[CWnd：get_accChild](#get_accchild)|由框架调用以检索指定子级的 `IDispatch` 接口地址。|
|[CWnd：get_accChildCount](#get_accchildcount)|由框架调用调用以检索属于该对象的子级的个数。|
|[CWnd：get_accDefaultAction](#get_accdefaultaction)|由框架调用以检索描述对象默认操作的字符串。|
|[CWnd::get_accDescription](#get_accdescription)|由框架调用以检索描述指定对象的可视外观的字符串。|
|[CWnd：get_accFocus](#get_accfocus)|由框架调用以检索具有键盘焦点的对象。|
|[CWnd：：get_accHelp](#get_acchelp)|由框架调用以检索对象的**帮助**属性字符串。|
|[CWnd：：get_accHelpTopic](#get_acchelptopic)|由框架调用以检索与指定对象关联的 `WinHelp` 文件的完整路径以及该文件内相应主题的标识符。|
|[CWnd：get_accKeyboardShortcut](#get_acckeyboardshortcut)|由框架调用以检索指定对象的快捷键或访问键。|
|[CWnd：：get_accName](#get_accname)|由框架调用以检索指定对象的名称。|
|[CWnd：get_accParent](#get_accparent)|由框架调用以检索对象父级的 `IDispatch` 接口。|
|[CWnd：：get_accRole](#get_accrole)|由框架调用以检索描述指定对象的角色的信息。|
|[CWnd：：get_accSelection](#get_accselection)|由框架调用以检索该对象的选定子级。|
|[CWnd：：get_accState](#get_accstate)|由框架调用以检索指定对象的当前状态。|
|[CWnd：get_accValue](#get_accvalue)|由框架调用以检索指定对象的值。|
|[CWnd：：获取活动窗口](#getactivewindow)|检索活动窗口。|
|[CWnd：获取祖先](#getancestor)|检索指定窗口的上级先窗口对象。|
|[CWnd：获取捕获](#getcapture)|检索具有鼠标捕获的 `CWnd`。|
|[CWnd：：获取卡斯特波斯](#getcaretpos)|检索插入符号的当前位置的客户端坐标。|
|[CWnd：：获取检查无线电按钮](#getcheckedradiobutton)|返回按钮中当前选中的单选按钮的 ID。|
|[CWnd：：获取客户](#getclientrect)|获取 `CWnd` 工作区的尺寸。|
|[CWnd：：获取剪贴板所有者](#getclipboardowner)|检索指向剪贴板当前所有者的指针。|
|[CWnd：：获取剪贴板查看器](#getclipboardviewer)|检索指向剪贴板查看器链中第一个窗口的指针。|
|[CWnd：：获取控制未知](#getcontrolunknown)|检索指向未知 ActiveX 控件的指针。|
|[CWnd：GetDC](#getdc)|检索工作区的显示上下文。|
|[CWnd：：获取DCEx](#getdcex)|检索工作区的显示上下文，并在绘制启用剪辑。|
|[CWnd：：获取DCRender目标](#getdcrendertarget)|检索 `CWnd` 窗口的设备上下文 (DC) 呈现目标。|
|[Cwnd：获取窗口](#getdescendantwindow)|搜索所有子代窗口，并返回具有指定 ID 的窗口。|
|[CWnd：：获取桌面窗口](#getdesktopwindow)|检索 Windows 桌面窗口。|
|[CWnd：：GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子窗口，则调用此函数会返回其 ID 值。|
|[CWnd：：GetDlgItem](#getdlgitem)|从指定对话框中检索具有指定 ID 的控件。|
|[Cwnd：：GetDlgItemint](#getdlgitemint)|将给定对话框中控件的文本转换为整数值。|
|[CWnd：：GetDlgItemText](#getdlgitemtext)|检索与控件关联的标题或文本。|
|[CWnd::GetDSCCursor](#getdsccursor)|检索指向由数据源控件的 DataSource、UserName、Password 和 SQL 属性定义的基础光标的指针。|
|[CWnd：：获取动态布局](#getdynamiclayout)|检索指向动态布局管理器对象的指针。|
|[CWnd：：获取样式](#getexstyle)|返回窗口的扩展样式。|
|[CWnd：获取焦点](#getfocus)|检索当前具有输入焦点的 `CWnd`。|
|[CWnd：：获取字体](#getfont)|检索当前字体。|
|[CWnd::GetForegroundWindow](#getforegroundwindow)|返回指向前台窗口（用户当前正在使用的顶级窗口）的指针。|
|[CWnd：：GetIcon](#geticon)|检索图标的句柄。|
|[CWnd：：获取最后活动弹出](#getlastactivepopup)|确定最近处于活动状态的由 `CWnd` 拥有的弹出窗口。|
|[CWnd：：获取分层窗口属性](#getlayeredwindowattributes)|检索分层窗口的不透明度和透明度颜色键。|
|[CWnd：：获取菜单](#getmenu)|检索指向指定菜单的指针。|
|[CWnd：：获取NextDlg集团项目](#getnextdlggroupitem)|在控件组中搜索的下一个（或上一个）控件。|
|[CWnd：：获取NextDlgTab项目](#getnextdlgtabitem)|检索第一个控件，其[WS_TABSTOP](styles-used-by-mfc.md#window-styles)样式位于指定控件之后（或之前）。|
|[CWnd：：获取下一个窗口](#getnextwindow)|返回窗口管理器列表中的下一个（或上一个）窗口。|
|[CWnd：：获取 Ole 控制网站](#getolecontrolsite)|检索指定 ActiveX 控件的自定义站点。|
|[CWnd：：获取打开的剪贴板窗口](#getopenclipboardwindow)|检索指向当前打开剪贴板的窗口的指针。|
|[CWnd::GetOwner](#getowner)|检索指向 `CWnd` 所有者的指针。|
|[CWnd：：获取家长](#getparent)|检索 `CWnd` 的父窗口（如果有）。|
|[CWnd：：获取父系框架](#getparentframe)|检索 `CWnd` 对象的父框架窗口。|
|[CWnd：：获取家长所有者](#getparentowner)|返回指向子窗口的父窗口的指针。|
|[CWnd：获取财产](#getproperty)|检索 ActiveX 控件属性。|
|[CWnd：：获取渲染目标](#getrendertarget)|获取与此窗口相关联的呈现目标。|
|[CWnd：：获取安全Hwnd](#getsafehwnd)|如果`m_hWnd`**此**指针为 NULL，则返回 或 NULL。|
|[CWnd：：获取安全所有者](#getsafeowner)|检索给定窗口的安全所有者。|
|[CWnd：：获取ScrollBarCtrl](#getscrollbarctrl)|返回同级滚动条控件。|
|[CWnd：：获取ScrollbarInfo](#getscrollbarinfo)|检索有关指定滚动条的信息。|
|[CWnd：：获取Scrollinfo](#getscrollinfo)|检索 `SCROLLINFO` 结构维护的有关滚动条的信息。|
|[CWnd：：获取滚动限制](#getscrolllimit)|检索滚动条的限制。|
|[CWnd：：获取ScrollPos](#getscrollpos)|检索滚动框的当前位置。|
|[CWnd：：获取滚动](#getscrollrange)|复制给定滚动条的当前最小和最大滚动条位置。|
|[CWnd：：获取风格](#getstyle)|返回当前窗口样式。|
|[CWnd：：获取系统菜单](#getsystemmenu)|允许应用程序访问控件菜单以进行复制和修改。|
|[CWnd：：获取TitlebarInfo](#gettitlebarinfo)|检索有关指定标题栏的信息。|
|[CWnd：：获取顶级框架](#gettoplevelframe)|检索窗口的顶级框架窗口。|
|[CWnd：：获取顶级级别所有者](#gettoplevelowner)|检索顶级窗口。|
|[CWnd：：获取顶级家长](#gettoplevelparent)|检索窗口的顶级父级。|
|[CWnd：：获取顶窗](#gettopwindow)|返回属于 `CWnd` 的第一个子窗口。|
|[CWnd：：获取更新](#getupdaterect)|检索完全包围 `CWnd` 更新区域的最小矩形的坐标。|
|[CWnd：：获取更新Rgn](#getupdatergn)|检索 `CWnd` 更新区域。|
|[CWnd：：获取窗口](#getwindow)|返回与此窗口具有指定关系的窗口。|
|[CWnd：：获取窗口上下文帮助Id](#getwindowcontexthelpid)|检索帮助上下文标识符。|
|[CWnd：：获取窗口DC](#getwindowdc)|检索整个窗口的显示上下文，包括标题栏、菜单和滚动条。|
|[CWnd：：获取窗口儿童计数](#getwindowedchildcount)|返回关联子窗口的数量。|
|[CWnd：：获取窗口信息](#getwindowinfo)|返回有关窗口的信息。|
|[CWnd：：获取无窗口儿童计数](#getwindowlesschildcount)|返回关联无窗口子窗口的数量。|
|[CWnd：：获取窗口放置](#getwindowplacement)|检索窗口的显示状态以及正常（已还原）、最小化和最大化位置。|
|[CWnd：：获取窗口Rect](#getwindowrect)|获取 `CWnd` 的屏幕坐标。|
|[CWnd：：获取窗口Rgn](#getwindowrgn)|检索窗口的窗口区域的副本。|
|[CWnd：：获取窗口文本](#getwindowtext)|返回窗口文本或标题（如果有）。|
|[CWnd：：获取窗口文本长度](#getwindowtextlength)|返回窗口文本或标题的长度。|
|[CWnd::HideCaret](#hidecaret)|通过从显示屏幕中移除来隐藏插入符号。|
|[CWnd::HiliteMenuItem](#hilitemenuitem)|突出显示顶级（菜单栏）菜单项或从顶级（菜单栏）菜单项移除突出显示。|
|[CWnd::HtmlHelp](#htmlhelp)|调用以启动 HTMLHelp 应用程序。|
|[CWnd::Invalidate](#invalidate)|使整个工作区无效。|
|[CWnd::InvalidateRect](#invalidaterect)|通过将给定矩形添加到当前更新区域，使该矩形内的工作区无效。|
|[CWnd::InvalidateRgn](#invalidatergn)|通过将给定区域添加到当前更新区域，使该区域内的工作区无效。|
|[CWnd::InvokeHelper](#invokehelper)|调用 ActiveX 控件方法或属性。|
|[CWnd::IsChild](#ischild)|指示 `CWnd` 是否为指定窗口的子窗口或其他直接子代。|
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|确定是否启用了 D2D 支持。|
|[CWnd::IsDialogMessage](#isdialogmessage)|确定给定消息是否用于无模式对话框，如果是，则处理它。|
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|确定是否选中按钮控件。|
|[CWnd::IsDynamicLayoutEnabled](#isdynamiclayoutenabled)|确定是否在此窗口上启用动态布局。 如果启用动态布局，则子窗口的位置和大小可以在用户调整父窗口大小时进行更改。|
|[CWnd::IsIconic](#isiconic)|确定 `CWnd` 是否进行最小化（图标化）。|
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否具有触摸支持。|
|[CWnd::IsWindowEnabled](#iswindowenabled)|确定是否针对鼠标和键盘输入启用窗口。|
|[CWnd::IsWindowVisible](#iswindowvisible)|确定窗口是否可见。|
|[CWnd::IsZoomed](#iszoomed)|确定 `CWnd` 是否进行最大化。|
|[CWnd：：基尔蒂默](#killtimer)|终止系统计时器。|
|[CWnd::LockWindowUpdate](#lockwindowupdate)|在给定窗口中禁用或重新启用绘制。|
|[CWnd::MapWindowPoints](#mapwindowpoints)|将一组点从 `CWnd` 的坐标空间转换（映射）到另一个窗口的坐标空间。|
|[CWnd::MessageBox](#messagebox)|创建并显示包含应用程序提供的消息和标题的窗口。|
|[CWnd::ModifyStyle](#modifystyle)|修改当前窗口样式。|
|[CWnd::ModifyStyleEx](#modifystyleex)|修改窗口的扩展样式。|
|[CWnd::MoveWindow](#movewindow)|更改 `CWnd` 的位置和尺寸。|
|[CWnd::NotifyWinEvent](#notifywinevent)|向系统发出信号，指出发生了预定义事件。|
|[CWnd::OnAmbientProperty](#onambientproperty)|实现环境属性值。|
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|由框架在需要获取要在 Windows 7 选项卡缩略图上或客户端上（进行应用程序速览）显示的位图时进行调用。|
|[CWnd::OnHelp](#onhelp)|处理应用程序中的 F1 帮助（使用当前上下文）。|
|[CWnd::OnHelpFinder](#onhelpfinder)|处理ID_HELP_FINDER和ID_DEFAULT_HELP命令。|
|[CWnd::OnHelpIndex](#onhelpindex)|处理ID_HELP_INDEX命令并提供默认帮助主题。|
|[CWnd::OnHelpUsing](#onhelpusing)|处理ID_HELP_USING命令。|
|[CWnd::OnToolHitTest](#ontoolhittest)|确定点是否在指定工具的边框内并检索有关此工具的信息。|
|[CWnd::OpenClipboard](#openclipboard)|打开剪贴板。 在调用 Windows [CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard)功能之前，其他应用程序将无法修改剪贴板。|
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控件容器上绘制无窗口控件。|
|[CWnd::PostMessage](#postmessage)|将消息置于应用程序队列中，然后返回而不等待窗口处理该消息。|
|[CWnd::PreCreateWindow](#precreatewindow)|在创建附加到此 `CWnd` 对象的 Windows 窗口之前调用。|
|[CWnd::PreSubclassWindow](#presubclasswindow)|允许在调用[子类窗口](#subclasswindow)之前进行其他必要的子类。|
|[CWnd::PreTranslateMessage](#pretranslatemessage)|由 `CWinApp` 用于在窗口消息调度到 `TranslateMessage` 和 `DispatchMessage` Windows 函数之前筛选它们。|
|[CWnd::Print](#print)|在指定设备上下文中绘制当前窗口。|
|[CWnd::PrintClient](#printclient)|在指定设备上下文（通常是打印机设备上下文）中绘制任何窗口。|
|[CWnd::PrintWindow](#printwindow)|将可视窗口复制到指定设备上下文（通常是打印机设备上下文）。|
|[CWnd::RedrawWindow](#redrawwindow)|更新工作区中的指定矩形或区域。|
|[CWnd::RegisterTouchWindow](#registertouchwindow)|注册/注销窗口 Windows 触摸支持。|
|[CWnd::ReleaseDC](#releasedc)|释放客户端和窗口设备上下文，从而使它们可供其他应用程序使用。|
|[CWnd::RepositionBars](#repositionbars)|在工作区中重新定位控件条。|
|[CWnd::RunModalLoop](#runmodalloop)|为处于模式状态的窗口检索、转换或调度消息。|
|[CWnd::ScreenToClient](#screentoclient)|将显示中的给定点或矩形的屏幕坐标转换为客户端坐标。|
|[CWnd::ScrollWindow](#scrollwindow)|滚动工作区的内容。|
|[CWnd::ScrollWindowEx](#scrollwindowex)|滚动工作区的内容。 类似于 `ScrollWindow`，不过具有附加功能。|
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|从父窗口向子窗口提供通知消息，以便子窗口可以处理任务。|
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|将消息发送到指定控件。|
|[CWnd::SendMessage](#sendmessage)|将消息发送到 `CWnd` 对象并且不返回，直到它处理了消息。|
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|将消息发送到窗口的所有子代窗口。|
|[CWnd::SendNotifyMessage](#sendnotifymessage)|将指定消息发送到窗口并尽快返回，具体取决于调用线程是否创建了窗口。|
|[CWnd::SetActiveWindow](#setactivewindow)|激活窗口。|
|[CWnd::SetCapture](#setcapture)|使所有后续鼠标输入都发送到 `CWnd`。|
|[CWnd::SetCaretPos](#setcaretpos)|将插入符号移动到指定位置。|
|[CWnd::SetClipboardViewer](#setclipboardviewer)|将 `CWnd` 添加到每当剪贴板内容发生更改时便会收到通知的窗口的链。|
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|为窗口（可以是任何子窗口，而不仅是对话框中的控件）设置窗口或控件 ID。|
|[CWnd::SetDlgItemInt](#setdlgitemint)|将控件的文本设置为表示整数值的字符串。|
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定对话框中设置控件的标题或文本。|
|[CWnd::SetFocus](#setfocus)|声明输入焦点。|
|[CWnd::SetFont](#setfont)|设置当前字体。|
|[CWnd::SetForegroundWindow](#setforegroundwindow)|将创建窗口的线程置于前台，并激活窗口。|
|[CWnd::SetIcon](#seticon)|设置特定图标的句柄。|
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|设置分层窗口的不透明度和透明度颜色键。|
|[CWnd::SetMenu](#setmenu)|将菜单设置为指定菜单。|
|[CWnd::SetOwner](#setowner)|更改 `CWnd` 的所有者。|
|[CWnd::SetParent](#setparent)|更改父窗口。|
|[CWnd::SetProperty](#setproperty)|设置 ActiveX 控件属性。|
|[CWnd::SetRedraw](#setredraw)|允许重绘 `CWnd` 中的更改，或阻止重绘更改。|
|[CWnd::SetScrollInfo](#setscrollinfo)|设置有关滚动条的信息。|
|[CWnd::SetScrollPos](#setscrollpos)|设置滚动框的当前位置，并且（如果指定）重绘滚动条以反映新位置。|
|[CWnd::SetScrollRange](#setscrollrange)|设置给定滚动条的最小和最大位置值。|
|[CWnd::SetTimer](#settimer)|安装系统计时器，在触发时发送[WM_TIMER](#ontimer)消息。|
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|设置帮助上下文标识符。|
|[CWnd::SetWindowPlacement](#setwindowplacement)|设置窗口的显示状态以及正常（已还原）、最小化和最大化位置。|
|[CWnd::SetWindowPos](#setwindowpos)|更改子窗口、弹出窗口和顶级窗口的大小、位置和的顺序。|
|[CWnd::SetWindowRgn](#setwindowrgn)|设置窗口的区域。|
|[CWnd::SetWindowText](#setwindowtext)|将窗口文本或标题（如果有）设置为指定文本。|
|[CWnd::ShowCaret](#showcaret)|在显示上插入符号的当前位置处显示插入符号。 显示之后，插入符号开始自动闪烁。|
|[CWnd::ShowOwnedPopups](#showownedpopups)|显示或隐藏窗口所拥有的所有弹出窗口。|
|[CWnd::ShowScrollBar](#showscrollbar)|显示或隐藏滚动条。|
|[CWnd::ShowWindow](#showwindow)|显示或隐藏窗口。|
|[CWnd::SubclassDlgItem](#subclassdlgitem)|将 Windows 控件附加到 `CWnd` 对象，并使它通过 `CWnd` 的消息映射来路由消息。|
|[CWnd::SubclassWindow](#subclasswindow)|将窗口附加到 `CWnd` 对象，并使它通过 `CWnd` 的消息映射来路由消息。|
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解锁使用 `CWnd::LockWindowUpdate` 锁定的窗口。|
|[CWnd::UnsubclassWindow](#unsubclasswindow)|从`CWnd`对象分离窗口|
|[CWnd::UpdateData](#updatedata)|从对话框初始化或检索数据。|
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|调用以更新对话框按钮和其他控件的状态。|
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分层窗口的位置、大小、形状、内容和透明度。|
|[CWnd::UpdateWindow](#updatewindow)|更新工作区。|
|[CWnd::ValidateRect](#validaterect)|通过从当前更新区域移除给定矩形，来验证该矩形内的工作区。|
|[CWnd::ValidateRgn](#validatergn)|通过从当前更新区域移除给定区域，来验证该区域内的工作区。|
|[CWnd::WindowFromPoint](#windowfrompoint)|标识包含给定点的窗口。|
|[CWnd::WinHelp](#winhelp)|调用以启动 WinHelp 应用程序。|

### <a name="protected-methods"></a>受保护的方法

|名称|说明|
|----------|-----------------|
|[CWnd::Default](#default)|调用默认窗口过程，该过程为应用程序不处理的任何窗口消息提供默认处理。|
|[CWnd::DefWindowProc](#defwindowproc)|调用默认窗口过程，该过程为应用程序不处理的任何窗口消息提供默认处理。|
|[CWnd：:DoDataExchange](#dodataexchange)|用于对话框数据交换和验证。 由 `UpdateData` 调用。|
|[CWnd：获取当前消息](#getcurrentmessage)|返回指向此窗口当前正在处理的消息的指针。 仅当在`On`*消息*处理程序成员函数中时才应调用。|
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由框架调用以初始化窗口的动态布局。|
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|从资源文件加载动态布局信息。|
|[Cwnd：：打开激活](#onactivate)|当正在激活或停用 `CWnd` 时调用。|
|[CWnd::OnActivateApp](#onactivateapp)|要激活或停用应用程序时调用。|
|[CWnd::OnAppCommand](#onappcommand)|当用户生成应用程序命令事件时调用。|
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|由剪贴板查看器应用程序在剪贴板所有者显示剪贴板内容时调用。|
|[CWnd::OnCancelMode](#oncancelmode)|调用以允许 `CWnd` 取消任何内部模式（如鼠标捕获）。|
|[CWnd::OnCaptureChanged](#oncapturechanged)|将消息发送到要失去鼠标捕获的窗口。|
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在从链中移除指定窗口。|
|[CWnd::OnChangeUIState](#onchangeuistate)|在应更改用户界面 (UI) 状态时调用。|
|[CWnd::OnChar](#onchar)|当击键转换为非系统字符时调用。|
|[CWnd::OnCharToItem](#onchartoitem)|由具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)样式的子列表框调用，以响应[WM_CHAR](#onchar)消息。|
|[CWnd::OnChildActivate](#onchildactivate)|每当 `CWnd` 大小或位置更改或 `CWnd` 激活时，针对多文档界面 (MDI) 子窗口进行调用。|
|[CWnd::OnChildNotify](#onchildnotify)|由父窗口调用以使通知控件有机会响应控件通知。|
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|在剪贴板内容已更改时调用。|
|[CWnd::OnClose](#onclose)|作为指示 `CWnd` 应关闭的信号进行调用。|
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|在非工作区的呈现策略已更改时调用。|
|[CWnd::OnCommand](#oncommand)|当用户选择命令时调用。|
|[CWnd::OnCompacting](#oncompacting)|当 Windows 检测到系统内存不足时调用。|
|[CWnd::OnCompareItem](#oncompareitem)|调用以确定新项在子所有者描述组合框或列表框中的相对位置。|
|[CWnd::OnCompositionChanged](#oncompositionchanged)|在桌面窗口管理器 (DWM) 组合已启用或已禁用时针对所有顶级窗口进行调用。|
|[CWnd::OnContextMenu](#oncontextmenu)|当用户窗口中单击鼠标右键时调用。|
|[CWnd::OnCopyData](#oncopydata)|将数据从一个应用程序复制到另一个应用程序。|
|[CWnd::OnCreate](#oncreate)|在窗口创建过程中调用。|
|[CWnd::OnCtlColor](#onctlcolor)|如果 `CWnd` 在要绘制控件时是控件的父级，则进行调用。|
|[CWnd::OnDeadChar](#ondeadchar)|当击键转换为非系统语音符号字符（如重音字符）时调用。|
|[CWnd::OnDeleteItem](#ondeleteitem)|当销毁所有者描述子列表框或组合框时，或是当从控件中移除项时调用。|
|[CWnd::OnDestroy](#ondestroy)|当销毁 `CWnd` 时调用。|
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|当通过调用 Windows[空剪板](/windows/win32/api/winuser/nf-winuser-emptyclipboard)功能清空剪贴板时调用。|
|[CWnd::OnDeviceChange](#ondevicechange)|向应用程序或设备驱动程序通知设备或计算机的硬件配置已更改。|
|[CWnd::OnDevModeChange](#ondevmodechange)|当用户更改设备模式设置时针对所有顶级窗口进行调用。|
|[CWnd::OnDrawClipboard](#ondrawclipboard)|当剪贴板内容已更改时调用。|
|[CWnd::OnDrawItem](#ondrawitem)|当需要绘制所有者描述子按钮控件、组合框控件、列表框控件或菜单的可视方面时调用。|
|[CWnd::OnDropFiles](#ondropfiles)|当用户在已将自己注册为拖放文件接收者的窗口上方释放鼠标左键时调用。|
|[CWnd::OnEnable](#onenable)|当启用或禁用 `CWnd` 时调用。|
|[CWnd::OnEndSession](#onendsession)|当会话结束时调用。|
|[CWnd::OnEnterIdle](#onenteridle)|调用以向应用程序的主窗口过程通知模式对话框或菜单正在进入空闲状态。|
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|当进入了菜单模式循环时调用。|
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影响的窗口进入移动或大小调整模式循环之后调用。|
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|当窗口背景需要擦除时调用。|
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|当退出了菜单模式循环时调用。|
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影响的窗口退出移动或大小调整模式循环之后调用。|
|[CWnd::OnFontChange](#onfontchange)|当字体资源池更改时调用。|
|[CWnd::OnGetDlgCode](#ongetdlgcode)|针对控件进行调用，以便控件可以自己处理箭头键和 TAB 键输入。|
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每当 Windows 需要知道最大化位置或尺寸或是最小或最大跟踪大小时调用。|
|[CWnd::OnHelpInfo](#onhelpinfo)|当用户按 F1 键时，由框架调用。|
|[CWnd::OnHotKey](#onhotkey)|当用户按系统范围热键时调用。|
|[CWnd::OnHScroll](#onhscroll)|当用户单击 `CWnd` 的水平滚动条时调用。|
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|当剪贴板所有者应滚动剪贴板图像、使相应部分失效以及更新滚动条值时调用。|
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|当 `CWnd` 已最小化（图标化）并且必须在绘制图标之前填充图标背景时调用。|
|[CWnd::OnInitMenu](#oninitmenu)|当菜单要成为活动状态时调用。|
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|当弹出菜单要成为活动状态时调用。|
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|当在系统中添加或移除 I/O 设备时调用。|
|[CWnd::OnInputLangChange](#oninputlangchange)|在应用程序的输入语言已更改之后调用。|
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|当用户选择新输入语言时调用。|
|[CWnd::OnKeyDown](#onkeydown)|当按下非系统键时调用。|
|[CWnd::OnKeyUp](#onkeyup)|当释放非系统键时调用。|
|[CWnd::OnKillFocus](#onkillfocus)|恰好在 `CWnd` 失去输入焦点之前调用。|
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|当用户双击鼠标左键时调用。|
|[CWnd::OnLButtonDown](#onlbuttondown)|当用户按下鼠标左键时调用。|
|[CWnd::OnLButtonUp](#onlbuttonup)|当用户释放鼠标左键时调用。|
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|当用户双击鼠标中键时调用。|
|[CWnd::OnMButtonDown](#onmbuttondown)|当用户按下鼠标中键时调用。|
|[CWnd::OnMButtonUp](#onmbuttonup)|当用户释放鼠标中键时调用。|
|[CWnd::OnMDIActivate](#onmdiactivate)|当激活或停用 MDI 子窗口时调用。|
|[CWnd::OnMeasureItem](#onmeasureitem)|创建控件时针对所有者描述子组合框、列表框或菜单项进行调用。 `CWnd` 向 Windows 通知控件的尺寸。|
|[CWnd::OnMenuChar](#onmenuchar)|当用户按下不与当前菜单中任何预定义助记键匹配的菜单助记键字符时调用。|
|[CWnd::OnMenuDrag](#onmenudrag)|当用户开始拖动菜单项时调用。|
|[CWnd::OnMenuGetObject](#onmenugetobject)|当鼠标光标进入菜单项或从该项的中心移动到该项的顶部或底部时调用。|
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|当光标位于菜单项上并且用户释放鼠标右键时调用。|
|[CWnd::OnMenuSelect](#onmenuselect)|当用户选择菜单项时调用。|
|[CWnd::OnMouseActivate](#onmouseactivate)|当光标处于非活动窗口中并且用户按下鼠标按钮时调用。|
|[CWnd::OnMouseHover](#onmousehover)|当光标悬停在窗口的工作区上，在之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的时间段时调用。|
|[CWnd::OnMouseHWheel](#onmousehwheel)|当前窗口由桌面窗口管理器 (DWM) 构造，并且该窗口已最大化时调用。|
|[CWnd::OnMouseLeave](#onmouseleave)|当光标离开之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的窗口的工作区时调用。|
|[CWnd::OnMouseMove](#onmousemove)|当鼠标光标移动时调用。|
|[CWnd::OnMouseWheel](#onmousewheel)|当用户旋转鼠标滚轮时调用。 使用 Windows NT 4.0 消息处理。|
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置已更改之后调用。|
|[CWnd::OnMoving](#onmoving)|指示用户正在移动 `CWnd` 对象。|
|[CWnd::OnNcActivate](#onncactivate)|当需要更改非工作区以指示活动或非活动状态时调用。|
|[CWnd::OnNcCalcSize](#onnccalcsize)|当需要计算工作区的大小和位置时调用。|
|[CWnd::OnNcCreate](#onnccreate)|在创建非工作区时在[OnCreate](#oncreate)之前调用。|
|[CWnd::OnNcDestroy](#onncdestroy)|当销毁非工作区时调用。|
|[CWnd::OnNcHitTest](#onnchittest)|每当如果 `CWnd` 包含光标或使用 `SetCapture` 捕获了鼠标输入便移动鼠标时调用。|
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|当用户在光标处于 `CWnd` 的非工作区期间双击鼠标左键时调用。|
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|当用户在光标处于 `CWnd` 的非工作区期间按下鼠标左键时调用。|
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|当用户在光标处于 `CWnd` 的非工作区期间释放鼠标左键时调用。|
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|当用户在光标处于 `CWnd` 的非工作区期间双击鼠标中键时调用。|
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|当用户在光标处于 `CWnd` 的非工作区期间按下鼠标中键时调用。|
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|当用户在光标处于 `CWnd` 的非工作区期间释放鼠标中键时调用。|
|[CWnd::OnNcMouseHover](#onncmousehover)|当光标悬停在窗口的非工作区上，在之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的时间段时调用。|
|[CWnd::OnNcMouseLeave](#onncmouseleave)|当光标离开之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的窗口的非工作区时，框架将调用此成员函数。|
|[CWnd::OnNcMouseMove](#onncmousemove)|当在 `CWnd` 的非工作区中移动光标时调用。|
|[CWnd::OnNcPaint](#onncpaint)|当需要绘制非工作区时调用。|
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|当用户在光标处于 `CWnd` 的非工作区期间双击鼠标右键时调用。|
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|当用户在光标处于 `CWnd` 的非工作区期间按下鼠标右键时调用。|
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|当用户在光标处于 `CWnd` 的非工作区期间释放鼠标右键时调用。|
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|在非工作区的呈现策略已更改时调用。|
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|当用户在光标位于窗口非工作区期间双击 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|当用户在光标位于窗口非工作区期间按下鼠标的 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|当用户在光标位于窗口非工作区期间释放鼠标的 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::OnNextMenu](#onnextmenu)|当使用向右或向左箭头键在菜单栏和系统菜单之间切换时调用。|
|[CWnd::OnNotify](#onnotify)|由框架调用以通知父窗口，在其某个控件上发生事件或该控件需要信息。|
|[CWnd::OnNotifyFormat](#onnotifyformat)|调用以确定当前窗口是否接受 WM_NOTIFY 通知消息中的 ANSI 或 Unicode 结构。|
|[CWnd::OnPaint](#onpaint)|调用以重新绘制窗口的一部分。|
|[CWnd::OnPaintClipboard](#onpaintclipboard)|当剪贴板查看器的工作区需要重新绘制时调用。|
|[CWnd::OnPaletteChanged](#onpalettechanged)|调用以允许使用调色板的窗口实现其逻辑调色板并更新其工作区。|
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|当某个应用程序要实现其逻辑调色板时，通知其他应用程序。|
|[CWnd::OnParentNotify](#onparentnotify)|当创建或销毁子窗口时，或是当用户在光标位于子窗口上方期间单击鼠标按钮时调用。|
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|当电源管理事件发生时调用。|
|[CWnd::OnQueryDragIcon](#onquerydragicon)|当用户要拖动最小化（图标化）的 `CWnd` 时调用。|
|[CWnd::OnQueryEndSession](#onqueryendsession)|当用户选择结束 Windows 会话时调用。|
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|向 `CWnd` 告知它要接收输入焦点。|
|[CWnd::OnQueryOpen](#onqueryopen)|当 `CWnd` 是图标并且用户请求打开该图标时调用。|
|[CWnd::OnQueryUIState](#onqueryuistate)|调用以检索窗口的用户界面 (UI) 状态。|
|[CWnd::OnRawInput](#onrawinput)|当前窗口中获取原始输入时调用。|
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|当用户双击鼠标右键时调用。|
|[CWnd::OnRButtonDown](#onrbuttondown)|当用户按下鼠标右键时调用。|
|[CWnd::OnRButtonUp](#onrbuttonup)|当用户释放鼠标右键时调用。|
|[CWnd::OnRenderAllFormats](#onrenderallformats)|当所有者应用程序正在销毁并且需要呈现其所有格式时调用。|
|[CWnd::OnRenderFormat](#onrenderformat)|当需要呈现具有延迟呈现的特定格式时，针对剪贴板所有者进行调用。|
|[CWnd::OnSessionChange](#onsessionchange)|调用以向应用程序通知会话状态已更改。|
|[CWnd::OnSetCursor](#onsetcursor)|如果鼠标输入未捕获并且鼠标使光标在光标中移动，则调用。|
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 获取输入焦点之后调用。|
|[CWnd::OnSettingChange](#onsettingchange)|当 Win32 `SystemParametersInfo` 函数更改系统范围设置时调用。|
|[CWnd::OnShowWindow](#onshowwindow)|当 `CWnd` 要显示或隐藏时调用。|
|[CWnd::OnSize](#onsize)|在 `CWnd` 的大小已更改之后调用。|
|[CWnd::OnSizeClipboard](#onsizeclipboard)|当剪贴板查看器窗口工作区的大小已更改时调用。|
|[CWnd::OnSizing](#onsizing)|指示用户正在调整矩形大小。|
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每当对打印管理器队列添加或移除作业时，从打印管理器调用。|
|[CWnd::OnStyleChanged](#onstylechanged)|指示[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函数已更改窗口的一个或多个样式。|
|[CWnd::OnStyleChanging](#onstylechanging)|指示[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函数即将更改窗口的一个或多个样式。|
|[CWnd::OnSysChar](#onsyschar)|当击键转换为系统字符时调用。|
|[CWnd::OnSysColorChange](#onsyscolorchange)|当在系统颜色设置中进行更改时，针对所有顶级窗口进行调用。|
|[CWnd::OnSysCommand](#onsyscommand)|当用户从控件菜单中选择命令时，或是当用户选择最大化或最小化按钮时调用。|
|[CWnd::OnSysDeadChar](#onsysdeadchar)|当击键转换为系统语音符号字符（如重音字符）时调用。|
|[CWnd::OnSysKeyDown](#onsyskeydown)|当用户按住 ALT 键，然后按下另一个键时调用。|
|[CWnd::OnSysKeyUp](#onsyskeyup)|当用户释放在按住 ALT 键的同时按下的键时调用。|
|[CWnd::OnTCard](#ontcard)|当用户单击可创作的按钮时调用。|
|[CWnd::OnTimeChange](#ontimechange)|在系统时间更改之后针对所有顶级窗口进行调用。|
|[CWnd::OnTimer](#ontimer)|在[SetTimer](#settimer)中指定的每个间隔之后调用。|
|[CWnd::OnTouchInput](#ontouchinput)|处理来自 Windows 触摸屏的单个输入。|
|[CWnd::OnTouchInputs](#ontouchinputs)|处理来自 Windows 触摸屏的输入。|
|[CWnd::OnUniChar](#onunichar)|当按下键时调用。 也就是说，当前窗口具有键盘焦点，并且[翻译Message](/windows/win32/api/winuser/nf-winuser-translatemessage)函数将[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)消息翻译。|
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|在下拉菜单或子菜单已销毁时调用。|
|[CWnd::OnUpdateUIState](#onupdateuistate)|调用以更改指定窗口及其所有子窗口的用户界面 (UI) 状态。|
|[CWnd::OnUserChanged](#onuserchanged)|在用户登录或注销之后调用。|
|[CWnd::OnVKeyToItem](#onvkeytoitem)|由 拥有`CWnd`的列表框调用，以响应[WM_KEYDOWN](#onkeydown)消息。|
|[CWnd::OnVScroll](#onvscroll)|当用户单击窗口的垂直滚动条时调用。|
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|当所有者应滚动剪贴板图像、使相应部分失效以及更新滚动条值时调用。|
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|当大小、位置或 Z 顺序因调用[SetWindowPos](#setwindowpos)或其他窗口管理功能而发生更改时调用。|
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|当大小、位置或 Z 顺序由于调用[SetWindowPos](#setwindowpos)或其他窗口管理功能而即将更改时调用。|
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化文件 (WIN.INI) 已更改之后对所有顶级窗口进行调用。|
|[CWnd::OnWndMsg](#onwndmsg)|指示是否处理了 Windows 消息。|
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|当用户在光标位于窗口工作区期间双击 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::OnXButtonDown](#onxbuttondown)|当用户在光标位于窗口工作区期间按下 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::OnXButtonUp](#onxbuttonup)|当用户在光标位于窗口工作区期间释放 XBUTTON1 或 XBUTTON2 时调用。|
|[CWnd::PostNcDestroy](#postncdestroy)|此虚拟函数在窗口被销毁后由默认[OnNc销毁](#onncdestroy)函数调用。|
|[CWnd::ReflectChildNotify](#reflectchildnotify)|将消息反射到其源的 Helper 函数。|
|[CWnd::ReflectLastMsg](#reflectlastmsg)|将最后一个消息反射到子窗口。|
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果对窗口启用了动态布局，则窗口大小更改以调整子窗口布局时会通过框架调用。|
|[CWnd::WindowProc](#windowproc)|为 `CWnd` 提供窗口过程。 默认设置会通过消息映射调度消息。|

### <a name="public-operators"></a>公共运算符

|名称|说明|
|----------|-----------------|
|[CWnd::operator HWND](#operator_hwnd)|调用以获取窗口的句柄。|
|[CWnd：：操作员！*](#operator_neq)|确定窗口是否与句柄[m_hWnd](#m_hwnd)的窗口不同。|
|[CWnd::operator ==](#operator_eq_eq)|确定窗口是否与句柄[为m_hWnd](#m_hwnd)的窗口相同。|

### <a name="public-data-members"></a>公共数据成员

|名称|说明|
|----------|-----------------|
|[CWnd::m_hWnd](#m_hwnd)|指示附加到此`CWnd`的 HWND。|

## <a name="remarks"></a>备注

`CWnd` 对象与 Windows 窗口不同，但这两者紧密相关。 `CWnd` 对象由 `CWnd` 构造函数和析构函数进行创建或销毁。 另一方面，Windows 窗口是 Windows 内部的数据结构，由`Create`成员函数创建并由`CWnd`虚拟析构函数销毁。 [销毁窗口](#destroywindow)功能在不破坏对象的情况下销毁 Windows 窗口。

类`CWnd`和消息映射机制隐藏函数`WndProc`。 传入的 Windows 通知消息通过消息映射自动路由到正确的 **"消息打开"**<em>Message</em>`CWnd`成员功能。 重写 **"消息"**<em>Message</em>成员函数以处理派生类中成员的特定消息。

通过 `CWnd` 类还可以为应用程序创建 Windows 子窗口。 从 `CWnd` 派生类，然后将成员变量添加到派生类，以存储特定于应用程序的数据。 可派生类中实现消息处理程序成员函数和消息映射，以指定在消息定向到窗口时所发生的情况。

可采用两个步骤创建子窗口。 首先，调用构造`CWnd`函数构造`CWnd`对象，然后调用[Create](#create)成员函数以创建子窗口并将其附加到`CWnd`对象。

当用户终止子窗口时，销毁 `CWnd` 对象，或调用 `DestroyWindow` 成员函数以移除窗口并销毁其数据结构。

在 Microsoft 基础类库中，从 `CWnd` 派生了更多类以提供特定窗口类型。 其中许多类，包括CFrameWnd，CMDIFrameWnd，CMDIChildwnd，CView[CView](../../mfc/reference/cview-class.md)和[CDialog，](../../mfc/reference/cdialog-class.md)都是为进一步派生而设计的。 [CFrameWnd](../../mfc/reference/cframewnd-class.md) [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md) [CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md) 派生自`CWnd`的控件类（如[CButton）](../../mfc/reference/cbutton-class.md)可以直接使用，也可以用于进一步派生类。

有关 使用`CWnd`的详细信息，请参阅[框架窗口](../../mfc/frame-windows.md)和[窗口对象](../../mfc/window-objects.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`CWnd`

## <a name="requirements"></a>要求

**标头:** afxwin.h

## <a name="cwndaccdodefaultaction"></a><a name="accdodefaultaction"></a>CWnd：：accDo默认行动

由框架调用以执行对象的默认操作。

```
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要调用的默认操作是对象的默认操作还是对象的子元素之一。 此参数可以是CHILDID_SELF（执行对象的默认操作）或子 ID（以执行对象一个子元素的默认操作）。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅"可访问"中的**返回值**：：Windows SDK 中的["accDoDefaultAction"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数以执行对象的默认操作。 有关详细信息，请参阅 Windows SDK 中的["可访问对象：：accDoDefaultAction"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)

## <a name="cwndacchittest"></a><a name="acchittest"></a>CWnd：：accHitTest

由框架调用以检索屏幕上给定点处的子元素或子对象。

```
virtual HRESULT accHitTest(
    long xLeft,
    long yTop,
    VARIANT* pvarChild);
```

### <a name="parameters"></a>参数

*x 左*<br/>
要命中测试的点的 X 坐标（以屏幕单位为单位）。

*yTop*<br/>
要命中测试的点的 Y 坐标（以屏幕单位为单位）。

*普瓦尔儿童*<br/>
接收在*xLeft*和*yTop*指定的点标识对象的信息。 请参阅["可访问点：：windows SDK 中的 pvarID：accHitTest"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest) *pvarID*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::accHitTest` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：accHitTest"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest)

## <a name="cwndacclocation"></a><a name="acclocation"></a>CWnd：：位置

由框架调用以检索指定对象的当前屏幕位置。

```
virtual HRESULT accLocation(
    long* pxLeft,
    long* pyTop,
    long* pcxWidth,
    long* pcyHeight,
    VARIANT varChild);
```

### <a name="parameters"></a>参数

*px 左*<br/>
接收对象的左上角（以屏幕单位为单位）的 x 坐标。

*pyTop*<br/>
接收对象左上角（以屏幕单位为单位）的 y 坐标。

*pcxWidth*<br/>
接收对象的宽度（以屏幕单位表示）。

*pcyHeight*<br/>
接收对象的高度（以屏幕单位为单位）。

*瓦尔儿童*<br/>
指定要检索的位置是对象的位置还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::accLocation` SDK 中的**返回值**。

### <a name="remarks"></a>备注

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅`IAccessible::accLocation`Windows SDK。

## <a name="cwndaccnavigate"></a><a name="accnavigate"></a>CWnd：：accNavigate

由框架调用以移到容器内的另一个用户界面元素，如果可能还检索对象。

```
virtual HRESULT accNavigate(
    long navDir,
    VARIANT varStart,
    VARIANT* pvarEndUpAt);
```

### <a name="parameters"></a>参数

*纳夫迪尔*<br/>
指定要导航的方向。 请参阅["可访问"](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate)中的*navDir：：* 在 Windows SDK 中导航。

*varStart*<br/>
指定起始对象。 请参阅 Windows `IAccessible::accNavigate` SDK 中的*var Start。*

*普瓦伦多普*<br/>
接收有关目标用户界面对象的信息。 请参阅 Windows SDK`IAccessible::accNavigate`中的*pvarEnd。*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::accNavigate` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：accNavigate"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate)

## <a name="cwndaccselect"></a><a name="accselect"></a>CWnd：：accSelect

由框架调用以修改选定内容或移动指定对象的键盘焦点。

```
virtual HRESULT accSelect(
    long flagsSelect,
    VARIANT varChild);
```

### <a name="parameters"></a>参数

*标志选择*<br/>
指定如何更改当前选择或焦点。 请参阅 *"*[可访问"中的标志选择：：在](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect)Windows SDK 中选择。

*瓦尔儿童*<br/>
指定要选择的对象。 此参数可以是CHILDID_SELF（选择对象本身）或子 ID（以选择对象的一个子项）。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::accSelect` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：accSelect"。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect)

## <a name="cwndanimatewindow"></a><a name="animatewindow"></a>CWnd：：动画窗口

显示或隐藏窗口时产生特殊效果。

```
BOOL AnimateWindow(
    DWORD dwTime,
    DWORD dwFlags);
```

### <a name="parameters"></a>参数

*dwTime*<br/>
指定播放动画所需的时间（以毫秒为单位）。 通常，动画需要 200 毫秒才能播放。

dwFlags**<br/>
指定动画类型。 有关可能值的完整列表，请参阅[AnimateWindow.](/windows/win32/api/winuser/nf-winuser-animatewindow)

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[AnimateWindow](/windows/win32/api/winuser/nf-winuser-animatewindow)的功能，如 Windows SDK 中所述。

## <a name="cwndarrangeiconicwindows"></a><a name="arrangeiconicwindows"></a>CWnd：：排列图标窗口

排列所有最小化（图标）子窗口。

```
UINT ArrangeIconicWindows();
```

### <a name="return-value"></a>返回值

如果函数成功，则一行图标的高度;否则 0。

### <a name="remarks"></a>备注

此成员功能还排列桌面窗口中的图标，该图标涵盖整个屏幕。 [Get DesktopWindow](#getdesktopwindow)成员函数检索指向桌面窗口对象的指针。

要在 MDI 客户端窗口中安排标志性的 MDI 子窗口，请致电[CMDIFrameWnd：：MDIIcon排列](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]

## <a name="cwndattach"></a><a name="attach"></a>CWnd：：附加

将 Windows 窗口附加到`CWnd`对象。

```
BOOL Attach(HWND hWndNew);
```

### <a name="parameters"></a>参数

*hWndNew*<br/>
指定 Windows 窗口的句柄。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="example"></a>示例

此示例演示如何使用附加和分离映射到 MDI 客户端窗口。

[!code-cpp[NVC_MFCWindowing#67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]

[!code-cpp[NVC_MFCWindowing#68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]

[!code-cpp[NVC_MFCWindowing#69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]

## <a name="cwndbeginmodalstate"></a><a name="beginmodalstate"></a>CWnd：：开始模式状态

调用此成员函数以使框架窗口具有模式。

```
virtual void BeginModalState();
```

## <a name="cwndbeginpaint"></a><a name="beginpaint"></a>CWnd：：开始绘画

准备`CWnd`绘画，并填写`PAINTSTRUCT`有关绘画的信息的数据结构。

```
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>参数

*lpPaint*<br/>
指向用于接收绘画信息的[PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct)结构。

### <a name="return-value"></a>返回值

标识`CWnd`的设备上下文。 指针可能是临时的，不应存储在[EndPaint](#endpaint)的范围之外。

### <a name="remarks"></a>备注

绘制结构包含一个 RECT 数据结构，该结构具有完全包含更新区域的最小矩形和指定背景是否已擦除的标志。

更新区域由["无效](#invalidate)、[无效"](#invalidaterect)或["无效Rgn"](#invalidatergn)成员函数设置，并在系统调整、移动、创建、滚动或执行影响工作区的任何其他操作后设置。 如果将更新区域标记为已进行已更新，则`BeginPaint`发送[WM_ONERASEBKGND](#onerasebkgnd)消息。

不要调用成员函数`BeginPaint`，除非响应[WM_PAINT](#onpaint)消息。 对成员函数的每个`BeginPaint`调用都必须具有对[EndPaint](#endpaint)成员函数的匹配调用。 如果 care 在要绘制的区域中，`BeginPaint`则成员函数会自动隐藏 caret，以防止其被擦除。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]

## <a name="cwndbinddefaultproperty"></a><a name="binddefaultproperty"></a>CWnd：：绑定默认属性

将调用对象的默认简单绑定属性（如类型库中标记的编辑控件）绑定到数据源控件的 DataSource、用户名、密码和 SQL 属性定义的基础游标。

```
void BindDefaultProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    LPCTSTR szFieldName,
    CWnd* pDSCWnd);
```

### <a name="parameters"></a>参数

*dwDispID*<br/>
指定要绑定到数据源控件的数据绑定控件上属性的 DISPID。

*vtProp*<br/>
指定要绑定的属性的类型，例如，VT_BSTR、VT_VARIANT 等。

*szfield名称*<br/>
指定列的名称，在数据源控件提供的游标中，该属性将绑定到该列。

*pDSCWnd*<br/>
指向承载将属性绑定到的数据源控件的窗口。 使用`GetDlgItem`DCS 的主机窗口的资源 ID 调用以检索此指针。

### <a name="remarks"></a>备注

调用`CWnd`此函数的对象必须是数据绑定控件。

### <a name="example"></a>示例

`BindDefaultProperty`可在以下上下文中使用：

[!code-cpp[NVC_MFC_AxDataBinding#2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]

## <a name="cwndbindproperty"></a><a name="bindproperty"></a>CWnd：：绑定财产

将数据绑定控件（如网格控件）上的游标绑定属性绑定到数据源控件，并注册与 MFC 绑定管理器的关系。

```
void BindProperty(
    DISPID dwDispId,
    CWnd* pWndDSC);
```

### <a name="parameters"></a>参数

*dwDispId*<br/>
指定要绑定到数据源控件的数据绑定控件上属性的 DISPID。

*pWndDSC*<br/>
指向承载将属性绑定到的数据源控件的窗口。 使用`GetDlgItem`DCS 的主机窗口的资源 ID 调用以检索此指针。

### <a name="remarks"></a>备注

调用`CWnd`此函数的对象必须是数据绑定控件。

### <a name="example"></a>示例

`BindProperty`可在以下上下文中使用：

[!code-cpp[NVC_MFC_AxDataBinding#4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]

## <a name="cwndbringwindowtotop"></a><a name="bringwindowtotop"></a>Cwnd：：将窗口顶

将 `CWnd` 置于一堆重叠窗口的顶部。

```
void BringWindowToTop();
```

### <a name="remarks"></a>备注

此外，`BringWindowToTop` 将激活弹出的、顶层和 MDI 子窗口。 `BringWindowToTop` 成员函数应用于显露被任何重叠窗口部分或完全遮盖的任意窗口。

此函数只是调用 Win32 [BringWindowTop](/windows/win32/api/winuser/nf-winuser-bringwindowtotop)函数。 调用[SetWindowPos](#setwindowpos)函数以更改窗口在 Z 顺序中的位置。 `BringWindowToTop` 函数不更改窗口样式，即可使其成为顶层窗口。 有关详细信息，请参阅[HWND_TOP和HWND_TOPMOST之间的区别](https://devblogs.microsoft.com/oldnewthing/?p=33263)

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]

## <a name="cwndcalcwindowrect"></a><a name="calcwindowrect"></a>CWnd：：卡尔窗口雷ct

计算可以包含指定客户端矩形的窗口矩形。

```
virtual void CalcWindowRect(
    LPRECT lpClientRect,
    UINT nAdjustType = adjustBorder);
```

### <a name="parameters"></a>参数

*lpClientrect*<br/>
[进出]指向矩形结构的指针。 在输入时，此结构包含客户端矩形。 方法完成后，此结构包含可以包含指定客户端矩形的窗口矩形。

*nAdjust 类型*<br/>
[在]用于`CWnd::adjustBorder`计算没有WS_EX_CLIENTEDGE样式的窗口坐标;否则，请使用`CWnd::adjustOutside`。

### <a name="remarks"></a>备注

计算的窗口矩形的大小不包括菜单栏的空间。

有关更多使用限制，请参阅[调整 WindowrectEx](/windows/win32/api/winuser/nf-winuser-adjustwindowrectex)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]

## <a name="cwndcanceltooltips"></a><a name="canceltooltips"></a>CWnd：：取消工具提示

如果当前显示工具提示，请调用此成员函数从屏幕中删除工具提示。

```
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```

### <a name="parameters"></a>参数

*bKeys*<br/>
TRUE 在按下键时取消工具提示，并将状态栏文本设置为默认值;否则 FALSE。

### <a name="remarks"></a>备注

> [!NOTE]
> 使用此成员函数不会影响代码管理的工具提示。 它只影响由 CWnd 管理的工具提示控制[：：启用工具提示](#enabletooltips)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]

## <a name="cwndcenterwindow"></a><a name="centerwindow"></a>CWnd：：中心窗口

使窗口相对于其父级居中。

```
void CenterWindow(CWnd* pAlternateOwner = NULL);
```

### <a name="parameters"></a>参数

*p替代所有者*<br/>
指向将居中（父窗口以外的）的备用窗口的指针。

### <a name="remarks"></a>备注

通常从[CDialog 调用：onInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)到相对于应用程序主窗口的中心对话框。 默认情况下，函数将子窗口相对于其父窗口和弹出窗口相对于其所有者居中。 如果弹出窗口不拥有，则相对于屏幕，该窗口居中。 要将窗口相对于不是所有者或父窗口的特定窗口居中 *，pAlternateOwner*参数可以设置为有效窗口。 要强制相对于屏幕进行居中，请传递[CWnd 返回的值：：获取桌面窗口](#getdesktopwindow)作为*p备用所有者*。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]

## <a name="cwndchangeclipboardchain"></a><a name="changeclipboardchain"></a>CWnd：：更改剪板链

从`CWnd`剪贴板查看器链中删除，并使*hWndNext*指定的窗口成为链中`CWnd`祖先的后代。

```
BOOL ChangeClipboardChain(HWND hWndNext);
```

### <a name="parameters"></a>参数

*hWndNext*<br/>
标识剪贴板查看器链`CWnd`中后面的窗口。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

## <a name="cwndcheckdlgbutton"></a><a name="checkdlgbutton"></a>CWnd：：检查DlgButton

选择（将复选标记放在旁边）或清除（从中删除复选标记），或者更改三状态按钮的状态。

```
void CheckDlgButton(
    int nIDButton,
    UINT nCheck);
```

### <a name="parameters"></a>参数

*nIDButton*<br/>
指定要修改的按钮。

*n检查*<br/>
指定要执行的操作。 如果*nCheck*是非零，`CheckDlgButton`则成员函数在按钮旁边放置一个复选标记;如果 nCheck 为非零，则成员函数将检查标记放在按钮旁边。如果为 0，则删除复选标记。 对于三状态按钮，如果*nCheck*为 2，则按钮状态不确定。

### <a name="remarks"></a>备注

该`CheckDlgButton`函数向指定的按钮发送[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)消息。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]

## <a name="cwndcheckradiobutton"></a><a name="checkradiobutton"></a>CWnd：：检查无线按钮

在组中选择（向）给定的单选按钮，并清除（从中删除）组中的所有其他单选按钮。

```
void CheckRadioButton(
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
```

### <a name="parameters"></a>参数

*nID第一按钮*<br/>
指定组中第一个单选按钮的整数标识符。

*nIDLastButton*<br/>
指定组中最后一个单选按钮的整数标识符。

*nID检查按钮*<br/>
指定要检查的单选按钮的整数标识符。

### <a name="remarks"></a>备注

该`CheckRadioButton`函数向指定的单选按钮发送[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)消息。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]

## <a name="cwndchildwindowfrompoint"></a><a name="childwindowfrompoint"></a>Cwnd：：儿童窗口从点

确定属于哪个`CWnd`子窗口（如果有）包含指定点。

```
CWnd* ChildWindowFromPoint(POINT point) const;

CWnd* ChildWindowFromPoint(
    POINT point,
    UINT nFlags) const;
```

### <a name="parameters"></a>参数

*点*<br/>
指定要测试的点的客户端坐标。

*nflags*<br/>
指定要跳过的子窗口。 此参数可以是以下值的组合：

|“值”|含义|
|-----------|-------------|
|CWP_ALL|不要跳过任何子窗口|
|CWP_SKIPINVISIBLE|跳过不可见的子窗口|
|CWP_SKIPDISABLED|跳过已禁用的子窗口|
|CWP_SKIPTRANSPARENT|跳过透明子窗口|

### <a name="return-value"></a>返回值

标识包含该点的子窗口。 如果给定点位于工作区之外，则为 NULL。 如果点位于工作区中，但不包含在任何子窗口中，`CWnd`则返回。

此成员函数将返回包含指定点的隐藏或禁用子窗口。

多个窗口可能包含给定点。 但是，此函数仅返回遇到的`CWnd`包含点的第一个窗口的 *。

返回`CWnd`的 * 可能是临时的，不应存储以供以后使用。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]

## <a name="cwndclienttoscreen"></a><a name="clienttoscreen"></a>Cwnd：：客户端屏幕

将显示中的给定点或矩形的客户端坐标转换为屏幕坐标。

```
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
指向包含要转换的客户端`CPoint`坐标的 POINT[结构](/windows/win32/api/windef/ns-windef-point)或对象。

*lpRect*<br/>
指向包含要转换的客户端坐标`CRect`的[RECT 结构](/windows/win32/api/windef/ns-windef-rect)或对象。

### <a name="remarks"></a>备注

成员`ClientToScreen`函数`POINT`使用`RECT`或 结构中的客户端坐标或*lpPoint*或*lpRect*指向的`CPoint`或`CRect`对象来计算新的屏幕坐标;然后，它将结构中的坐标替换为新坐标。 新的屏幕坐标相对于系统显示屏的左上角。

成员`ClientToScreen`函数假定给定的点或矩形位于客户端坐标中。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]

## <a name="cwndclosewindow"></a><a name="closewindow"></a>CWnd：：关闭窗口

最小化窗口。

```
void CloseWindow();
```

### <a name="remarks"></a>备注

此成员函数模拟函数[CloseWindow](/windows/win32/api/winuser/nf-winuser-closewindow)的功能，如 Windows SDK 中所述。

## <a name="cwndcontinuemodal"></a><a name="continuemodal"></a>CWnd：：继续模式化

[RunModalLoop](#runmodalloop)调用此成员函数以确定应退出模式状态。

```
virtual BOOL ContinueModal();
```

### <a name="return-value"></a>返回值

如果要继续模式循环，则非零;0 调用[端模态循环](#endmodalloop)。

### <a name="remarks"></a>备注

默认情况下，它返回非零直到`EndModalLoop`调用。

## <a name="cwndcreate"></a><a name="create"></a>CWnd：：创建

创建指定的子窗口并将其附加到[CWnd](../../mfc/reference/cwnd-class.md)对象。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    Const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*lpszClass名称*<br/>
[在]指向包含已注册系统窗口类名称的 null 终止字符串的指针;或预定义的系统窗口类的名称。

*lpsz窗口名称*<br/>
[在]指向包含窗口显示名称的 null 终止字符串的指针;否则 NULL 没有窗口显示名称。

*dwStyle*<br/>
[在][窗口样式](styles-used-by-mfc.md#window-styles)的位组合 （OR）。 WS_POPUP选项不是有效的样式。

*矩形*<br/>
[在]窗口相对于父窗口左上角的大小和位置。

*pparentwnd*<br/>
[在]指向父窗口的指针。

*nID*<br/>
[在]窗口的 ID。

*pContext*<br/>
[在]指向[CCreateContext](../../mfc/reference/ccreatecontext-structure.md)结构的指针，该结构用于自定义应用程序的文档视图体系结构。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

> [!WARNING]
> `CWnd::PreCreateWindow`现在，如果菜单为 NULL 且`CREATESTRUCT`样式包含WS_CHILD，则将其参数的 hMenu 成员分配给**此**指针。 要获得正确的功能，请确保对话框控件的 ID 不是 NULL。
>
> 此更改修复了托管/本机互操作方案中的崩溃。 中的`CWnd::Create`TRACE 语句提醒开发人员问题。

使用[Afx 注册WndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函数注册窗口类。 用户定义的窗口类在注册的模块中可用。

在`Create`方法返回之前和窗口变得可见之前调用[CWnd：：onCreate](#oncreate)方法。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]

## <a name="cwndcreateaccessibleproxy"></a><a name="createaccessibleproxy"></a>CWnd：：创建可访问代理

为指定对象创建 Active Accessibility 代理服务器。

```
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>参数

*wParam*<br/>
标识活动辅助功能代理访问的对象。 可以是以下值之一

|“值”|含义|
|-----------|-------------|
|OBJID_CLIENT|引用窗口的工作区。|

*lParam*<br/>
提供其他与消息相关的信息。

*pResult*<br/>
指向存储结果代码的 LRESULT 的指针。

### <a name="remarks"></a>备注

为指定对象创建 Active Accessibility 代理服务器。

## <a name="cwndcreatecaret"></a><a name="createcaret"></a>CWnd：：创建关怀

为系统加斯特创建新形状，并声称对该 care 的置置体的所有权。

```
void CreateCaret(CBitmap* pBitmap);
```

### <a name="parameters"></a>参数

*pBitmap*<br/>
标识定义贴贴形状的位图。

### <a name="remarks"></a>备注

位图以前必须由[CBitmap：：CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap)成员函数[、CreateDIBitmap](/windows/win32/api/wingdi/nf-wingdi-createdibitmap) Windows 函数或[CBitmap：LoadBitmap](../../mfc/reference/cbitmap-class.md#loadbitmap)成员函数创建。

`CreateCaret`自动销毁以前的护理形状（如果有），无论哪个窗口拥有该图。 创建后，该隐子最初将隐藏。 要显示 caret，必须调用[ShowCaret](#showcaret)成员函数。

系统资源是共享资源。 `CWnd`仅当具有输入焦点或处于活动状态时，才应创建一个 care。 它应该在失去输入焦点或变为非活动状态之前销毁该 care。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]

## <a name="cwndcreatecontrol"></a><a name="createcontrol"></a>CWnd：：创建控制

使用此成员函数可以创建一个 ActiveX 控件，该控件将由`CWnd`对象在 MFC 程序中表示。

```
BOOL CreateControl(
    LPCTSTR pszClass,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const POINT* ppt,
    const SIZE* psize,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);
```

### <a name="parameters"></a>参数

*pszClass*<br/>
此字符串可能包含类的 OLE"短名称"（ProgID），例如"CIRC3"。Circ3Ctrl.1" 该名称需要与控件注册的相同名称匹配。 或者，字符串可能包含 CLSID 的字符串形式，包含在大括号中，例如"#9DBAFCCF-592F-101B-85CE-00608CEC297B}"。 在这两种情况下，`CreateControl`将字符串转换为相应的类 ID。

*pszWindow名称*<br/>
指向要在控件中显示的文本的指针。 设置控件的标题或文本属性的值（如果有）。 如果为 NULL，则控件的标题或文本属性不会更改。

*dwStyle*<br/>
窗口样式。 可用样式列在"备注"下。

*矩形*<br/>
指定控件的大小和位置。 它可以是[CRect](../../atl-mfc-shared/reference/crect-class.md)对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。

*Ppt*<br/>
指向包含控件左上角`CPoint`的 POINT[结构](/windows/win32/api/windef/ns-windef-point)或对象。

*pSize*<br/>
指向包含控件[SIZE](/windows/win32/api/windef/ns-windef-size)大小的 SIZE`CSize`结构或对象

*pparentwnd*<br/>
指定控件的父窗口。 值不得为 NULL。

*nID*<br/>
指定控件的 ID。

*p 坚持*<br/>
指向包含控件的持久状态的[CFile](../../mfc/reference/cfile-class.md)的指针。 默认值为 NULL，指示控件在不从任何持久存储还原其状态的情况下初始化自身。 如果不是 NULL，它应该是指向`CFile`派生对象的指针，该对象包含控件的持久数据，其形式是流或存储。 此数据可能已保存在客户端的上次激活中。 `CFile`可以包含其他数据，但必须将其读写指针设置为调用`CreateControl`时持久性数据的第一个字节。

*b 存储*<br/>
指示是否应将*pPersist*中的数据解释为 IStorage 或 IStream 数据。 如果*pPersist*中的数据是存储，*则 b 存储*应为 TRUE。 如果*pPersist*中的数据是流，*则 b 存储*应为 FALSE。 默认值是 FALSE。

*bstrLicKey*<br/>
可选的许可证密钥数据。 仅创建需要运行时许可证密钥的控件才需要此数据。 如果控件支持许可，则必须提供许可证密钥才能成功创建控件。 默认值为 NULL。

*Clsid*<br/>
控件的唯一类 ID。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

`CreateControl`是[CWnd：：创建](#create)函数的直接模拟，它为 创建 窗口`CWnd`。 `CreateControl`创建 ActiveX 控件而不是普通窗口。

仅支持 Windows *dwStyle*标志的子集`CreateControl`：

- WS_VISIBLE 创建最初可见的窗口。 如果希望控件立即可见（如普通窗口），则需要。

- WS_DISABLED 创建最初禁用的窗口。 禁用的窗口无法接收用户输入。 如果控件具有"已启用"属性，则可以进行设置。

- WS_BORDER 创建具有细线边框的窗口。 如果控件具有 BorderStyle 属性，则可以进行设置。

- WS_GROUP 指定一组控件的第一个控件。 用户可以使用方向键将键盘焦点从组中的一个控件更改为下一个控件。 在第一个控件之后使用WS_GROUP样式定义的所有控件都属于同一组。 具有WS_GROUP样式的下一个控件将结束组并启动下一个组。

- WS_TABSTOP 指定可在用户按下 TAB 键时接收键盘焦点的控件。 按下 TAB 键会将键盘焦点更改为WS_TABSTOP样式的下一个控件。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]

## <a name="cwndcreateex"></a><a name="createex"></a>CWnd：：创建Ex

创建指定的窗口并将其附加到`CWnd`对象。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU nIDorHMenu,
    LPVOID lpParam = NULL);

virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    LPVOID lpParam = NULL);
```

### <a name="parameters"></a>参数

*dwExStyle*<br/>
[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)的位组合 （OR）;否则默认扩展窗口样式为 NULL。

*lpszClass名称*<br/>
指向包含已注册系统窗口类名称的 null 终止字符串的指针;或预定义的系统窗口类的名称。

*lpsz窗口名称*<br/>
指向包含窗口显示名称的 null 终止字符串的指针;否则 NULL 没有窗口显示名称。

*dwStyle*<br/>
[窗口样式](styles-used-by-mfc.md#window-styles)的位组合 （OR）;否则默认窗口样式为 NULL。

** x <br/>
窗口与屏幕左侧或父窗口的初始水平距离。

*Y*<br/>
窗口与屏幕顶部或父窗口的初始垂直距离。

*n 宽度*<br/>
窗口的宽度（以像素为单位）。

*nHeight*<br/>
窗口的高度（以像素为单位）。

*hwnd 家长*<br/>
对于子窗口，对父窗口的句柄;否则，如果窗口具有所有者，则所有者窗口的句柄。

*尼多尔赫梅*<br/>
对于子窗口，窗口 ID;否则，窗口的菜单的 ID。

*lpParam*<br/>
指向传递给[CWnd：：：onCreate](#oncreate)方法的用户数据在*lpCreateParams*字段中。

*矩形*<br/>
窗口相对于屏幕或父窗口的大小和位置。

*pparentwnd*<br/>
对于子窗口，指向父窗口;否则，如果窗口具有所有者，则指向所有者窗口。

*nID*<br/>
对于子窗口，窗口 ID;否则，窗口的菜单的 ID。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

> [!WARNING]
> `CWnd::PreCreateWindow`现在，如果菜单为 NULL 且`CREATESTRUCT`样式包含WS_CHILD，则将其参数的 hMenu 成员分配给**此**指针。 要获得正确的功能，请确保对话框控件的 ID 不是 NULL。
>
> 此更改修复了托管/本机互操作方案中的崩溃。 中的`TRACE``CWnd::Create`语句提醒开发人员问题。

默认扩展窗口样式为WS_EX_LEFT。 默认窗口样式为WS_OVERLAPPED。

使用[Afx 注册WndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函数注册窗口类。 用户定义的窗口类在注册的模块中可用。

子窗口的维度相对于父窗口工作区的左上角。 顶层窗口的尺寸相对于屏幕的左上角。

在`CreateEx`方法返回之前和窗口变得可见之前调用[CWnd：：onCreate](#oncreate)方法。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]

## <a name="cwndcreategraycaret"></a><a name="creategraycaret"></a>CWnd：：创建格雷卡雷

为系统加斯特创建灰色矩形，并声称对图特的所有权。

```
void CreateGrayCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*n 宽度*<br/>
指定卡斯特的宽度（以逻辑单位表示）。 如果此参数为 0，则宽度设置为系统定义的窗口边框宽度。

*nHeight*<br/>
指定卡斯特的高度（以逻辑单位表示）。 如果此参数为 0，则高度设置为系统定义的窗口边框高度。

### <a name="remarks"></a>备注

倾斜的形状可以是一条线或一个块。

参数*nWidth*和*nHeight*指定护套的宽度和高度（以逻辑单位为单位）;确切的宽度和高度（以像素为单位）取决于映射模式。

使用SM_CXBORDER和SM_CYBORDER索引的[GetSystemMetricS](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可以检索系统的窗口边框宽度或高度。 使用窗口边框宽度或高度可确保在高分辨率显示屏上可以看到卡斯特。

成员`CreateGrayCaret`函数会自动销毁以前的 caret 形状（如果有），而不管哪个窗口拥有该图。 创建后，该隐子最初将隐藏。 要显示 caret，必须调用[ShowCaret](#showcaret)成员函数。

系统资源是共享资源。 `CWnd`仅当具有输入焦点或处于活动状态时，才应创建一个 care。 它应该在失去输入焦点或变为非活动状态之前销毁该 care。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]

## <a name="cwndcreatesolidcaret"></a><a name="createsolidcaret"></a>CWnd：：创建固体卡丁

为系统加斯特创建一个实体矩形，并声称对图特的所有权。

```
void CreateSolidCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*n 宽度*<br/>
指定卡斯特的宽度（以逻辑单位表示）。 如果此参数为 0，则宽度设置为系统定义的窗口边框宽度。

*nHeight*<br/>
指定卡斯特的高度（以逻辑单位表示）。 如果此参数为 0，则高度设置为系统定义的窗口边框高度。

### <a name="remarks"></a>备注

倾斜的形状可以是一条线或块。

参数*nWidth*和*nHeight*指定护套的宽度和高度（以逻辑单位为单位）;确切的宽度和高度（以像素为单位）取决于映射模式。

使用SM_CXBORDER和SM_CYBORDER索引的[GetSystemMetricS](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可以检索系统的窗口边框宽度或高度。 使用窗口边框宽度或高度可确保在高分辨率显示屏上可以看到卡斯特。

成员`CreateSolidCaret`函数会自动销毁以前的 caret 形状（如果有），而不管哪个窗口拥有该图。 创建后，该隐子最初将隐藏。 要显示 caret，必须调用[ShowCaret](#showcaret)成员函数。

系统资源是共享资源。 `CWnd`仅当具有输入焦点或处于活动状态时，才应创建一个 care。 它应该在失去输入焦点或变为非活动状态之前销毁该 care。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]

## <a name="cwndcwnd"></a><a name="cwnd"></a>CWnd：Cwnd

构造 `CWnd` 对象。

```
CWnd();
```

### <a name="remarks"></a>备注

在调用[CreateEx](#createex)或[Create](#create)成员函数之前，不会创建和附加 Windows 窗口。

## <a name="cwnddefault"></a><a name="default"></a>CWnd：:D

调用默认窗口过程。

```
LRESULT Default();
```

### <a name="return-value"></a>返回值

取决于发送的消息。

### <a name="remarks"></a>备注

默认窗口过程为应用程序未处理的任何窗口消息提供默认处理。 此成员函数可确保处理每条消息。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]

## <a name="cwnddefwindowproc"></a><a name="defwindowproc"></a>CWnd：:DefWindowProc

调用默认窗口过程，该过程为应用程序未处理的任何窗口消息提供默认处理。

```
virtual LRESULT DefWindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要处理的 Windows 消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

### <a name="return-value"></a>返回值

取决于发送的消息。

### <a name="remarks"></a>备注

此成员函数可确保处理每条消息。 调用它的参数应与窗口过程接收的参数相同。

## <a name="cwnddeletetempmap"></a><a name="deletetempmap"></a>CWnd：:DeleteTempMap

由`CWinApp`对象的空闲时间处理程序自动调用。

```
static void PASCAL DeleteTempMap();
```

### <a name="remarks"></a>备注

删除`FromHandle`成员函数创建`CWnd`的任何临时对象。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]

## <a name="cwnddestroywindow"></a><a name="destroywindow"></a>CWnd：:D

销毁附加到`CWnd`对象的 Windows 窗口。

```
virtual BOOL DestroyWindow();
```

### <a name="return-value"></a>返回值

如果窗口被破坏，则非零;否则 0。

### <a name="remarks"></a>备注

成员`DestroyWindow`函数向窗口发送适当的消息以停用它并删除输入焦点。 它还会破坏窗口的菜单、刷新应用程序队列、销毁未完成的计时器、删除剪贴板所有权，并中断"剪贴板-查看器"链（如果`CWnd`位于查看器链的顶部）。 它将[WM_DESTROY](#ondestroy)和[WM_NCDESTROY](#onncdestroy)消息发送到窗口。 它不会破坏对象`CWnd`。

`DestroyWindow`是执行清理的占位符。 因为它是`DestroyWindow`一个虚拟函数，它显示在类视图中的任何`CWnd`派生类中。 但是，即使您重写`CWnd`派生类中的此函数，`DestroyWindow`也不一定调用。 如果在`DestroyWindow`MFC 代码中未调用，则必须在您自己的代码中显式调用它（如果希望调用它）。

例如，假设您在`DestroyWindow``CView`派生类中重写了。 由于 MFC 源代码不在其`DestroyWindow`任何`CFrameWnd`派生类中调用，因此除非显式调用它`DestroyWindow`，否则不会调用重写。

如果窗口是任何窗口的父窗口，则在销毁父窗口时，这些子窗口将自动销毁。 成员`DestroyWindow`函数首先销毁子窗口，然后销毁窗口本身。

成员`DestroyWindow`函数还销毁由[CDialog：：：create](../../mfc/reference/cdialog-class.md#create)创建的无模式对话框。

如果正在`CWnd`销毁的是子窗口，并且没有[设置WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)样式，则[WM_PARENTNOTIFY](/previous-versions/windows/desktop/inputmsg/wm-parentnotify)消息将发送到父级。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]

## <a name="cwnddetach"></a><a name="detach"></a>CWnd：:D埃塔奇

从 `CWnd` 对象分离 Windows 句柄并返回该句柄。

```
HWND Detach();
```

### <a name="return-value"></a>返回值

到 Windows 对象的 HWND。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：附加](#attach)。

## <a name="cwnddlgdirlist"></a><a name="dlgdirlist"></a>CWnd：:DlgDirlist

使用文件或目录列表填充列表框。

```
int DlgDirList(
    LPTSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>参数

*lpPathSpec*<br/>
指向包含路径或文件名的 null 端接字符串。 `DlgDirList`修改此字符串，该字符串应足够长以包含修改。 有关详细信息，请参阅以下"备注"部分。

*nIDListBox*<br/>
指定列表框的标识符。 如果*nIDListBox*为`DlgDirList`0，则假定不存在列表框，并且不会尝试填充列表框。

*nID静态路径*<br/>
指定用于显示当前驱动器和目录的静态文本控件的标识符。 如果*nIDStaticPath*为`DlgDirList`0，则假定不存在此类文本控件。

*n文件类型*<br/>
指定要显示的文件的属性。 它可以是以下值的任意组合：

- DDL_READWRITE没有附加属性的读取写入数据文件。

- DDL_READONLY只读文件。

- DDL_HIDDEN隐藏文件。

- DDL_SYSTEM系统文件。

- DDL_DIRECTORY 目录。

- DDL_ARCHIVE档案

- DDL_POSTMSGSLB_DIR标志。 如果设置了LB_DIR标志，Windows 会将生成的消息放在应用程序的`DlgDirList`队列中;如果设置了 LB_DIR 标志，则 Windows 将生成的消息放在应用程序的队列中。否则，它们将直接发送到对话框过程。

- DDL_DRIVES驱动器。 如果设置了DDL_DRIVES标志，则会自动设置DDL_EXCLUSIVE标志。 因此，要创建包含驱动器和文件的目录列表，必须调用`DlgDirList`两次：一次使用DDL_DRIVES标志集，一次使用列表其余部分的标志。

- DDL_EXCLUSIVE独占位。 如果设置了独占位，则仅列出指定类型的文件;如果设置了独占位位，则仅列出指定类型的文件。否则将列出指定类型的正常文件和文件。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

`DlgDirList`将[LB_RESETCONTENT](/windows/win32/Controls/lb-resetcontent)和[LB_DIR](/windows/win32/Controls/lb-dir)消息发送到列表框。 它填充*nIDListBox*指定的列表框，包含与*lpPathSpec*给出的路径匹配的所有文件的名称。

*lpPathSpec 参数*具有以下形式：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此示例中，*驱动器*是驱动器号，*目录*是有效的目录名称，*文件名*是必须至少包含一个通配符的有效文件名。 通配符是一个问号 **（？），** 意思是匹配任何字符，和星号 （），<strong>\*</strong>这意味着匹配任意数量的字符。

如果为*lpPathSpec*指定 0 长字符串 ，或者仅指定目录名称但不包含任何文件规范，则该字符串将更改为 "\*。\*".

如果*lpPathSpec*包含驱动器和/或目录名称，则在填充列表框之前，当前驱动器和目录将更改为指定的驱动器和目录。 *nIDStaticPath*标识的文本控件也会使用新驱动器和/或目录名称进行更新。

填充列表框后，通过删除路径的驱动器和/或目录部分来更新*lpPathSpec。*

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]

## <a name="cwnddlgdirlistcombobox"></a><a name="dlgdirlistcombobox"></a>CWnd：:DlgDirlistComboBox

使用文件或目录列表填充组合框的列表框。

```
int DlgDirListComboBox(
    LPTSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>参数

*lpPathSpec*<br/>
指向包含路径或文件名的 null 端接字符串。 `DlgDirListComboBox`修改此字符串，因此此数据不应以字符串文本的形式出现。 请参阅以下"备注"部分。

*nIDComboBox*<br/>
在对话框中指定组合框的标识符。 如果*nIDComboBox*为`DlgDirListComboBox`0，则假定不存在组合框，并且不会尝试填充组合框。

*nID静态路径*<br/>
指定用于显示当前驱动器和目录的静态文本控件的标识符。 如果*nIDStaticPath*为`DlgDirListComboBox`0，则假定不存在此类文本控件。

*n文件类型*<br/>
指定要显示文件的 DOS 文件属性。 它可以是以下值的任意组合：

- DDL_READWRITE没有附加属性的读取写入数据文件。

- DDL_READONLY只读文件。

- DDL_HIDDEN隐藏文件。

- DDL_SYSTEM系统文件。

- DDL_DIRECTORY 目录。

- DDL_ARCHIVE档案

- DDL_POSTMSGSCB_DIR标志。 如果设置了CB_DIR标志，Windows 会将生成的消息放在应用程序的`DlgDirListComboBox`队列中;如果设置了 CB_DIR 标志，则 Windows 将生成的消息放在应用程序的队列中。否则，它们将直接发送到对话框过程。

- DDL_DRIVES驱动器。 如果设置了DDL_DRIVES标志，则会自动设置DDL_EXCLUSIVE标志。 因此，要创建包含驱动器和文件的目录列表，必须调用`DlgDirListComboBox`两次：一次使用DDL_DRIVES标志集，一次使用列表其余部分的标志。

- DDL_EXCLUSIVE独占位。 如果设置了独占位，则仅列出指定类型的文件;如果设置了独占位位，则仅列出指定类型的文件。否则将列出指定类型的正常文件和文件。

### <a name="return-value"></a>返回值

指定函数的结果。 如果进行了列表，则为非零，甚至是空列表。 0 返回值表示输入字符串不包含有效的搜索路径。

### <a name="remarks"></a>备注

`DlgDirListComboBox`将[CB_RESETCONTENT](/windows/win32/Controls/cb-resetcontent)消息和[CB_DIR](/windows/win32/Controls/cb-dir)消息发送到组合框。 它填充*nIDComboBox*指定的组合框的列表框，包含与*lpPathSpec*给出的路径匹配的所有文件的名称。

*lpPathSpec 参数*具有以下形式：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此示例中，*驱动器*是驱动器号，*目录*是有效的目录名称，*文件名*是必须至少包含一个通配符的有效文件名。 通配符是一个问号 **（？），** 意思是匹配任何字符，和星号 （），<strong>\*</strong>这意味着匹配任意数量的字符。

如果为*lpPathSpec*指定零长度字符串，将使用当前目录，并且不会修改*lpPathSpec。* 如果只指定目录名称，但不包含任何文件规范，则字符串将更改为""。\*

如果*lpPathSpec*包含驱动器和/或目录名称，则在填充列表框之前，当前驱动器和目录将更改为指定的驱动器和目录。 *nIDStaticPath*标识的文本控件也会使用新驱动器和/或目录名称进行更新。

填充组合框列表框后，通过删除路径的驱动器和/或目录部分来更新*lpPathSpec。*

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]

## <a name="cwnddlgdirselect"></a><a name="dlgdirselect"></a>CWnd：:DlgDirSelect

从列表框检索当前所选内容。

```
BOOL DlgDirSelect(
    LPTSTR lpString,
    int nIDListBox);
```

### <a name="parameters"></a>参数

*lpString*<br/>
指向要在列表框中接收当前选择的缓冲区。

*nIDListBox*<br/>
在对话框中指定列表框的整数 ID。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

它假定列表框已由[DlgDirList](#dlgdirlist)成员函数填充，并且所选内容是驱动器号、文件或目录名称。

成员`DlgDirSelect`函数将所选内容复制到*lpString*提供的缓冲区。 如果没有选择 *，lpString*不会更改。

`DlgDirSelect`将[LB_GETCURSEL](/windows/win32/Controls/lb-getcursel)和[LB_GETTEXT](/windows/win32/Controls/lb-gettext)消息发送到列表框。

它不允许从列表框中返回多个文件名。 列表框不能是多选列表框。

## <a name="cwnddlgdirselectcombobox"></a><a name="dlgdirselectcombobox"></a>CWnd：:DlgDirSelectComboBox

从组合框的列表框检索当前所选内容。

```
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,
    int nIDComboBox);
```

### <a name="parameters"></a>参数

*lpString*<br/>
指向要接收所选路径的缓冲区。

*nIDComboBox*<br/>
在对话框中指定组合框的整数 ID。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

它假定列表框已由[DlgDirListComboBox](#dlgdirlistcombobox)成员函数填充，并且所选内容是驱动器号、文件或目录名称。

成员`DlgDirSelectComboBox`函数将所选内容复制到指定的缓冲区。 如果没有选择，则不会更改缓冲区的内容。

`DlgDirSelectComboBox`将[CB_GETCURSEL](/windows/win32/Controls/cb-getcursel)和[CB_GETLBTEXT](/windows/win32/Controls/cb-getlbtext)消息发送到组合框。

它不允许从组合框中返回多个文件名。

## <a name="cwnddodataexchange"></a><a name="dodataexchange"></a>CWnd：:DoDataExchange

由框架调用以交换和验证对话框数据。

```
virtual void DoDataExchange(CDataExchange* pDX);
```

### <a name="parameters"></a>参数

*pDX*<br/>
一个指向 `CDataExchange` 对象的指针。

### <a name="remarks"></a>备注

切勿直接调用此函数。 它由[UpdateData](#updatedata)成员函数调用。 调用`UpdateData`以初始化对话框的控件或从对话框检索数据。

从[CDialog](../../mfc/reference/cdialog-class.md)派生特定于应用程序的对话框类时，如果要利用框架的自动数据交换和验证，则需要重写此成员函数。 "添加变量"向导将为您编写此成员函数的重写版本，其中包含对话框数据交换 （DDX） 和验证 （DDV） 全局函数调用所需的"数据映射"。

要自动生成此成员函数的重写版本，请先使用对话框编辑器创建对话框资源，然后派生特定于应用程序的对话框类。 然后，使用"添加变量"向导将变量、数据和验证范围与新对话框中的各种控件相关联。 然后，向导将写入包含数据`DoDataExchange`映射的重写 的 。a。 下面是添加变量向导生成的 DDX/DDV 代码块示例：

[!code-cpp[NVC_MFCWindowing#90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]

`DoDataExchange`重写的成员函数必须位于源文件中的宏语句之前。

有关对话框数据交换和验证的详细信息，请参阅在[窗体中显示和操作数据](../../data/odbc/displaying-and-manipulating-data-in-a-form.md)以及[对话框数据交换和验证](../../mfc/dialog-data-exchange-and-validation.md)。 有关添加变量向导生成的DDX_和DDV_宏的说明，请参阅[技术说明 26](../../mfc/tn026-ddx-and-ddv-routines.md)。

## <a name="cwnddragacceptfiles"></a><a name="dragacceptfiles"></a>CWnd：:D拉格接受文件

在应用程序的`CWnd`[CWinApp：：initA 函数](../../mfc/reference/cwinapp-class.md#initinstance)中使用指针从窗口内调用此成员函数，以指示窗口接受从 Windows 文件管理器或文件资源管理器中删除的文件。

```
void DragAcceptFiles(BOOL bAccept = TRUE);
```

### <a name="parameters"></a>参数

*B 接受*<br/>
指示是否接受拖动文件的标志。

### <a name="remarks"></a>备注

只有使用`DragAcceptFiles`*bAccept*参数设置为 TRUE 调用的窗口才标识自己能够处理 Windows 消息WM_DROPFILES。 例如，在 MDI 应用程序中，如果在`CMDIFrameWnd``DragAcceptFiles`函数调用中使用窗口指针，则只有`CMDIFrameWnd`窗口获取WM_DROPFILES消息。 此消息不会发送到所有打开`CMDIChildWnd`的窗口。 要接收`CMDIChildWnd`此消息的窗口，必须使用`DragAcceptFiles``CMDIChildWnd`窗口指针调用。

要停止接收被拖的文件，请调用成员函数，将*bAccept*设置为 FALSE。

## <a name="cwnddragdetect"></a><a name="dragdetect"></a>CWnd：:D拉格检测

捕获鼠标并跟踪其移动，直到用户释放左键、按 ESC 键或将鼠标移动到围绕指定点的拖动矩形外部。

```
BOOL DragDetect(POINT pt) const;
```

### <a name="parameters"></a>参数

*pt*<br/>
鼠标的初始位置，位于屏幕坐标中。 函数使用此点确定拖动矩形的坐标。

### <a name="return-value"></a>返回值

如果用户按住左键时将鼠标移到拖动矩形之外，则返回值为非零。

如果用户按住左键时未将鼠标移到拖动矩形之外，则返回值为零。

### <a name="remarks"></a>备注

此成员函数模拟函数[DragDetect](/windows/win32/api/winuser/nf-winuser-dragdetect)的功能，如 Windows SDK 中所述。

## <a name="cwnddrawanimatedrects"></a><a name="drawanimatedrects"></a>CWnd：:D原始动画Rects

绘制透明框架矩形并对它进行动画处理，以指示图标的打开或是窗口的最小化或最大化。

```
BOOL DrawAnimatedRects(
    int idAni,
    CONST RECT* lprcFrom,
    CONST RECT* lprcTo);
```

### <a name="parameters"></a>参数

*伊德安尼*<br/>
指定动画类型。 如果指定IDANI_CAPTION，窗口标题将从*lprcFrom*指定的位置到*lprcTo*指定的位置进行动画处理。 效果类似于最小化或最大化窗口。

*lprc 从*<br/>
指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针，指定图标的位置和大小或最小化的窗口。

*利浦帕托*<br/>
指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针，指定还原窗口的位置和大小

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[DrawAnimatedRects](/windows/win32/api/winuser/nf-winuser-drawanimatedrects)的功能，如 Windows SDK 中所述。

## <a name="cwnddrawcaption"></a><a name="drawcaption"></a>CWnd：:D原始标题

绘制窗口标题。

```
BOOL DrawCaption(
    CDC* pDC,
    LPCRECT lprc,
    UINT uFlags);
```

### <a name="parameters"></a>参数

*pDC*<br/>
一个指向设备上下文的指针。 该函数将窗口标题绘制到此设备上下文中。

*利赫浦*<br/>
指向 RECT 结构的指针，用于指定窗口标题的边界矩形。

*uFlags*<br/>
指定绘图选项。 有关值的完整列表，请参阅[绘制标题](/windows/win32/api/winuser/nf-winuser-drawcaption)。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[DrawCaption](/windows/win32/api/winuser/nf-winuser-drawcaption)的功能，如 Windows SDK 中所述。

## <a name="cwnddrawmenubar"></a><a name="drawmenubar"></a>CWnd：:D原始菜单栏

重绘菜单栏。

```
void DrawMenuBar();
```

### <a name="remarks"></a>备注

如果在 Windows 创建窗口后更改了菜单栏，请调用此函数以绘制已更改的菜单栏。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：获取菜单](#getmenu)。

## <a name="cwndenableactiveaccessibility"></a><a name="enableactiveaccessibility"></a>CWnd：：启用主动辅助功能

启用用户定义的活动辅助功能。

```
void EnableActiveAccessibility();
```

### <a name="remarks"></a>备注

MFC 的默认活动辅助功能支持足以用于标准窗口和控制，包括 ActiveX 控件;但是，如果`CWnd`派生类包含非窗口用户界面元素，MFC 无法知道它们。 在这种情况下，必须重写类中的相应[活动辅助功能成员函数](/windows/win32/winauto/sdk-components)，并且必须调用`EnableActiveAccessibility`类的构造函数。

## <a name="cwndenabledynamiclayout"></a><a name="enabledynamiclayout"></a>CWnd：：启用动态布局

启用或禁用动态布局管理器。 启用动态布局时，子窗口的位置和大小可以在用户调整窗口大小时动态调整。

```
void EnableDynamicLayout(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
如果为 TRUE，则启用动态布局；如果为 FALSE，则禁用动态布局。

### <a name="remarks"></a>备注

如果想要启用动态布局，你不只需要调用此方法。 还必须提供指定动态布局信息，此信息指定窗口中的控件如何响应大小更改。 可以在资源编辑器中（或以编程方式）为每个控件指定此信息。 请参阅[动态布局](../../mfc/dynamic-layout.md)。

## <a name="cwndenabled2dsupport"></a><a name="enabled2dsupport"></a>CWnd：：启用D2D支持

启用或禁用窗口 D2D 支持。 在初始化主窗口之前调用此方法。

```
void EnableD2DSupport(
    BOOL bEnable = TRUE,
    BOOL bUseDCRenderTarget = FALSE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定是打开还是关闭 D2D 支持。

*bUseDCRender目标*<br/>
指定是否使用设备上下文 (DC) 呈现器目标 CDCRenderTarget。 如果为 FALSE，则使用 CHwndRenderTarget。

## <a name="cwndenablescrollbar"></a><a name="enablescrollbar"></a>CWnd：：启用滚动条

启用或禁用滚动条的一个或两个箭头。

```
BOOL EnableScrollBar(
    int nSBFlags,
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```

### <a name="parameters"></a>参数

*nSBFlags*<br/>
指定滚动条类型。 可以是下列值之一：

- SB_BOTH 启用或禁用与窗口关联的水平和垂直滚动条的箭头。

- SB_HORZ 启用或禁用与窗口关联的水平滚动条的箭头。

- SB_VERT 启用或禁用与窗口关联的垂直滚动条的箭头。

*nArrowFlags*<br/>
指定滚动条箭头是启用还是禁用，以及启用或禁用哪些箭头。 可以是下列值之一：

- ESB_ENABLE_BOTH 启用滚动条的两个箭头（默认值）。

- ESB_DISABLE_LTUP禁用水平滚动条的左箭头或垂直滚动条的向上箭头。

- ESB_DISABLE_RTDN禁用水平滚动条的右箭头或垂直滚动条的向下箭头。

- ESB_DISABLE_BOTH禁用滚动条的两个箭头。

### <a name="return-value"></a>返回值

如果箭头已启用或禁用（如指定）则为非零。 否则为 0，表示箭头已处于请求状态或发生错误。

## <a name="cwndenablescrollbarctrl"></a><a name="enablescrollbarctrl"></a>CWnd：：启用ScrollBarCtrl

启用或禁用此窗口的滚动条。

```
void EnableScrollBarCtrl(
    int nBar,
    BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*nBar*<br/>
滚动条标识符。

*b 启用*<br/>
指定是启用还是禁用滚动条。

### <a name="remarks"></a>备注

如果窗口具有同级滚动条控件，则使用该滚动条;如果窗口具有同级滚动条控件，则使用该滚动条。否则使用窗口自己的滚动条。

## <a name="cwndenabletooltips"></a><a name="enabletooltips"></a>CWnd：：启用工具提示

为给定窗口启用工具提示。

```
BOOL EnableToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定工具尖端控件是启用还是禁用。 TRUE 启用控件;FALSE 禁用控件。

### <a name="return-value"></a>返回值

如果启用了工具提示，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

覆盖[OnToolHitTest，](#ontoolhittest)为窗口提供[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)结构或结构。

> [!NOTE]
> 某些窗口（如[CToolBar）](../../mfc/reference/ctoolbar-class.md)提供了[OnToolHitTest 的](#ontoolhittest)内置实现。

有关此结构的详细信息，请参阅 Windows SDK 中的[TOOLINFO。](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)

除非父`EnableToolTips`窗口派生自`CFrameWnd`，否则仅调用不足以显示子控件的工具提示。 这是因为`CFrameWnd`为TTN_NEEDTEXT通知提供了默认处理程序。 如果父窗口不是派生自`CFrameWnd`，即，如果它是对话框或窗体视图，则子控件的工具提示将不能正确显示，除非您为TTN_NEEDTEXT工具提示通知提供了处理程序。 请参阅[工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。

为窗口提供的默认工具提示`EnableToolTips`没有与其关联的文本。 要检索要显示的工具提示的文本，TTN_NEEDTEXT通知在显示工具提示窗口之前发送到工具提示控件的父窗口。 如果此消息没有处理程序为`TOOLTIPTEXT`结构的*pszText*成员分配一些值，则工具提示将不会显示任何文本。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]

[!code-cpp[NVC_MFCWindowing#92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]

## <a name="cwndenabletrackingtooltips"></a><a name="enabletrackingtooltips"></a>CWnd：：启用跟踪工具提示

启用或禁用跟踪工具提示。

```
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定是启用跟踪工具提示还是禁用。 如果此参数为 TRUE，将启用跟踪工具提示。 如果此参数为 FALSE，则将禁用跟踪工具提示。

### <a name="return-value"></a>返回值

指示调用`EnableWindow`成员函数之前的状态。 如果以前禁用了窗口，则返回值为非零。 如果以前启用了窗口或发生错误，则返回值为 0。

### <a name="remarks"></a>备注

跟踪工具提示是工具提示窗口，您可以在屏幕上动态定位。 通过快速更新位置，工具尖端窗口似乎移动平稳，或"跟踪"。 如果需要工具提示文本在指针移动时跟随指针的位置，此功能非常有用。

## <a name="cwndenablewindow"></a><a name="enablewindow"></a>CWnd：：启用窗口

启用或禁用鼠标和键盘输入。

```
BOOL EnableWindow(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定是启用还是禁用给定窗口。 如果此参数为 TRUE，则将启用该窗口。 如果此参数为 FALSE，则窗口将被禁用。

### <a name="return-value"></a>返回值

指示调用`EnableWindow`成员函数之前的状态。 如果以前禁用了窗口，则返回值为非零。 如果以前启用了窗口或发生错误，则返回值为 0。

### <a name="remarks"></a>备注

禁用输入后，将忽略鼠标单击和击键等输入。 启用输入后，窗口将处理所有输入。

如果启用的状态正在更改，则在返回此函数之前发送[WM_ENABLE](#onenable)消息。

如果禁用，则所有子窗口都隐式禁用，尽管它们未WM_ENABLE消息发送。

必须先启用窗口，然后才能激活它。 例如，如果应用程序显示无模式对话框并禁用其主窗口，则必须在销毁对话框之前启用主窗口。 否则，另一个窗口将获得输入焦点并激活。 如果禁用了子窗口，则当 Windows 尝试确定哪个窗口应获取鼠标消息时，将忽略该窗口。

默认情况下，创建窗口时将启用该窗口。 应用程序可以在["创建](#create)"或["CreateEx"](#createex)成员函数中指定WS_DISABLED样式，以创建最初禁用的窗口。 创建窗口后，应用程序还可以使用`EnableWindow`成员函数启用或禁用该窗口。

应用程序可以使用此函数启用或禁用对话框中的控件。 禁用的控件无法接收输入焦点，用户也无法访问它。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]

## <a name="cwndendmodalloop"></a><a name="endmodalloop"></a>CWnd：：结束模态循环

终止对`RunModalLoop`的调用。

```
virtual void EndModalLoop(int nResult);
```

### <a name="parameters"></a>参数

*nResult*<br/>
包含要返回给[RunModalLoop](#runmodalloop)调用方的值。

### <a name="remarks"></a>备注

*nResult*参数从 传播到返回值`RunModalLoop`。

## <a name="cwndendmodalstate"></a><a name="endmodalstate"></a>CWnd：：结束模式状态

调用此成员函数以将框架窗口从有模式更改为无模式。

```
virtual void EndModalState();
```

## <a name="cwndendpaint"></a><a name="endpaint"></a>CWnd：：结束油漆

标记给定窗口中绘画的结束。

```
void EndPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>参数

*lpPaint*<br/>
指向包含[BeginPaint](#beginpaint)成员函数检索的绘制信息的[PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct)结构。

### <a name="remarks"></a>备注

每次`EndPaint`调用`BeginPaint`成员函数都需要成员函数，但仅在绘制完成后完成。

如果参数被成员函数隐藏，`BeginPaint``EndPaint`则将 care 还原到屏幕。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：开始绘制](#beginpaint)。

## <a name="cwndexecutedlginit"></a><a name="executedlginit"></a>Cwnd：：执行Dlginit

启动对话框资源。

```
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
BOOL ExecuteDlgInit(LPVOID lpResource);
```

### <a name="parameters"></a>参数

*lpsz 资源名称*<br/>
指向指定资源名称的 null 端接字符串的指针。

*lp资源*<br/>
指向资源的指针。

### <a name="return-value"></a>返回值

如果执行了对话框资源，则为 TRUE;如果执行了对话框资源，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

`ExecuteDlgInit`将使用绑定到执行模块的资源，或从其他源中使用的资源。 为此，`ExecuteDlgInit`通过调用`AfxFindResourceHandle`查找资源句柄。 如果您的 MFC 应用程序不使用共享 DLL （MFCx0[U][D]）。DLL），`AfxFindResourceHandle`调用[AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle)，它返回可执行文件的当前资源句柄。 如果您的 MFC 应用程序使用 MFCx0[U][D]。DLL，`AfxFindResourceHandle`遍历共享`CDynLinkLibrary`和 MFC 扩展 DLL 的对象列表，以查找正确的资源句柄。

## <a name="cwndfiltertooltipmessage"></a><a name="filtertooltipmessage"></a>CWnd：：过滤器工具提示消息

由框架调用以显示工具提示消息。

```
void FilterToolTipMessage(MSG* pMsg);
```

### <a name="parameters"></a>参数

*pMsg*<br/>
指向工具提示消息的指针。

### <a name="remarks"></a>备注

在大多数 MFC 应用程序中，此方法由[预翻译消息](#pretranslatemessage)和[启用工具提示](#enabletooltips)的框架调用，您不需要自己调用它。

但是，在某些应用程序中（例如某些 ActiveX 控件）中，框架可能不会调用这些方法，您需要自己调用 FilterToolTipMessage。 有关详细信息，请参阅[创建工具提示的方法](../../mfc/methods-of-creating-tool-tips.md)。

## <a name="cwndfindwindow"></a><a name="findwindow"></a>CWnd：：查找窗口

返回其窗口类由`CWnd` *lpszClassName*提供，其窗口名称或标题由*lpszWindowName*提供的顶级级别。

```
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName);
```

### <a name="parameters"></a>参数

*lpszClass名称*<br/>
指向指定窗口的类名称（`WNDCLASS`结构）的 null 端接字符串。 如果*lpClassName*为 NULL，则所有类名称都匹配。

*lpsz窗口名称*<br/>
指向指定窗口名称（窗口标题）的 null 端接字符串。 如果*lpWindowName*为 NULL，则所有窗口名称都匹配。

### <a name="return-value"></a>返回值

标识具有指定类名称和窗口名称的窗口。 如果未找到此类窗口，则为 NULL。

`CWnd`* 可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

此功能不搜索子窗口。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]

## <a name="cwndfindwindowex"></a><a name="findwindowex"></a>CWnd：：查找窗口Ex

检索类名称和窗口名称与指定字符串匹配的窗口对象。

```
static CWnd* FindWindowEx(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCTSTR lpszClass,
    LPCTSTR lpszWindow);
```

### <a name="parameters"></a>参数

*hwnd 家长*<br/>
要搜索其子窗口的父窗口的句柄。

*hwndChild 后*<br/>
处理子窗口。 搜索以 Z 顺序的下一个子窗口开始。 子窗口必须是*hwndParent*的直接子窗口，而不仅仅是后代窗口。

*lpszClass*<br/>
指向 null 端接字符串的指针，该字符串指定以前对[注册类](/windows/win32/api/winuser/nf-winuser-registerclassw)或[RegisterClassEx](/windows/win32/api/winuser/nf-winuser-registerclassexw)的调用创建的类名称或类原子。

*lpszWindow*<br/>
指向指定窗口名称（窗口标题）的 null 端接字符串的指针。 如果此参数为 NULL，则所有窗口名称都匹配。

### <a name="return-value"></a>返回值

如果函数成功，则返回值是指向具有指定类和窗口名称的窗口对象的指针。 如果函数失败，则返回值为 NULL。

### <a name="remarks"></a>备注

此成员函数模拟函数[FindWindowEx](/windows/win32/api/winuser/nf-winuser-findwindowexw)的功能，如 Windows SDK 中所述。

## <a name="cwndflashwindow"></a><a name="flashwindow"></a>CWnd：：闪存窗口

闪烁给定窗口一次。

```
BOOL FlashWindow(BOOL bInvert);
```

### <a name="parameters"></a>参数

*b 反转*<br/>
指定`CWnd`是闪烁还是返回到其原始状态。 如果`CWnd` *binvert*为 TRUE，则从一种状态闪烁到另一种状态。 如果*bInvert*为 FALSE，则窗口将返回到其原始状态（活动或非活动状态）。

### <a name="return-value"></a>返回值

如果窗口在调用`FlashWindow`成员函数之前处于活动状态，则非零;否则 0。

### <a name="remarks"></a>备注

对于连续闪烁，创建一个系统计时器并重复`FlashWindow`调用 。 闪烁`CWnd`意味着更改其标题栏的外观，`CWnd`就像从非活动状态更改为活动状态一样，反之亦然。 （非活动标题栏更改为活动标题栏;活动标题栏更改为非活动标题栏。

通常，窗口会闪烁，以通知用户它需要注意，但它当前没有输入焦点。

仅当窗口获取输入焦点且不再闪烁时 *，bInvert*参数应为 FALSE;在等待输入焦点时，在连续调用时应为 TRUE。

对于最小化的窗口，此功能始终返回非零。 如果窗口最小化，`FlashWindow`只需闪烁窗口的图标;*b 对*最小化的窗口忽略反转。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]

## <a name="cwndflashwindowex"></a><a name="flashwindowex"></a>CWnd：：闪存窗口Ex

闪烁给定的窗口。

```
BOOL FlashWindowEx(
    DWORD dwFlags,
    UINT uCount,
    DWORD dwTimeout);
```

### <a name="parameters"></a>参数

dwFlags**<br/>
指定闪存状态。 有关值的完整列表，请参阅[FLASHWINFO](/windows/win32/api/winuser/ns-winuser-flashwinfo)结构。

*uCount*<br/>
指定闪烁窗口的次数。

*dwTimeout*<br/>
指定窗口闪烁的速率（以毫秒为单位）。 如果*dwTimeout*为零，则函数使用默认光标闪烁速率。

### <a name="return-value"></a>返回值

返回值指定窗口在调用`FlashWindowEx`函数之前的状态。 如果在调用之前将窗口标题绘制为活动，则返回值为非零。 否则，返回值为零。

### <a name="remarks"></a>备注

此方法模拟函数[FlashWindowEx](/windows/win32/api/winuser/nf-winuser-flashwindowex)的功能，如 Windows SDK 中所述。

## <a name="cwndfromhandle"></a><a name="fromhandle"></a>Cwnd：：从手

在提供了窗口的句柄时返回指向 `CWnd` 对象的指针。 如果 `CWnd` 对象未附加到该句柄，则会创建并附加一个临时 `CWnd` 对象。

```
static CWnd* PASCAL FromHandle(HWND hWnd);
```

### <a name="parameters"></a>参数

*hwnd*<br/>
窗口的 HWND。

### <a name="return-value"></a>返回值

在提供了窗口的句柄时返回指向 `CWnd` 对象的指针。 如果 `CWnd` 对象未附加到该句柄，则会创建并附加一个临时 `CWnd` 对象。

该指针可能是暂时的，不应存储起来供将来使用。

## <a name="cwndfromhandlepermanent"></a><a name="fromhandlepermanent"></a>Cwnd：：从处理永久

在提供了窗口的句柄时返回指向 `CWnd` 对象的指针。

```
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```

### <a name="parameters"></a>参数

*hwnd*<br/>
窗口的 HWND。

### <a name="return-value"></a>返回值

一个指向 `CWnd` 对象的指针。

### <a name="remarks"></a>备注

如果对象`CWnd`未附加到句柄，则返回 NULL。

与[FromHandle](#fromhandle)不同，此函数不创建临时对象。

## <a name="cwndget_accchild"></a><a name="get_accchild"></a>CWnd：get_accChild

由框架调用以检索指定子级的 `IDispatch` 接口地址。

```
virtual HRESULT get_accChild(
    VARIANT varChild,
    IDispatch** ppdispChild);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
标识要检索其`IDispatch`接口的子级。

*ppdispChild*<br/>
接收子对象的`IDispatch`接口的地址。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问"](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild)中的**返回值**：：get_accChild在 Windows SDK 中。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accChild。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild)

## <a name="cwndget_accchildcount"></a><a name="get_accchildcount"></a>CWnd：get_accChildCount

由框架调用调用以检索属于该对象的子级的个数。

```
virtual HRESULT get_accChildCount(long* pcountChildren);
```

### <a name="parameters"></a>参数

*计数儿童*<br/>
接收子级数。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问：：：get_accChildCount](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) Windows SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。 调用基类版本，然后添加非窗口子元素。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accChildCount。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount)

## <a name="cwndget_accdefaultaction"></a><a name="get_accdefaultaction"></a>CWnd：get_accDefaultAction

由框架调用以检索描述对象默认操作的字符串。

```
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,
    BSTR* pszDefaultAction);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的默认操作是对象的默认操作还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*pszDefaultAction*<br/>
接收描述指定对象的默认操作的本地化字符串的 BSTR 的地址，如果此对象没有默认操作，则 NULL。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问"](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)中的**返回值**：：get_accDefaultAction在 Windows SDK 中。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数，以描述对象的默认操作。

有关详细信息，请参阅 Windows SDK 中的[I 可访问：get_accDefaultAction。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)

## <a name="cwndget_accdescription"></a><a name="get_accdescription"></a>CWnd：：get_accDescription

由框架调用以检索描述指定对象的可视外观的字符串。

```
virtual HRESULT get_accDescription(
    VARIANT varChild,
    BSTR* pszDescription);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的描述是对象的描述还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*psz描述*<br/>
接收描述指定对象的本地化字符串的 BSTR 的地址，如果此对象没有可用的描述，则 NULL。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问：：：get_accDescription](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription) Windows SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数以描述对象。 调用基类版本并添加说明。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accDescription。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription)

## <a name="cwndget_accfocus"></a><a name="get_accfocus"></a>CWnd：get_accFocus

由框架调用以检索具有键盘焦点的对象。

```
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```

### <a name="parameters"></a>参数

*普瓦尔儿童*<br/>
接收有关具有焦点的对象的信息。 请参阅["可访问：：：get_accFocus](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus) Windows SDK 中的*pvarID。*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::get_accFocus` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的[I 可访问：：get_accFocus。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus)

## <a name="cwndget_acchelp"></a><a name="get_acchelp"></a>CWnd：：get_accHelp

由框架调用以检索对象的**帮助**属性字符串。

```
virtual HRESULT get_accHelp(
    VARIANT varChild,
    BSTR* pszHelp);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的帮助信息是对象的帮助信息还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*pszHelp*<br/>
接收包含指定对象的帮助信息的本地化字符串的 BSTR 的地址，如果没有可用的帮助信息，则 NULL。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问"](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp)中的**返回值**：：get_accHelp在 Windows SDK 中。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数，为对象提供帮助文本。

有关详细信息，请参阅 Windows SDK 中的["不可访问：：：get_accHelp。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp)

## <a name="cwndget_acchelptopic"></a><a name="get_acchelptopic"></a>CWnd：：get_accHelpTopic

由框架调用以检索与指定对象关联的**WinHelp**文件的完整路径以及该文件中相应主题的标识符。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>参数

*pszHelp文件*<br/>
接收与指定对象关联的`WinHelp`文件的完整路径（如果有）的 BSTR 的地址。

*瓦尔儿童*<br/>
指定要检索的帮助主题是对象的主题还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取对象的帮助主题）或子 ID（以获取对象一个子元素的帮助主题）。

*pidTopic*<br/>
标识与指定对象关联的帮助文件主题。 请参阅["可访问点：：get_accHelpTopic](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic)在 Windows SDK 中的*pidTopic。*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::get_accHelpTopic` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数，以提供有关对象的帮助信息。

有关详细信息，请参阅 Windows SDK 中的["可访问：：get_accHelpTopic。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic)

## <a name="cwndget_acckeyboardshortcut"></a><a name="get_acckeyboardshortcut"></a>CWnd：get_accKeyboardShortcut

由框架调用以检索指定对象的快捷键或访问键。

```
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,
    BSTR* pszKeyboardShortcut);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的键盘快捷方式是对象的快捷方式还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*psz键盘快捷键*<br/>
接收标识键盘快捷键的本地化字符串的 BSTR 的地址，如果没有与指定对象关联的键盘快捷方式，则 NULL。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问：：：get_accKeyboardShortcut](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)在 Windows SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

覆盖`CWnd`派生类中的此函数，以标识对象的键盘快捷方式。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accKeyboardShortcut。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)

## <a name="cwndget_accname"></a><a name="get_accname"></a>CWnd：：get_accName

由框架调用以检索指定对象的名称。

```
virtual HRESULT get_accName(
    VARIANT varChild,
    BSTR* pszName);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的名称是对象的名称还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*pszName*<br/>
接收包含指定对象名称的字符串的 BSTR 的地址。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问"](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname)中的**返回值**：：get_accName在 Windows SDK 中。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

重写`CWnd`派生类中的此函数以返回对象的名称。

有关详细信息，请参阅 Windows SDK 中的["不可访问：：get_accName。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname)

## <a name="cwndget_accparent"></a><a name="get_accparent"></a>CWnd：get_accParent

由框架调用以检索对象父级的 `IDispatch` 接口。

```
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```

### <a name="parameters"></a>参数

*ppdisp 父级*<br/>
接收父对象的`IDispatch`接口的地址。 如果没有父变量，或者子级无法访问其父变量，则变量设置为 NULL。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问：：：get_accParent](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent)在 Windows SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

在大多数情况下，您不必重写此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accParent。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent)

## <a name="cwndget_accrole"></a><a name="get_accrole"></a>CWnd：：get_accRole

由框架调用以检索描述指定对象的角色的信息。

```
virtual HRESULT get_accRole(
    VARIANT varChild,
    VARIANT* pvarRole);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的角色信息是对象的角色信息还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*普瓦尔罗尔*<br/>
接收角色信息。 请参阅["可访问：：：get_accRole](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole)在 Windows SDK 中的*pvarRole。*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::get_accRole` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["可访问：：：get_accRole。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole)

## <a name="cwndget_accselection"></a><a name="get_accselection"></a>CWnd：：get_accSelection

由框架调用以检索该对象的选定子级。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>参数

*普瓦尔儿童*<br/>
接收有关选择哪些子级的信息。 请参阅["可访问：：get_accSelection](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection) Windows SDK 中的*pvar 儿童*。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::get_accSelection` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["I 可访问：：：get_accSelection。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection)

## <a name="cwndget_accstate"></a><a name="get_accstate"></a>CWnd：：get_accState

由框架调用以检索指定对象的当前状态。

```
virtual HRESULT get_accState(
    VARIANT varChild,
    VARIANT* pvarState);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的状态信息是对象的状态信息还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*普瓦尔邦*<br/>
接收有关对象状态的信息。 请参阅["可访问点：：get_accState](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate)中的*pvarState。*

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅 Windows `IAccessible::get_accState` SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的[I 可访问：get_accState。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate)

## <a name="cwndget_accvalue"></a><a name="get_accvalue"></a>CWnd：get_accValue

由框架调用以检索指定对象的值。

```
virtual HRESULT get_accValue(
    VARIANT varChild,
    BSTR* pszValue);
```

### <a name="parameters"></a>参数

*瓦尔儿童*<br/>
指定要检索的值信息是对象的值信息还是对象的子元素之一。 此参数可以是CHILDID_SELF（获取有关对象的信息）或子 ID（以获取有关对象的子元素的信息）。

*pszValue*<br/>
接收包含对象的当前值的本地化字符串的 BSTR 的地址。

### <a name="return-value"></a>返回值

在成功时返回S_OK，在失败时返回 COM 错误代码。 请参阅["可访问：：：get_accValue](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue) Windows SDK 中的**返回值**。

### <a name="remarks"></a>备注

此功能是 MFC[活动辅助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支持的一部分。

如果您有非窗口的用户界面`CWnd`元素（MFC 处理的无窗口 ActiveX 控件之外），则覆盖派生类中的此函数。

有关详细信息，请参阅 Windows SDK 中的["I 可访问：：get_accValue。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue)

## <a name="cwndgetactivewindow"></a><a name="getactivewindow"></a>CWnd：：获取活动窗口

检索指向活动窗口的指针。

```
static CWnd* PASCAL GetActiveWindow();
```

### <a name="return-value"></a>返回值

活动窗口或 NULL（如果在调用时没有活动窗口）。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

活动窗口是具有当前输入焦点的窗口，或者[由 SetActiveWindow](#setactivewindow)成员函数显式激活的窗口。

## <a name="cwndgetancestor"></a><a name="getancestor"></a>CWnd：获取祖先

检索指定窗口的上级先窗口对象。

```
CWnd* GetAncestor(UINT gaFlags) const;
```

### <a name="parameters"></a>参数

*加旗*<br/>
指定要检索的祖先。 有关可能值的完整列表，请参阅[获取祖先](/windows/win32/api/winuser/nf-winuser-getancestor)。

### <a name="return-value"></a>返回值

如果函数成功，则返回值是指向祖先窗口对象的指针。 如果函数失败，则返回值为 NULL。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetAncestor](/windows/win32/api/winuser/nf-winuser-getancestor)的功能，如 Windows SDK 中所述。

## <a name="cwndgetcapture"></a><a name="getcapture"></a>CWnd：获取捕获

检索具有鼠标捕获的窗口。

```
static CWnd* PASCAL GetCapture();
```

### <a name="return-value"></a>返回值

标识具有鼠标捕获的窗口。 如果没有窗口具有鼠标捕获，则为 NULL。

返回值可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

在任何给定时间，只有一个窗口具有鼠标捕获。 调用[SetCapture](#setcapture)成员函数时，窗口接收鼠标捕获。 无论光标是否在其边界内，此窗口都会接收鼠标输入。

## <a name="cwndgetcaretpos"></a><a name="getcaretpos"></a>CWnd：：获取卡斯特波斯

检索加斯特当前位置的客户端坐标，并将它们作为 返回。 `CPoint`

```
static CPoint PASCAL GetCaretPos();
```

### <a name="return-value"></a>返回值

包含卡斯特位置坐标的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="remarks"></a>备注

在`CWnd`窗口的客户端坐标中给出的护理位置。

## <a name="cwndgetcheckedradiobutton"></a><a name="getcheckedradiobutton"></a>CWnd：：获取检查无线电按钮

检索指定组中当前选中的单选按钮的 ID。

```
int GetCheckedRadioButton(
    int nIDFirstButton,
    int nIDLastButton);
```

### <a name="parameters"></a>参数

*nID第一按钮*<br/>
指定组中第一个单选按钮的整数标识符。

*nIDLastButton*<br/>
指定组中最后一个单选按钮的整数标识符。

### <a name="return-value"></a>返回值

已检查的单选按钮的 ID，如果未选择，则为 0。

## <a name="cwndgetclientrect"></a><a name="getclientrect"></a>CWnd：：获取客户

将客户端区域的`CWnd`客户端坐标复制到*lpRect*指向的结构中。

```
void GetClientRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT 结构](/windows/win32/api/windef/ns-windef-rect)或`CRect`对象以接收客户端坐标。 `left`和`top`成员将为 0。 `right`和`bottom`成员将包含窗口的宽度和高度。

### <a name="remarks"></a>备注

客户端坐标指定工作区的左上角和右下角。 由于客户端坐标相对于`CWnd`工作区的左上角，因此左上角的坐标为 （0，0）。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：IsIconic](#isiconic)。

## <a name="cwndgetclipboardowner"></a><a name="getclipboardowner"></a>CWnd：：获取剪贴板所有者

检索剪贴板的当前所有者。

```
static CWnd* PASCAL GetClipboardOwner();
```

### <a name="return-value"></a>返回值

如果函数成功，则标识拥有剪贴板的窗口。 否则，它为 NULL。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

剪贴板仍可以包含数据，即使数据当前未拥有也是如此。

## <a name="cwndgetclipboardviewer"></a><a name="getclipboardviewer"></a>CWnd：：获取剪贴板查看器

检索剪贴板查看器链中的第一个窗口。

```
static CWnd* PASCAL GetClipboardViewer();
```

### <a name="return-value"></a>返回值

标识当前负责显示剪贴板的窗口（如果成功）;否则 NULL（例如，如果没有查看器）。

返回的指针可能是临时的，不应存储以供以后使用。

## <a name="cwndgetcontrolunknown"></a><a name="getcontrolunknown"></a>CWnd：：获取控制未知

调用此成员函数以检索指向未知 OLE 控件的指针。

```
LPUNKNOWN GetControlUnknown();
```

### <a name="return-value"></a>返回值

指向此`CWnd`对象表示的 OLE 控件的[I 未知](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口的指针。 如果此对象不表示 OLE 控件，则返回值为 NULL。

### <a name="remarks"></a>备注

不应释放此`IUnknown`指针。 通常，您将使用 来获取控件的特定接口。

返回的`GetControlUnknown`接口指针不计算引用。 不要调用[INots：：释放](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)指针，除非您以前在指针上调用[INots：：addRef。](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]

## <a name="cwndgetcurrentmessage"></a><a name="getcurrentmessage"></a>CWnd：获取当前消息

返回指向此窗口当前正在处理的消息的指针。 仅当在**消息消息**<em>Message</em>传递者成员函数中时才应调用。

```
static const MSG* PASCAL GetCurrentMessage();
```

### <a name="return-value"></a>返回值

返回指向[MSG](/windows/win32/api/winuser/ns-winuser-msg)结构的指针，其中包含窗口当前正在处理的消息。 仅当在<em>"打开消息"</em>处理程序**On**中时才应调用。

### <a name="example"></a>示例

  请参阅[CMDIFrameWnd 的示例：：MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)。

## <a name="cwndgetdc"></a><a name="getdc"></a>CWnd：GetDC

检索指向工作区的通用、类或专用设备上下文的指针，具体取决于为 指定的类样式`CWnd`。

```
CDC* GetDC();
```

### <a name="return-value"></a>返回值

如果成功，`CWnd`标识工作区的设备上下文;否则，返回值为 NULL。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

对于常见设备上下文，`GetDC`每次检索上下文时都会将默认属性分配给上下文。 对于类和私有上下文，`GetDC`保留以前分配的属性不变。 设备上下文可用于后续图形设备接口 （GDI） 函数，以在工作区中绘制。

除非设备上下文属于窗口类，否则必须调用[ReleaseDC](#releasedc)成员函数才能在绘制后释放上下文。

如果CS_CLASSDC、CS_OWNDC或CS_PARENTDC`CWnd`在注册类时指定`GetDC`为结构中的`WNDCLASS`样式，则成员函数将返回属于该类的设备上下文。

## <a name="cwndgetdcex"></a><a name="getdcex"></a>CWnd：：获取DCEx

检索窗口的设备上下文的`CWnd`句柄。

```
CDC* GetDCEx(
    CRgn* prgnClip,
    DWORD flags);
```

### <a name="parameters"></a>参数

*prgnClip*<br/>
标识可能与客户端窗口的可见区域组合的裁剪区域。

*标志*<br/>
可以具有以下预设值之一：

- DCX_CACHE从缓存返回设备上下文，而不是从 OWNDC 或 CLASSDC 窗口返回设备上下文。 覆盖CS_OWNDC和CS_CLASSDC。

- DCX_CLIPCHILDREN 排除窗口下方所有子窗口的`CWnd`可见区域。

- DCX_CLIPSIBLINGS 排除窗口上方所有同级窗口的`CWnd`可见区域。

- DCX_EXCLUDERGN 从返回的设备上下文的可见区域排除*prgnClip*标识的剪切区域。

- DCX_INTERSECTRGN 在返回的设备上下文的可见区域内与*prgnClip*标识的剪切区域相交。

- DCX_LOCKWINDOWUPDATE允许绘图，即使有一个`LockWindowUpdate`有效的调用，否则将排除此窗口。 此值用于跟踪期间的绘图。

- DCX_PARENTCLIP 使用父窗口的可见区域并忽略父窗口WS_CLIPCHILDREN和WS_PARENTDC样式位。 此值将设备上下文的原点设置到`CWnd`窗口的左上角。

- DCX_WINDOW 返回对应于窗口矩形而不是客户端矩形的设备上下文。

### <a name="return-value"></a>返回值

如果函数成功，则指定窗口的设备上下文;否则 NULL。

### <a name="remarks"></a>备注

设备上下文可用于后续 GDI 函数中，以在工作区中绘制。

此函数是[GetDC](/windows/win32/api/winuser/nf-winuser-getdc)函数的扩展，它使应用程序能够对窗口的设备上下文的剪切方式和是否进行更多控制。

除非设备上下文属于窗口类，否则必须调用[ReleaseDC](/windows/win32/api/winuser/nf-winuser-releasedc)函数才能在绘制后释放上下文。 由于在任何给定时间只有五个通用设备上下文可用，因此无法释放设备上下文可能会阻止其他应用程序访问设备上下文。

要获取缓存的设备上下文，应用程序必须指定[DCX_CACHE](/windows/win32/api/winuser/nf-winuser-getdcex)。 如果未指定DCX_CACHE并且窗口既不CS_OWNDC也不[CS_CLASSDC，](/windows/win32/api/winuser/ns-winuser-wndclassw)则此函数将返回 NULL。

如果注册类时在[WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw)结构中指定了[CS_CLASSDC、CS_OWNDC](/windows/win32/api/winuser/ns-winuser-wndclassw)或[CS_PARENTDC](/windows/win32/api/winuser/ns-winuser-wndclassw)样式，[则 GetDCEx](/windows/win32/api/winuser/nf-winuser-getdcex)函数会返回具有特殊特征的设备上下文。

有关这些特征的详细信息，请参阅 Windows SDK 中`WNDCLASS`结构的说明。

## <a name="cwndgetdcrendertarget"></a><a name="getdcrendertarget"></a>CWnd：：获取DCRender目标

检索 `CWnd` 窗口的设备上下文 (DC) 呈现目标。

```
CDCRenderTarget* GetDCRenderTarget();
```

### <a name="return-value"></a>返回值

如果函数成功，则是指定窗口的设备上下文呈现目标；否则为 NULL。

### <a name="remarks"></a>备注

## <a name="cwndgetdescendantwindow"></a><a name="getdescendantwindow"></a>Cwnd：获取窗口

调用此成员函数以查找给定 ID 指定的子窗口。

```
CWnd* GetDescendantWindow(
    int nID,
    BOOL bOnlyPerm = FALSE) const;
```

### <a name="parameters"></a>参数

*nID*<br/>
指定要检索的控件或子窗口的标识符。

*b 只*<br/>
指定要返回的窗口是否可以是暂时的。 如果为 TRUE，则只能返回永久窗口;如果为 TRUE，则只能返回永久窗口。如果 FALSE，则函数可以返回临时窗口。 有关临时窗口的详细信息，请参阅[技术说明 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="return-value"></a>返回值

指向`CWnd`对象的指针，如果没有找到子窗口，则为 NULL。

### <a name="remarks"></a>备注

此成员函数搜索整个子窗口树，而不仅仅是直接子窗口的窗口。

## <a name="cwndgetdesktopwindow"></a><a name="getdesktopwindow"></a>CWnd：：获取桌面窗口

返回 Windows 桌面窗口。

```
static CWnd* PASCAL GetDesktopWindow();
```

### <a name="return-value"></a>返回值

标识 Windows 桌面窗口。 此指针可能是临时指针，不应存储以供以后使用。

### <a name="remarks"></a>备注

桌面窗口覆盖整个屏幕，是上面绘制所有图标和其他窗口的区域。

## <a name="cwndgetdlgctrlid"></a><a name="getdlgctrlid"></a>CWnd：：GetDlgCtrlID

返回任何子窗口的窗口或控件 ID 值，而不仅仅是对话框中控件的窗口或控件 ID 值。

```
int GetDlgCtrlID() const;
```

### <a name="return-value"></a>返回值

如果函数成功，`CWnd`则子窗口的数字标识符;否则 0。

### <a name="remarks"></a>备注

由于顶级窗口没有 ID 值，因此，如果`CWnd`是 顶级窗口，则此函数的返回值将无效。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：OnCtlColor](#onctlcolor)。

## <a name="cwndgetdlgitem"></a><a name="getdlgitem"></a>CWnd：：GetDlgItem

在对话框或其他窗口中检索指向指定控件或子窗口的指针。

```
CWnd* GetDlgItem(int nID) const;

void GetDlgItem(
    int nID,
    HWND* phWnd) const;
```

### <a name="parameters"></a>参数

*nID*<br/>
指定要检索的控件或子窗口的标识符。

*phwnd*<br/>
指向子窗口的指针。

### <a name="return-value"></a>返回值

指向给定控件或子窗口的指针。 如果不存在*nID*参数提供的整数 ID 控件，则值为 NULL。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

返回的指针通常转换为*nID*标识的控件类型。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]

## <a name="cwndgetdlgitemint"></a><a name="getdlgitemint"></a>Cwnd：：GetDlgItemint

检索*nID*标识的控件的文本。

```
UINT GetDlgItemInt(
    int nID,
    BOOL* lpTrans = NULL,
    BOOL bSigned = TRUE) const;
```

### <a name="parameters"></a>参数

*nID*<br/>
指定要转换的对话框控件的整数标识符。

*lpTrans*<br/>
指向要接收翻译标志的布尔变量。

*b签名*<br/>
指定是否对要检索的值进行签名。

### <a name="return-value"></a>返回值

指定对话框项文本的已翻译值。 由于 0 是有效的返回值，因此必须使用*lpTrans*来检测错误。 如果需要签名的返回值，则将其转换为**int**类型。

如果翻译的数字大于INT_MAX（对于签名号码）或UINT_MAX（对于未签名的），则函数返回 0。

当发生错误（如遇到非数字字符并超过上述最大值）时，`GetDlgItemInt`将 0 复制到*lpTrans*指向的位置。 如果没有错误 *，lpTrans*将收到非零值。 如果*lpTrans*为`GetDlgItemInt`NULL，则不警告错误。

### <a name="remarks"></a>备注

它通过剥离文本开头的任何额外空格并转换十进制数字，将给定对话框中指定控件的文本转换为整数值。 当它到达文本末尾或遇到任何非数字字符时，它将停止翻译。

如果*bSign*为`GetDlgItemInt`TRUE，则检查文本开头的减号 （-），并将文本转换为签名编号。 否则，它将创建一个未签名的值。

它将[WM_GETTEXT](/windows/win32/winmsg/wm-gettext)消息发送到控件。

## <a name="cwndgetdlgitemtext"></a><a name="getdlgitemtext"></a>CWnd：：GetDlgItemText

调用此成员函数以检索与对话框中控件关联的标题或文本。

```
int GetDlgItemText(
    int nID,
    LPTSTR lpStr,
    int nMaxCount) const;

int GetDlgItemText(
    int nID,
    CString& rString) const;
```

### <a name="parameters"></a>参数

*nID*<br/>
指定要检索其标题的控件的整数标识符。

*lpStr*<br/>
指向缓冲区以接收控件的标题或文本。

*nMaxCount*<br/>
指定要复制到*lpStr*的字符串的最大长度（以字符形式）。 如果字符串长于*nMaxCount，* 则将其截断。

*rString*<br/>
对[CString](../../atl-mfc-shared/reference/cstringt-class.md)的引用。

### <a name="return-value"></a>返回值

指定复制到缓冲区的实际字符数，不包括终止空字符。 如果未复制任何文本，则该值为 0。

### <a name="remarks"></a>备注

成员`GetDlgItemText`函数将文本复制到*lpStr*指向的位置，并返回它复制的字节数的计数。

## <a name="cwndgetdsccursor"></a><a name="getdsccursor"></a>CWnd：：获取Sccursor

调用此成员函数以检索数据源控件的 DataSource、用户名、密码和 SQL 属性定义的指向基础游标的指针。

```
IUnknown* GetDSCCursor();
```

### <a name="return-value"></a>返回值

指向由数据源控件定义的游标的指针。 MFC 负责调用`AddRef`指针。

### <a name="remarks"></a>备注

使用返回的指针设置复杂数据绑定控件（如数据绑定网格控件）的 ICursor 属性。 数据源控件不会变为活动状态，直到第一个绑定控件请求其游标。 这可以通过 MFC 绑定管理器的`GetDSCCursor`调用或隐式方式发生。 在这两种情况下，都可以通过调用`GetDSCCursor`返回`Release`的指针到`IUnknown`，强制数据源控件变为活动状态。 激活将导致数据源控件尝试连接到基础数据源。 返回的指针可能在以下上下文中使用：

### <a name="example"></a>示例

[!code-cpp[NVC_MFC_AxDataBinding#5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]

## <a name="cwndgetdynamiclayout"></a><a name="getdynamiclayout"></a>CWnd：：获取动态布局

检索指向动态布局管理器对象的指针。

```
CMFCDynamicLayout* GetDynamicLayout();
```

### <a name="return-value"></a>返回值

动态布局管理器对象的指针，如果未启用动态布局，则为 NULL。

### <a name="remarks"></a>备注

窗口对象拥有并管理返回的指针的生存期，因此它只应该用于访问对象；不要删除指针或永久存储指针。

## <a name="cwndgetexstyle"></a><a name="getexstyle"></a>CWnd：：获取样式

返回窗口的扩展样式。

```
DWORD GetExStyle() const;
```

### <a name="return-value"></a>返回值

窗口的扩展样式。 有关 MFC 中使用的扩展窗口样式的详细信息，请参阅[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

## <a name="cwndgetfocus"></a><a name="getfocus"></a>CWnd：获取焦点

检索指向`CWnd`当前具有输入焦点的的指针。

```
static CWnd* PASCAL GetFocus();
```

### <a name="return-value"></a>返回值

指向具有当前焦点的窗口的指针，如果没有焦点窗口，则指向 NULL。

该指针可能是暂时的，不应存储起来供将来使用。

## <a name="cwndgetfont"></a><a name="getfont"></a>CWnd：：获取字体

将WM_GETFONT消息发送到窗口以检索当前字体。

```
CFont* GetFont() const;
```

### <a name="return-value"></a>返回值

指向附加到窗口的当前字体的[CFont](../../mfc/reference/cfont-class.md)对象的指针。

### <a name="remarks"></a>备注

除非窗口处理WM_GETFONT消息，否则此方法无效。 许多 MFC 类从`CWnd`处理此消息派生，因为它们附加到预定义的窗口类，其中包括WM_GETFONT消息的消息处理程序。 要使用此方法，派生自`CWnd`的类必须为WM_GETFONT消息定义方法处理程序。

## <a name="cwndgetforegroundwindow"></a><a name="getforegroundwindow"></a>CWnd：：获取前景窗口

返回指向前景窗口（用户当前正在使用的窗口）的指针。

```
static CWnd* PASCAL GetForegroundWindow();
```

### <a name="return-value"></a>返回值

指向前景窗口的指针。 这可能是一个临时`CWnd`对象。

### <a name="remarks"></a>备注

前景窗口仅适用于顶级窗口（框架窗口或对话框）。

## <a name="cwndgeticon"></a><a name="geticon"></a>CWnd：：GetIcon

调用此成员函数，使句柄到大 （32x32） 或句柄到一个小 （16x16） 图标， 如*bBigIcon*所示.

```
HICON GetIcon(BOOL bBigIcon) const;
```

### <a name="parameters"></a>参数

*bBigIcon*<br/>
如果为 TRUE，则指定 32 像素 x 32 像素图标;如果 FALSE，则指定 16 像素 x 16 像素图标。

### <a name="return-value"></a>返回值

图标的图柄。 如果不成功，则返回 NULL。

## <a name="cwndgetlastactivepopup"></a><a name="getlastactivepopup"></a>CWnd：：获取最后活动弹出

确定最近处于活动状态的由 `CWnd` 拥有的弹出窗口。

```
CWnd* GetLastActivePopup() const;
```

### <a name="return-value"></a>返回值

标识最近处于活动状态的弹出窗口。 如果满足以下任何条件，返回值将是窗口本身：

- 窗口本身最近处于活动状态。

- 该窗口不拥有任何弹出窗口。

- 该窗口不是顶级窗口，或由另一个窗口拥有。

该指针可能是暂时的，不应存储起来供将来使用。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：查找窗口](#findwindow)。

## <a name="cwndgetlayeredwindowattributes"></a><a name="getlayeredwindowattributes"></a>CWnd：：获取分层窗口属性

检索分层窗口的不透明度和透明度颜色键。

```
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags) const;
```

### <a name="parameters"></a>参数

*pcrKey*<br/>
指向 COLORREF 值的指针，该值接收在组成分层窗口时要使用的透明度颜色键。 此颜色的窗口绘制的所有像素都将是透明的。 如果不需要参数，这可以为 NULL。

*pb阿尔法*<br/>
指向接收用于描述分层窗口的不向性的 Alpha 值的 BYTE 的指针。 当*pbAlpha*引用的变量为 0 时，窗口是完全透明的。 当*pbAlpha*引用的变量为 255 时，窗口是不透明的。 如果不需要参数，这可以为 NULL。

*pdwFlags*<br/>
指向接收分层标志的 DWORD 的指针。 如果不需要参数，这可以为 NULL。 有关可能值的完整列表，请参阅[获取分层窗口属性](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[GetLayeredWindows 属性](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)的功能，如 Windows SDK 中所述。

## <a name="cwndgetmenu"></a><a name="getmenu"></a>CWnd：：获取菜单

检索指向此窗口的菜单的指针。

```
CMenu* GetMenu() const;
```

### <a name="return-value"></a>返回值

标识菜单。 如果没有`CWnd`菜单，则该值为 NULL。 如果是`CWnd`子窗口，则返回值未定义。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

此功能不应用于子窗口，因为它们没有菜单。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]

## <a name="cwndgetmenubarinfo"></a><a name="getmenubarinfo"></a>CWnd：：获取菜单栏信息

检索有关指定菜单栏的信息。

```
BOOL GetMenuBarInfo(
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi) const;
```

### <a name="parameters"></a>参数

*idObject*<br/>
指定菜单对象。 有关可能值的列表，请参阅[GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)。

*idItem*<br/>
指定要为其检索信息的项。 如果此参数为零，则函数将检索有关菜单本身的信息。 如果此参数为 1，则函数将检索有关菜单上第一项的信息，等等。

*pmbi*<br/>
指向接收信息的[MENUBARINFO](/windows/win32/api/winuser/ns-winuser-menubarinfo)结构的指针。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)的功能，如 Windows SDK 中所述。

## <a name="cwndgetnextdlggroupitem"></a><a name="getnextdlggroupitem"></a>CWnd：：获取NextDlg集团项目

在对话框中的控件组中搜索上一个或下一个控件。

```
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;
```

### <a name="parameters"></a>参数

*pWndCtl*<br/>
标识要用作搜索起点的控件。

*b 上一个*<br/>
指定函数在对话框中搜索控件组的方式。 如果为 TRUE，则函数将搜索组中的上一个控件;如果为 TRUE，则函数将搜索组中的上一个控件。如果 FALSE，它将搜索组中的下一个控件。

*pCurSiteOrwnd*<br/>
标识`COleControlSiteOrWnd`控件。 有关 的详细信息`COleControlSiteOrWnd`，请参阅**备注**。

### <a name="return-value"></a>返回值

如果成员函数成功，则指向组中的上一个或下一个控件。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

控件组从使用[WS_GROUP](styles-used-by-mfc.md#window-styles)样式创建的控件开始，最后以未使用WS_GROUP样式创建的最后一个控件结束。

默认情况下，`GetNextDlgGroupItem`成员函数返回指向组中的下一个控件的指针。 如果*pWndCtl*标识组中的第一个控件，bLast 为`GetNextDlgGroupItem`TRUE，则返回指向组中最后一个控件的指针。 *bPrevious*

> [!NOTE]
> 由于 MFC 支持无窗口 ActiveX 控件、标准 ActiveX 控件和窗口，因此仅引用 HWND 的控件已不足够。 该`COleControlSiteOrWnd`对象包括将对象标识为窗口 ActiveX 控件、无窗口 ActiveX 控件或窗口的信息，如下所示：

|控件或窗口类型|识别信息|
|----------------------------|-----------------------------|
|窗口激活 X 控件|包含 HWND 并将[COleControlSite](../../mfc/reference/colecontrolsite-class.md)对象与其关联。 `COleControlSiteOrWnd`的成员`m_hWnd`设置为控件的 HWND，`m_pSite`并且成员指向控件的`COleControlSite`。|
|无窗动 X 控件|不包含 HWND。 指向`m_pSite`控件的`COleControlSiteOrWnd``COleControlSite`的 点的成员，`m_hWnd`并且成员为 NULL。|
|标准窗口|仅包含 HWND。 的成员`m_hWnd``COleControlSiteOrWnd`设置为窗口的 HWND，`m_pSite`并且该成员为 NULL。|

## <a name="cwndgetnextdlgtabitem"></a><a name="getnextdlgtabitem"></a>CWnd：：获取NextDlgTab项目

检索指向使用[WS_TABSTOP](styles-used-by-mfc.md#window-styles)样式创建并在指定控件之前或遵循的第一个控件的指针。

```
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,
    BOOL bPrevious) const;
```

### <a name="parameters"></a>参数

*pWndCtl*<br/>
标识要用作搜索起点的控件。

*pCurSiteOrwnd*<br/>
标识`COleControlSiteOrWnd`控件。 有关 的详细信息`COleControlSiteOrWnd`，请参阅[CWnd：：GetNextDlgGroupItem](#getnextdlggroupitem)。

*b 上一个*<br/>
指定函数如何搜索对话框。 如果为 TRUE，则函数将在对话框中搜索上一个控件;如果为 TRUE，则函数将搜索该控件。如果 FALSE，它将搜索下一个控件。

### <a name="return-value"></a>返回值

如果成员函数成功，则指向具有WS_TABSTOP样式的上一个或下一个控件的指针。

返回的指针可能是临时的，不应存储以供以后使用。

有关 的详细信息`COleControlSiteOrWnd`，请参阅[CWnd：：GetNextDlgGroupItem](#getnextdlggroupitem)。

## <a name="cwndgetnextwindow"></a><a name="getnextwindow"></a>CWnd：：获取下一个窗口

搜索窗口管理器列表中的下一个（或上一个）窗口。

```
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
```

### <a name="parameters"></a>参数

*nFlag*<br/>
指定函数是返回指向下一个窗口或上一个窗口的指针。 它可以是GW_HWNDNEXT，它返回窗口管理器列表中`CWnd`的对象后面的窗口，也可以是GW_HWNDPREV，它返回窗口管理器列表中的前一个窗口。

### <a name="return-value"></a>返回值

如果成员函数成功，则标识窗口管理器列表中的下一个（或上一个）窗口。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

窗口管理器列表包含所有顶级窗口、其关联的子窗口以及任何子窗口的子窗口的条目。

如果`CWnd`是顶级窗口，则函数将搜索下一个（或上一个）顶级窗口;如果是顶级窗口，则函数将搜索下一个（或上一个）顶级窗口。如果是`CWnd`子窗口，则函数将搜索下一个（或上一个）子窗口。

## <a name="cwndgetolecontrolsite"></a><a name="getolecontrolsite"></a>CWnd：：获取 Ole 控制网站

检索指定 ActiveX 控件的自定义站点。

```
COleControlSite* GetOleControlSite(UINT idControl) const;
```

### <a name="parameters"></a>参数

*idControl*<br/>
ActiveX 控件的 ID。

## <a name="cwndgetopenclipboardwindow"></a><a name="getopenclipboardwindow"></a>CWnd：：获取打开的剪贴板窗口

检索当前打开剪贴板的窗口的句柄。

```
static CWnd* PASCAL GetOpenClipboardWindow();
```

### <a name="return-value"></a>返回值

如果函数成功，当前打开剪贴板的窗口的句柄;如果函数成功，则窗口的句柄。否则 NULL。

## <a name="cwndgetowner"></a><a name="getowner"></a>CWnd：：获取所有者

检索指向窗口所有者的指针。

```
CWnd* GetOwner() const;
```

### <a name="return-value"></a>返回值

一个指向 `CWnd` 对象的指针。

### <a name="remarks"></a>备注

如果窗口没有所有者，则默认情况下将返回指向父窗口对象的指针。 请注意，所有者和拥有的关系在几个重要方面与父子关系不同。 例如，具有父窗口的窗口限制在其父窗口的工作区中。 拥有的窗口可以在桌面上的任何位置绘制。

该函数的所有权概念不同于[GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的所有权概念。

## <a name="cwndgetparent"></a><a name="getparent"></a>CWnd：：获取家长

调用此函数以获取指向子窗口的父窗口（如果有）的指针。

```
CWnd* GetParent() const;
```

### <a name="return-value"></a>返回值

请参阅 Windows SDK 中的["获取父级"](/windows/win32/api/winuser/nf-winuser-getparent)中的返回值部分。

### <a name="remarks"></a>备注

函数`GetParent`返回指向直接父级的指针（如果存在）。 相反[，GetParentOwner](#getparentowner)函数返回指向不是子窗口（没有WS_CHILD样式）的最直接的父窗口或所有者窗口的指针。 如果子窗口中有一个子窗口`GetParent`，并`GetParentOwner`返回不同的结果。

## <a name="cwndgetparentframe"></a><a name="getparentframe"></a>CWnd：：获取父系框架

调用此成员函数以检索父帧窗口。

```
CFrameWnd* GetParentFrame() const;
```

### <a name="return-value"></a>返回值

指向帧窗口的指针（如果成功）;如果成功，则指向框架窗口的指针。否则 NULL。

### <a name="remarks"></a>备注

成员函数向上搜索父链，直到找到[CFrameWnd（](../../mfc/reference/cframewnd-class.md)或派生类）对象。

## <a name="cwndgetparentowner"></a><a name="getparentowner"></a>CWnd：：获取家长所有者

调用此成员函数以获取指向子窗口的父窗口或所有者窗口的指针。

```
CWnd* GetParentOwner() const;
```

### <a name="return-value"></a>返回值

一个指向 `CWnd` 对象的指针。 如果 `CWnd` 对象未附加到该句柄，则会创建并附加一个临时 `CWnd` 对象。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

`GetParentOwner`返回指向不是子窗口的最直接的父窗口或所有者窗口的指针（没有WS_CHILD样式）。 当前所有者窗口可以使用[SetOwner](#setowner)进行设置。 默认情况下，窗口的父级是其所有者。

相反[，GetParent](#getparent)函数返回指向正父级的指针，无论该指针是否是子窗口。 如果子窗口中有一个子窗口`GetParent`，并`GetParentOwner`返回不同的结果。

## <a name="cwndgetproperty"></a><a name="getproperty"></a>CWnd：获取财产

调用此成员函数获取*dwDispID*指定的 ActiveX 控件属性。

```
void GetProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    void* pvProp)const;
```

### <a name="parameters"></a>参数

*dwDispID*<br/>
标识要检索的属性。

*vtProp*<br/>
指定要检索的属性的类型。 有关可能的值，请参阅备注部分 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。

*pvProp*<br/>
将接收属性值的变量的地址。 它必须匹配*vtProp*指定的类型。

### <a name="remarks"></a>备注

`GetProperty`通过*pvProp*返回值。

> [!NOTE]
> 此函数应仅在表示 ActiveX`CWnd`控件的对象上调用。

有关将此成员函数与 ActiveX 控制容器一起使用的详细信息，请参阅文章[ActiveX 控件容器：在 ActiveX 控件容器中编程 ActiveX 控件](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndgetrendertarget"></a><a name="getrendertarget"></a>CWnd：：获取渲染目标

获取与此窗口相关联的呈现目标。

```
CHwndRenderTarget* GetRenderTarget();
```

### <a name="return-value"></a>返回值

指向渲染目标或 NULL 的指针。

## <a name="cwndgetsafehwnd"></a><a name="getsafehwnd"></a>CWnd：：获取安全Hwnd

如果`m_hWnd`**此**指针为 NULL，则返回 或 NULL。

```
HWND GetSafeHwnd() const;
```

### <a name="return-value"></a>返回值

返回窗口的窗口句柄。 如果`CWnd`未附加到窗口或将其与 NULL 指针一起使用，则返回`CWnd`NULL。

### <a name="example"></a>示例

  请参阅[CWnd：：子类窗口](#subclasswindow)的示例。

## <a name="cwndgetsafeowner"></a><a name="getsafeowner"></a>CWnd：：获取安全所有者

调用此成员函数以检索应用于对话框或其他模式窗口的所有者窗口。

```
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,
    HWND* pWndTop = NULL);
```

### <a name="parameters"></a>参数

*p 父级*<br/>
指向父`CWnd`窗口的指针。 可以为 NULL。

*pWndTop*<br/>
指向当前位于顶部的窗口的指针。 可以为 NULL。

### <a name="return-value"></a>返回值

指向给定窗口的安全所有者的指针。

### <a name="remarks"></a>备注

安全所有者是*pParent*的第一个非子父窗口。 如果*pParent*为 NULL，则线程的主窗口（通过[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)检索）用于查找所有者。

> [!NOTE]
> 框架本身使用此函数来确定对话框和属性表的正确所有者窗口，其中未指定所有者。

## <a name="cwndgetscrollbarctrl"></a><a name="getscrollbarctrl"></a>CWnd：：获取ScrollBarCtrl

调用此成员函数以获取指向指定同级滚动条或拆分器窗口的指针。

```
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定滚动条的类型。 参数可以采用以下值之一：

- SB_HORZ检索水平滚动条的位置。

- SB_VERT检索垂直滚动条的位置。

### <a name="return-value"></a>返回值

同级滚动条控件，或 NULL（如果没有）。

### <a name="remarks"></a>备注

此成员函数不会在创建窗口期间设置WS_HSCROLL或WS_VSCROLL位时创建的滚动条上工作。 此`CWnd`函数的实现仅返回 NULL。 派生类，如`CView`，实现描述的功能。

## <a name="cwndgetscrollbarinfo"></a><a name="getscrollbarinfo"></a>CWnd：：获取ScrollbarInfo

检索有关指定滚动条的信息。

```
BOOL GetScrollBarInfo(
    LONG idObject,
    PSCROLLBARINFO psbi) const;
```

### <a name="parameters"></a>参数

*idObject*<br/>
指定菜单对象。 有关可能值的列表，请参阅[GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)。

*psbi*<br/>
指向接收信息的[SCROLLBARINFO](/windows/win32/api/winuser/ns-winuser-scrollbarinfo)结构的指针。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)的功能，如 Windows SDK 中所述。

## <a name="cwndgetscrollinfo"></a><a name="getscrollinfo"></a>CWnd：：获取Scrollinfo

调用此成员函数以检索`SCROLLINFO`结构维护的关于滚动条的信息。

```
BOOL GetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    UINT nMask = SIF_ALL);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定滚动条是控件还是窗口的非工作区的一部分。 如果它是非工作区的一部分 *，nBar*还会指示滚动条是水平、垂直还是两者兼而有之。 它必须是以下项之一：

- SB_CTL检索滚动条控件的参数。 数据`m_hWnd`成员必须是滚动条控件的句柄。

- SB_HORZ检索窗口的标准水平滚动条的参数。

- SB_VERT检索窗口的标准垂直滚动条的参数。

*lpScrollInfo*<br/>
指向[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)结构的指针。 有关此结构的详细信息，请参阅 Windows SDK。

*nMask*<br/>
指定要检索的滚动条参数。 默认值指定SIF_PAGE、SIF_POS、SIF_TRACKPOS和SIF_RANGE的组合。 有关`SCROLLINFO` *nMask*值的详细信息，请参阅。

### <a name="return-value"></a>返回值

如果消息检索了任何值，则返回为 TRUE。 否则，它是 FALSE。

### <a name="remarks"></a>备注

`GetScrollInfo`使应用程序能够使用 32 位滚动位置。

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)结构包含有关滚动条的信息，包括最小和最大滚动位置、页面大小和滚动框（拇指）的位置。 有关更改`SCROLLINFO`结构默认值的详细信息，请参阅 Windows SDK 中的结构主题。

指示滚动条位置的 MFC Windows 消息处理程序[，CWnd：onHScroll](#onhscroll)和[CWnd：：onVScroll，](#onvscroll)仅提供 16 位位置数据。 `GetScrollInfo`并提供`SetScrollInfo`32 位滚动条位置数据。 因此，应用程序可以在处理或`GetScrollInfo``CWnd::OnHScroll``CWnd::OnVScroll`获取 32 位滚动条位置数据时调用。

## <a name="cwndgetscrolllimit"></a><a name="getscrolllimit"></a>CWnd：：获取滚动限制

调用此成员函数以检索滚动条的最大滚动位置。

```
int GetScrollLimit(int nBar);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定滚动条的类型。 参数可以采用以下值之一：

- SB_HORZ检索水平滚动条的滚动限制。

- SB_VERT检索垂直滚动条的滚动限制。

### <a name="return-value"></a>返回值

指定滚动条的最大位置（如果成功）;否则 0。

## <a name="cwndgetscrollpos"></a><a name="getscrollpos"></a>CWnd：：获取ScrollPos

检索滚动条滚动框的当前位置。

```
int GetScrollPos(int nBar) const;
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定要检查的滚动条。 参数可以采用以下值之一：

- SB_HORZ检索水平滚动条的位置。

- SB_VERT检索垂直滚动条的位置。

### <a name="return-value"></a>返回值

如果成功，在滚动条中指定滚动框的当前位置;否则 0。

### <a name="remarks"></a>备注

当前位置是一个相对值，取决于当前滚动范围。 例如，如果滚动范围为 50 到 100，并且滚动框位于条形图的中间，则当前位置为 75。

## <a name="cwndgetscrollrange"></a><a name="getscrollrange"></a>CWnd：：获取滚动

将给定滚动条的当前最小和最大滚动条位置复制到*lpMinPos*和*lpMaxPos*指定的位置。

```
void GetScrollRange(
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos) const;
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定要检查的滚动条。 参数可以采用以下值之一：

- SB_HORZ检索水平滚动条的位置。

- SB_VERT检索垂直滚动条的位置。

*lpMinPos*<br/>
指向要接收最小位置的整数变量。

*lpMaxPos*<br/>
指向要接收最大位置的整数变量。

### <a name="remarks"></a>备注

如果没有`CWnd`滚动条，则`GetScrollRange`成员函数将 0 复制到*lpMinPos*和*lpMaxPos*。

标准滚动条的默认范围为 0 到 100。 滚动条控件的默认范围为空（两个值均为 0）。

## <a name="cwndgetstyle"></a><a name="getstyle"></a>CWnd：：获取风格

返回当前窗口样式。

```
DWORD GetStyle() const;
```

### <a name="return-value"></a>返回值

窗口的风格。 有关 MFC 中使用的窗口样式的详细信息，请参阅[窗口样式](styles-used-by-mfc.md#window-styles)。

## <a name="cwndgetsystemmenu"></a><a name="getsystemmenu"></a>CWnd：：获取系统菜单

允许应用程序访问控件菜单以进行复制和修改。

```
CMenu* GetSystemMenu(BOOL bRevert) const;
```

### <a name="parameters"></a>参数

*b 还原*<br/>
指定要执行的操作。 如果*bRevert*是`GetSystemMenu`FALSE，则将句柄返回到当前正在使用的"控制"菜单的副本。 此副本最初与"控制"菜单相同，但可以修改。 如果*bRevert*为`GetSystemMenu`TRUE，则将"控制"菜单重置回默认状态。 上一个可能修改的"控制"菜单（如果有）将被销毁。 在这种情况下，返回值未定义。

### <a name="return-value"></a>返回值

如果*bRevert*是 FALSE，则标识"控制"菜单的副本。 如果*bRevert*为 TRUE，则返回值未定义。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

任何不用于`GetSystemMenu`制作自己的"控制"菜单副本的窗口都会收到标准"控件"菜单。

成员函数返回`GetSystemMenu`的指针可与[CMenu：：：附加菜单](../../mfc/reference/cmenu-class.md#appendmenu)[、CMenu：：插入菜单](../../mfc/reference/cmenu-class.md#insertmenu)或[CMenu：：修改菜单](../../mfc/reference/cmenu-class.md#modifymenu)功能一起使用。这些函数可用于更改"控制"菜单。

"控制"菜单最初包含使用各种 ID 值（如SC_CLOSE、SC_MOVE和SC_SIZE）标识的项。 "控制"菜单上的项目将[生成WM_SYSCOMMAND](#onsyscommand)消息。 所有预定义的控制菜单项的 ID 编号大于 0xF000。 如果应用程序将项添加到"控制"菜单，则应使用小于 F000 的 ID 号。

Windows 可能会自动使项目在标准控件菜单中不可用。 `CWnd`可以通过响应在显示任何菜单之前发送[的WM_INITMENU](#oninitmenu)消息来执行自己的选择或不可用。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]

## <a name="cwndgettitlebarinfo"></a><a name="gettitlebarinfo"></a>CWnd：：获取TitlebarInfo

检索有关指定标题栏的信息。

```
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;
```

### <a name="parameters"></a>参数

*Pti*<br/>
指向接收信息的[TITLEBARINFO](/windows/win32/api/winuser/ns-winuser-titlebarinfo)结构的指针。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetTitleBarInfo](/windows/win32/api/winuser/nf-winuser-gettitlebarinfo)的功能，如 Windows SDK 中所述。

## <a name="cwndgettoplevelframe"></a><a name="gettoplevelframe"></a>CWnd：：获取顶级框架

调用此成员函数以检索窗口的顶层框架窗口（如果有）。

```
CFrameWnd* GetTopLevelFrame() const;
```

### <a name="return-value"></a>返回值

标识窗口的顶层框架窗口。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

如果没有`CWnd`附加窗口，或者其顶级父级不是[CFrameWnd](../../mfc/reference/cframewnd-class.md)派生对象，则此函数将返回 NULL。

## <a name="cwndgettoplevelowner"></a><a name="gettoplevelowner"></a>CWnd：：获取顶级级别所有者

调用此成员函数以检索顶级窗口。

```
CWnd* GetTopLevelOwner() const;
```

### <a name="return-value"></a>返回值

标识顶层窗口。 返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

顶层窗口是桌面子窗口的窗口。 如果没有`CWnd`附加窗口，此函数将返回 NULL。

## <a name="cwndgettoplevelparent"></a><a name="gettoplevelparent"></a>CWnd：：获取顶级家长

调用此成员函数以检索窗口的顶级父级。

```
CWnd* GetTopLevelParent() const;
```

### <a name="return-value"></a>返回值

标识窗口的顶层父窗口。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

`GetTopLevelParent`类似于[获取顶级框架](#gettoplevelframe)和[获取顶级级别所有者](#gettoplevelowner);但是，它忽略设置为当前所有者窗口的值。

## <a name="cwndgettopwindow"></a><a name="gettopwindow"></a>CWnd：：获取顶窗

搜索属于`CWnd`的顶层子窗口。

```
CWnd* GetTopWindow() const;
```

### <a name="return-value"></a>返回值

标识子窗口`CWnd`链接列表中的顶级子窗口。 如果不存在子窗口，则值为 NULL。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

如果没有`CWnd`子级，此函数将返回 NULL。

## <a name="cwndgetupdaterect"></a><a name="getupdaterect"></a>CWnd：：获取更新

检索完全包含更新区域的最小矩形的坐标。

```
BOOL GetUpdateRect(
    LPRECT lpRect,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向对象`CRect`或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)，该结构用于接收包含更新区域的更新的客户端坐标。

将此参数设置为 NULL 以确定 更新区域是否存在`CWnd`于 。 如果*lpRect*为`GetUpdateRect`NULL，则成员函数将返回非零（如果存在更新区域），如果不存在，则返回 0。 这提供了一种确定WM_PAINT消息是否由无效区域产生的方法。 请勿在 Windows 版本 3.0 和更早版本中将此参数设置为 NULL。

*bErase*<br/>
指定是否应擦除更新区域中的背景。

### <a name="return-value"></a>返回值

指定更新区域的状态。 如果更新区域不为空，则该值为非零;否则 0。

如果*lpRect*参数设置为 NULL，则如果存在更新区域，则返回值为非零;否则 0。

### <a name="remarks"></a>备注

如果使用`CWnd`CS_OWNDC样式创建，并且映射模式未MM_TEXT，则`GetUpdateRect`成员函数在逻辑坐标中提供矩形。 否则，`GetUpdateRect`在客户端坐标中给出矩形。 如果没有更新区域，则`GetUpdateRect`将矩形设置为空（将所有坐标设置为 0）。

*bErase*参数指定是否应`GetUpdateRect`擦除更新区域的背景。 如果*bErase*为 TRUE，并且更新区域不为空，则删除背景。 要擦除背景，WM_ERASEBKGND`GetUpdateRect`消息。 [WM_ERASEBKGND](#onerasebkgnd)

[BeginPaint](#beginpaint)成员函数检索的更新矩形与`GetUpdateRect`成员函数检索的更新矩形相同。

成员`BeginPaint`函数会自动验证更新区域，因此在`GetUpdateRect`调用`BeginPaint`以检索空更新区域后立即对所做的任何调用都会进行。

## <a name="cwndgetupdatergn"></a><a name="getupdatergn"></a>CWnd：：获取更新Rgn

将更新区域检索到*pRgn*标识的区域。

```
int GetUpdateRgn(
    CRgn* pRgn,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识更新区域。

*bErase*<br/>
指定是否擦除背景，是否绘制子窗口的非工作区。 如果值为 FALSE，则不执行任何绘图。

### <a name="return-value"></a>返回值

指定指示结果区域类型的短整数标志。 该值可以采用以下任一值：

- 区域没有重叠边框。

- 区域具有重叠边框。

- NULL 区域为空。

- 未创建任何区域。

### <a name="remarks"></a>备注

此区域的坐标相对于左上角（客户端坐标）。

[BeginPaint](#beginpaint)成员函数会自动验证更新区域，因此在`GetUpdateRgn`调用`BeginPaint`以检索空更新区域后立即对所做的任何调用都会进行。

## <a name="cwndgetwindow"></a><a name="getwindow"></a>CWnd：：获取窗口

返回指向请求的窗口的指针，如果没有，则返回 NULL。

```
CWnd* GetWindow(UINT nCmd) const;
```

### <a name="parameters"></a>参数

*nCmd*<br/>
指定窗口与返回`CWnd`窗口之间的关系。 它可以采取以下值之一：

- GW_CHILD 标识第`CWnd`一个子窗口。

- GW_HWNDFIRST`CWnd`如果是子窗口，则返回第一个同级窗口。 否则，它将返回列表中的第一个顶级窗口。

- GW_HWNDLAST`CWnd`如果是子窗口，则返回最后一个同级窗口。 否则，它将返回列表中的最后一个顶级窗口。

- GW_HWNDNEXT 返回窗口管理器列表中的下一个窗口。

- GW_HWNDPREV 返回窗口管理器列表中的上一个窗口。

- GW_OWNER 标识`CWnd`所有者。

### <a name="return-value"></a>返回值

返回的指针可能是临时的，不应存储以供以后使用。

## <a name="cwndgetwindowcontexthelpid"></a><a name="getwindowcontexthelpid"></a>CWnd：：获取窗口上下文帮助Id

调用此成员函数以检索与窗口关联的帮助上下文标识符（如果有）。

```
DWORD GetWindowContextHelpId() const;
```

### <a name="return-value"></a>返回值

帮助上下文标识符。 如果窗口没有，则返回 0。

## <a name="cwndgetwindowedchildcount"></a><a name="getwindowedchildcount"></a>CWnd：：获取窗口儿童计数

调用此成员函数以检索关联的子窗口数。

```
long GetWindowedChildCount();
```

### <a name="return-value"></a>返回值

与`CWnd`对象关联的子窗口数。

## <a name="cwndgetwindowdc"></a><a name="getwindowdc"></a>CWnd：：获取窗口DC

检索整个窗口的显示上下文，包括标题栏、菜单和滚动条。

```
CDC* GetWindowDC();
```

### <a name="return-value"></a>返回值

如果函数成功，则标识给定窗口的显示上下文;否则 NULL。

返回的指针可能是临时的，不应存储以供以后使用。 [ReleaseDC](#releasedc)对于每次`GetWindowDC`成功调用 时，应调用释放 DC 一次。

### <a name="remarks"></a>备注

窗口显示上下文允许在 中的`CWnd`任意位置进行绘制，因为上下文的原点是工作区的`CWnd`左上角，而不是工作区。

每次检索上下文时，默认属性都会分配给显示上下文。 以前的属性将丢失。

`GetWindowDC`用于`CWnd`非客户区域内的特殊绘画效果。 不建议在任何窗口的非客户端区域进行绘画。

[GetSystemMetrics](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可用于检索非工作区各个部分的尺寸，如标题栏、菜单和滚动条。

绘制完成后，必须调用[ReleaseDC](#releasedc)成员函数以释放显示上下文。 由于同时打开的设备上下文数受到限制，未能释放显示上下文将严重影响应用程序请求的绘制。

## <a name="cwndgetwindowinfo"></a><a name="getwindowinfo"></a>CWnd：：获取窗口信息

检索有关窗口的信息。

```
BOOL GetWindowInfo(PWINDOWINFO pwi) const;
```

### <a name="parameters"></a>参数

*普基*<br/>
指向[WINDOWINFO](/windows/win32/api/winuser/ns-winuser-windowinfo)结构的指针。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetWindowInfo](/windows/win32/api/winuser/nf-winuser-getwindowinfo)的功能，如 Windows SDK 中所述。

## <a name="cwndgetwindowlesschildcount"></a><a name="getwindowlesschildcount"></a>CWnd：：获取无窗口儿童计数

检索关联的无窗口子窗口数。

```
long GetWindowlessChildCount();
```

### <a name="return-value"></a>返回值

与`CWnd`对象关联的无窗口子窗口数。

## <a name="cwndgetwindowplacement"></a><a name="getwindowplacement"></a>CWnd：：获取窗口放置

检索窗口的显示状态以及正常（已还原）、最小化和最大化位置。

```
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
```

### <a name="parameters"></a>参数

*普尔温德普尔*<br/>
指向接收显示`WINDOWPLACEMENT`状态和位置信息的结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此`flags`函数检索的[WINDOW 放置](/windows/win32/api/winuser/ns-winuser-windowplacement)结构的成员始终为 0。 如果`CWnd`最大化，则`showCmd`的成员`WINDOWPLACEMENT`SW_SHOWMAXIMIZED。 如果窗口最小化，则SW_SHOWMINIMIZED。 否则SW_SHOWNORMAL。

## <a name="cwndgetwindowrect"></a><a name="getwindowrect"></a>CWnd：：获取窗口Rect

将`CWnd`对象边界矩形的尺寸复制到*lpRect*指向的结构。

```
void GetWindowRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向将接收`CRect`左上角和右下角屏幕坐标的对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>备注

尺寸在屏幕坐标中相对于显示屏的左上角给出。 包括标题、边框和滚动条（如果存在）的尺寸。

## <a name="cwndgetwindowrgn"></a><a name="getwindowrgn"></a>CWnd：：获取窗口Rgn

调用此成员函数以获取窗口的窗口区域。

```
int GetWindowRgn(HRGN hRgn)const;
```

### <a name="parameters"></a>参数

*hRgn*<br/>
窗口区域的句柄。

### <a name="return-value"></a>返回值

返回值指定函数获取的区域的类型。 可以为下列值之一：

- NULL 区域为空。

- 区域是单个矩形。

- 区域是多个矩形。

- 错误 发生错误;该区域不受影响。

### <a name="remarks"></a>备注

窗口区域确定操作系统允许绘图的窗口内的区域。 操作系统不显示窗口区域外部的窗口的任何部分。

窗口窗口区域的坐标相对于窗口的左上角，而不是窗口的工作区。

要设置窗口的窗口区域，请调用[CWnd：：setWindowRgn](#setwindowrgn)。

## <a name="cwndgetwindowtext"></a><a name="getwindowtext"></a>CWnd：：获取窗口文本

将`CWnd`标题标题（如果有）复制到*lpszStringBuf*指向的缓冲区或目标字符串*rString*中。

```
int GetWindowText(
    LPTSTR lpszStringBuf,
    int nMaxCount) const;

void GetWindowText(
    CString& rString) const;
```

### <a name="parameters"></a>参数

*lpszStringBuf*<br/>
指向要接收窗口标题的复制字符串的缓冲区。

*nMaxCount*<br/>
指定要复制到缓冲区的最大字符数，包括终止空字符。 如果字符串长于*nMaxCount*中指定的字符数，则该字符串将被截断。

*rString*<br/>
接收窗口标题的复制字符串的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

### <a name="return-value"></a>返回值

指定复制字符串的长度（以字符形式表示），不包括终止空字符。 如果没有`CWnd`标题或标题为空，则为 0。

### <a name="remarks"></a>备注

如果`CWnd`对象是控件，则`GetWindowText`成员函数将复制控件中的文本，而不是复制标题。

此成员函数会导致[将WM_GETTEXT](/windows/win32/winmsg/wm-gettext)消息发送到`CWnd`对象。

### <a name="example"></a>示例

  请参阅[CWnd 示例：：设置窗口文本](#setwindowtext)。

## <a name="cwndgetwindowtextlength"></a><a name="getwindowtextlength"></a>CWnd：：获取窗口文本长度

返回`CWnd`对象标题标题的长度。

```
int GetWindowTextLength() const;
```

### <a name="return-value"></a>返回值

以字符指定文本长度，不包括任何空终止字符。 如果没有此类文本，则该值为 0。

### <a name="remarks"></a>备注

如果是`CWnd`控件，则`GetWindowTextLength`成员函数返回控件中文本的长度，而不是标题。

此成员函数会导致[将WM_GETTEXTLENGTH](/windows/win32/winmsg/wm-gettextlength)消息发送到对象`CWnd`。

### <a name="example"></a>示例

  请参阅[CWnd 示例：：设置窗口文本](#setwindowtext)。

## <a name="cwndhidecaret"></a><a name="hidecaret"></a>CWnd：：隐藏卡斯特

通过从显示屏幕中移除来隐藏插入符号。

```
void HideCaret();
```

### <a name="remarks"></a>备注

尽管 caret 不再可见，但可以使用[ShowCaret](#showcaret)成员函数再次显示它。 隐藏 caret 不会破坏其当前形状。

隐藏是累积的。 如果`HideCaret`连续调用了五次，`ShowCaret`则必须对成员函数调用五次，然后才能显示该 caret。

## <a name="cwndhilitemenuitem"></a><a name="hilitemenuitem"></a>CWnd：：HiliteMenu项目

从顶级（菜单栏）菜单项中突出显示或删除高光。

```
BOOL HiliteMenuItem(
    CMenu* pMenu,
    UINT nIDHiliteItem,
    UINT nHilite);
```

### <a name="parameters"></a>参数

*pMenu*<br/>
标识包含要突出显示的项目的顶级菜单。

*nIDHilite项目*<br/>
指定要突出显示的菜单项，具体取决于*nHilite*参数的值。

*nHilite*<br/>
指定菜单项是突出显示还是删除高光。 它可以是MF_HILITE或MF_UNHILITE与MF_BYCOMMAND或MF_BYPOSITION的组合。 可以使用位或运算符组合这些值。 这些值将具有以下含义：

- MF_BYCOMMAND将*nIDHiliteItem*解释为菜单项 ID（默认解释）。

- MF_BYPOSITION将*nIDHiliteItem*解释为菜单项的零偏移量。

- MF_HILITE突出显示该项目。 如果未给出此值，则从项中删除高光。

- MF_UNHILITE从项目中删除高光。

### <a name="return-value"></a>返回值

指定菜单项是否突出显示。 如果项目突出显示，则非零;否则 0。

### <a name="remarks"></a>备注

MF_HILITE和MF_UNHILITE标志只能用于此成员函数;因此，这些标志只能用于此成员函数。它们不能与[CMenu：：修改菜单](../../mfc/reference/cmenu-class.md#modifymenu)成员函数一起使用。

## <a name="cwndhtmlhelp"></a><a name="htmlhelp"></a>CWnd：：Html帮助

调用此成员函数以调用 HTMLHelp 应用程序。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>参数

*dwData*<br/>
指定其他数据。 使用的值取决于*nCmd*参数的值。

*nCmd*<br/>
指定请求的帮助的类型。 有关可能值的列表及其如何影响*dwData*参数，请参阅 Windows SDK 中的 HTML 帮助 API 参考中描述的*uCommand*参数。

### <a name="remarks"></a>备注

有关详细信息[，请参阅 CWinApp：html帮助](../../mfc/reference/cwinapp-class.md#htmlhelp)。

## <a name="cwndinitdynamiclayout"></a><a name="initdynamiclayout"></a>Cwnd：：动态布局

由框架调用以初始化窗口的动态布局。

```
void InitDynamicLayout();
```

### <a name="remarks"></a>备注

请勿直接调用此方法。

## <a name="cwndinvalidate"></a><a name="invalidate"></a>Cwnd：无效

使 的整个工作区无效`CWnd`。

```
void Invalidate(BOOL bErase = TRUE);
```

### <a name="parameters"></a>参数

*bErase*<br/>
指定是否擦除更新区域中的背景。

### <a name="remarks"></a>备注

当下一[个WM_PAINT](#onpaint)消息发生时，将标记工作区以进行绘制。 在[验证 Rect](#validaterect)或[ValidateRgn](#validatergn)成员函数发生WM_PAINT消息之前，还可以验证该区域。

*bErase*参数指定在处理更新区域时是否擦除更新区域中的背景。 如果 bErase 为 TRUE，则在调用 BeginPaint 成员函数时擦除背景;如果*bErase*为 TRUE，则在调用[BeginPaint](#beginpaint)成员函数时，将擦除背景。如果*bErase*是 FALSE，则背景保持不变。 如果*bErase*对于更新区域的任何部分都为 TRUE，则整个区域（而不仅仅是给定部分）的背景将被删除。

每当更新区域[WM_PAINT](#onpaint)不为空且`CWnd`该窗口的应用程序队列中没有其他消息时，Windows 都会发送WM_PAINT消息。

### <a name="example"></a>示例

  请参阅[CWnd 示例：：更新窗口](#updatewindow)。

## <a name="cwndinvalidaterect"></a><a name="invalidaterect"></a>Cwnd：：无效重

通过将该矩形添加到`CWnd`更新区域，使给定矩形中的工作区失效。

```
void InvalidateRect(
    LPCRECT lpRect,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含`CRect`要添加到更新区域的矩形（在客户端坐标中）的对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。 如果*lpRect*为 NULL，则整个工作区将添加到该区域。

*bErase*<br/>
指定是否擦除更新区域中的背景。

### <a name="remarks"></a>备注

在发送下一[WM_PAINT](#onpaint)消息时，将标记无效矩形以及更新区域中的所有其他区域进行绘制。 无效区域在更新区域中累积，直到在下一个WM_PAINT调用发生时处理该区域，或直到[验证雷Ct](#validaterect)或[ValidateRgn](#validatergn)成员函数验证该区域。

*bErase*参数指定在处理更新区域时是否擦除更新区域中的背景。 如果 bErase 为 TRUE，则在调用 BeginPaint 成员函数时擦除背景;如果*bErase*为 TRUE，则在调用[BeginPaint](#beginpaint)成员函数时，将擦除背景。如果*bErase*是 FALSE，则背景保持不变。 如果*bErase*对于更新区域的任何部分都为 TRUE，则整个区域的背景将被删除，而不仅仅是在给定部分中。

每当更新区域[WM_PAINT](#onpaint)不为空且`CWnd`该窗口的应用程序队列中没有其他消息时，Windows 都会发送WM_PAINT消息。

## <a name="cwndinvalidatergn"></a><a name="invalidatergn"></a>Cwnd：无效

通过将给定区域中的工作区添加到`CWnd`的当前更新区域，使该工作区无效。

```
void InvalidateRgn(
    CRgn* pRgn,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向[CRgn](../../mfc/reference/crgn-class.md)对象的指针，用于标识要添加到更新区域的区域。 假定该区域具有客户端坐标。 如果此参数为 NULL，则整个工作区将添加到更新区域。

*bErase*<br/>
指定是否擦除更新区域中的背景。

### <a name="remarks"></a>备注

在下次发送[WM_PAINT](#onpaint)消息时，将标记无效区域以及更新区域中的所有其他区域进行绘制。 无效区域在更新区域中累积，直到下次发送WM_PAINT消息时处理该区域，或直到[验证雷讯](#validaterect)或[验证 Rgn](#validatergn)成员函数验证该区域。

*bErase*参数指定在处理更新区域时是否擦除更新区域中的背景。 如果 bErase 为 TRUE，则在调用 BeginPaint 成员函数时擦除背景;如果*bErase*为 TRUE，则在调用[BeginPaint](#beginpaint)成员函数时，将擦除背景。如果*bErase*是 FALSE，则背景保持不变。 如果*bErase*对于更新区域的任何部分都为 TRUE，则整个区域（而不仅仅是给定部分）的背景将被删除。

每当更新区域[WM_PAINT](#onpaint)不为空且`CWnd`该窗口的应用程序队列中没有其他消息时，Windows 都会发送WM_PAINT消息。

给定区域以前必须由区域函数之一创建。

## <a name="cwndinvokehelper"></a><a name="invokehelper"></a>CWnd：：InvokeHelper

调用此成员函数以调用*dwDispID*指定的 ActiveX 控制方法或属性，该上下文中由*wFlags*指定。

```
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,
    WORD wFlags,
    VARTYPE vtRet,
    void* pvRet,
    const BYTE* pbParamInfo,
    ... );
```

### <a name="parameters"></a>参数

*dwDispID*<br/>
标识要调用的方法或属性。

*wFlags*<br/>
描述对`IDispatch::Invoke`的调用上下文的标志。

*弗特雷特*<br/>
指定返回值的类型。 有关可能的值，请参阅备注部分 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。

*pvRet*<br/>
将接收属性值或返回值的变量的地址。 它必须与*vtRet*指定的类型匹配。

*pbParamInfo*<br/>
指向 null 端接字节字符串的指针，指定*pbParamInfo*之后的参数类型。 有关可能的值，请参阅`COleDispatchDriver::InvokeHelper`的 备注部分。

*...*<br/>
参数的变量列表，在*pbParamInfo*中指定的类型。

### <a name="remarks"></a>备注

*pbParamInfo*参数指定传递给方法或属性的参数的类型。 参数的变量列表在语法声明中通过 *...* 进行表示。

此函数将参数转换为 VARIANTARG 值，然后在 ActiveX`IDispatch::Invoke`控件上调用方法。 如果 `IDispatch::Invoke` 调用失败，则此函数会引发异常。 如果返回`IDispatch::Invoke`的 SCODE（状态代码）DISP_E_EXCEPTION，则此函数将引发[一个 COleException](../../mfc/reference/coleexception-class.md)对象，否则将引发[COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。

> [!NOTE]
> 此函数应仅在表示 ActiveX`CWnd`控件的对象上调用。

有关将此成员函数与 ActiveX 控制容器一起使用的详细信息，请参阅文章[ActiveX 控件容器：在 ActiveX 控件容器中编程 ActiveX 控件](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndischild"></a><a name="ischild"></a>CWnd：：是儿童

指示*pWnd*指定的窗口是子窗口还是`CWnd`的其他直接后代。

```
BOOL IsChild(const CWnd* pWnd) const;
```

### <a name="parameters"></a>参数

*pwnd*<br/>
标识要测试的窗口。

### <a name="return-value"></a>返回值

指定函数的结果。 如果*pWnd*标识的窗口是`CWnd`中的子窗口，则该值为非零。否则 0。

### <a name="remarks"></a>备注

子窗口是`CWnd`对象位于父窗口链中的`CWnd`直接后代，该链从原始弹出窗口到子窗口。

## <a name="cwndisd2dsupportenabled"></a><a name="isd2dsupportenabled"></a>CWnd：isD2D支持启用

确定是否启用了 D2D 支持。

```
BOOL IsD2DSupportEnabled();
```

### <a name="return-value"></a>返回值

如果启用了该功能，则为 TRUE;如果启用了该功能，则为 TRUE。否则 FALSE。

## <a name="cwndisdialogmessage"></a><a name="isdialogmessage"></a>Cwnd：：对话消息

调用此成员函数以确定给定的消息是否用于无模式对话框;请调用此成员函数，以确定给定消息是否用于无模式对话框;如果是，此函数将处理消息。

```
BOOL IsDialogMessage(LPMSG lpMsg);
```

### <a name="parameters"></a>参数

*lpMsg*<br/>
指向包含要检查的消息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)结构。

### <a name="return-value"></a>返回值

指定成员函数是否已处理给定的消息。 如果已处理消息，则为非零;否则 0。 如果返回为 0，请致电基类的[CWnd：:P重新翻译消息](#pretranslatemessage)成员函数来处理消息。 在成员函数的重写`CWnd::PreTranslateMessage`中，代码如下所示：

[!code-cpp[NVC_MFCWindowing#100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]

### <a name="remarks"></a>备注

当`IsDialogMessage`函数处理消息时，它会检查键盘消息并将其转换为相应对话框的选择命令。 例如，TAB 键选择下一个控件或控件组，向下箭头键选择组中的下一个控件。

您不得将处理`IsDialogMessage`的消息传递给[翻译消息](/windows/win32/api/winuser/nf-winuser-translatemessage)或[调度消息](/windows/win32/api/winuser/nf-winuser-dispatchmessage)窗口功能，因为它已处理。

## <a name="cwndisdlgbuttonchecked"></a><a name="isdlgbuttonchecked"></a>CWnd：：IsDlgButtonChecked

确定按钮控件旁边是否有复选标记。

```
UINT IsDlgButtonChecked(int nIDButton) const;
```

### <a name="parameters"></a>参数

*nIDButton*<br/>
指定按钮控件的整数标识符。

### <a name="return-value"></a>返回值

如果选中给定控件，则为非零;如果未选中则为 0。 只能选中单选按钮和复选框。 对于三状态按钮，如果按钮不确定，则返回值可以是 2。 此成员函数返回 0 的按钮。

### <a name="remarks"></a>备注

如果按钮是三状态控件，则成员函数将确定该按钮是变暗、选中还是两者均未调暗。

## <a name="cwndisdynamiclayoutenabled"></a><a name="isdynamiclayoutenabled"></a>CWnd：：动态布局启用

确定是否在此窗口上启用动态布局。 如果启用动态布局，则子窗口的位置和大小可以在用户调整父窗口大小时进行更改。

```
BOOL IsDynamicLayoutEnabled() const;
```

### <a name="return-value"></a>返回值

如果启用了动态布局，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

## <a name="cwndisiconic"></a><a name="isiconic"></a>CWnd：：图标

指定是否`CWnd`最小化（图标）。

```
BOOL IsIconic() const;
```

### <a name="return-value"></a>返回值

如果最小化`CWnd`，则非零;否则 0。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndistouchwindow"></a><a name="istouchwindow"></a>CWnd：：是触摸窗口

指定 `CWnd` 是否具有触摸支持。

```
BOOL IsTouchWindow() const;
```

### <a name="return-value"></a>返回值

TRUE，`CWnd`如果有触摸支持;否则 FALSE。

### <a name="remarks"></a>备注

## <a name="cwndiswindowenabled"></a><a name="iswindowenabled"></a>CWnd：：已启用窗口

指定是否`CWnd`为鼠标和键盘输入启用。

```
BOOL IsWindowEnabled() const;
```

### <a name="return-value"></a>返回值

未归零`CWnd`（如果启用）;否则 0。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]

## <a name="cwndiswindowvisible"></a><a name="iswindowvisible"></a>CWnd：：视窗可见

确定给定窗口的可见性状态。

```
BOOL IsWindowVisible() const;
```

### <a name="return-value"></a>返回值

如果`CWnd`为不可见，则非零（设置[WS_VISIBLE](styles-used-by-mfc.md#window-styles)样式位，并且父窗口可见）。 由于返回值反映WS_VISIBLE样式位的状态，因此返回值可能是非零的，即使`CWnd`其他窗口完全模糊了返回值。

### <a name="remarks"></a>备注

窗口具有WS_VISIBLE样式位指示的可见性状态。 当使用对[ShowWindow](#showwindow)成员函数的调用设置此样式位时，将显示窗口，只要窗口设置了样式位，将显示窗口的后续图形。

如果窗口被其他窗口覆盖或由其父窗口剪切，则不会显示具有WS_VISIBLE样式的窗口的任何绘图。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]

## <a name="cwndiszoomed"></a><a name="iszoomed"></a>Cwnd：：放大缩小字体功能 放大缩小字体功能

确定是否已`CWnd`最大化。

```
BOOL IsZoomed() const;
```

### <a name="return-value"></a>返回值

如果最大化`CWnd`，则非零;否则 0。

## <a name="cwndkilltimer"></a><a name="killtimer"></a>CWnd：：基尔蒂默

从之前对`SetTimer`的调用中终止*nIDEvent*标识的计时器事件。

```
BOOL KillTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>参数

*nIDEvent*<br/>
传递给[SetTimer](#settimer)的计时器事件的值。

### <a name="return-value"></a>返回值

指定函数的结果。 如果事件已终止，则该值为非零。 如果成员函数找不到指定的`KillTimer`计时器事件，则为 0。

### <a name="remarks"></a>备注

与计时器关联的[挂起WM_TIMER](#ontimer)消息不会从消息队列中删除。

### <a name="example"></a>示例

  请参阅[CWnd：：SetTimer](#settimer)的示例。

## <a name="cwndloaddynamiclayoutresource"></a><a name="loaddynamiclayoutresource"></a>CWnd：：加载动态布局资源

由框架调用，以从资源文件加载动态布局信息。

```
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```

### <a name="parameters"></a>参数

*lpsz 资源名称*<br/>
包含此窗口所需的动态布局信息的资源名称。

### <a name="return-value"></a>返回值

如果函数运行成功，则为非零。 如果发生故障，则为 0。

### <a name="remarks"></a>备注

请勿直接调用此方法。

## <a name="cwndlockwindowupdate"></a><a name="lockwindowupdate"></a>CWnd：：锁窗口更新

禁用给定窗口中的绘图。

```
BOOL LockWindowUpdate();
```

### <a name="return-value"></a>返回值

如果函数运行成功，则为非零。 如果发生故障或函数已用于锁定另一个`LockWindowUpdate`窗口，则为 0。

### <a name="remarks"></a>备注

无法移动锁定的窗口。 一次只能锁定一个窗口。 要解锁锁定的窗口，`LockWindowUpdate`请调用[解锁窗口更新](#unlockwindowupdate)。

如果具有锁定窗口（或任何锁定的子窗口）的应用程序调用[GetDC、GetDCEx](/windows/win32/api/winuser/nf-winuser-getdc)[GetDCEx,](/windows/win32/api/winuser/nf-winuser-getdcex)或[BeginPaint](/windows/win32/api/winuser/nf-winuser-beginpaint) Windows 函数，则被调用的函数将返回其可见区域为空的设备上下文。 这将发生，直到应用程序通过调用`UnlockWindowUpdate`成员函数解锁窗口。

当窗口更新被锁定时，系统会跟踪与锁定窗口关联的设备上下文的任何绘图操作的边界矩形。 重新启用绘图时，此边界矩形在锁定的窗口及其子窗口中失效，以强制最终[WM_PAINT](/windows/win32/gdi/wm-paint)消息更新屏幕。 如果在窗口更新锁定时未发生绘图，则没有区域无效。

成员`LockWindowUpdate`函数不会使给定窗口不可见，也不会清除[WS_VISIBLE](styles-used-by-mfc.md#window-styles)样式位。

## <a name="cwndm_hwnd"></a><a name="m_hwnd"></a>CWnd：：m_hWnd

附加到此`CWnd`的 Windows 窗口的句柄。

```
HWND m_hWnd;
```

### <a name="remarks"></a>备注

数据`m_hWnd`成员是 HWND 类型的公共变量。

## <a name="cwndmapwindowpoints"></a><a name="mapwindowpoints"></a>CWnd：：地图窗口点

将一组点从 `CWnd` 的坐标空间转换（映射）到另一个窗口的坐标空间。

```
void MapWindowPoints(
    CWnd* pwndTo,
    LPRECT lpRect) const;

void MapWindowPoints(
    CWnd* pwndTo,
    LPPOINT lpPoint,
    UINT nCount) const;
```

### <a name="parameters"></a>参数

*普恩托*<br/>
标识将点转换为的窗口。 如果此参数为 NULL，则点将转换为屏幕坐标。

*lpRect*<br/>
指定要转换其点的矩形。 此功能的第一个版本仅适用于 Windows 3.1 及更高版本。

*lpPoint*<br/>
指向[POINT 结构](/windows/win32/api/windef/ns-windef-point)数组的指针，其中包含要转换的点集。

*nCount*<br/>
指定`POINT`*lpPoint*指向的数组中的结构数。

## <a name="cwndmessagebox"></a><a name="messagebox"></a>CWnd：：消息框

创建并显示包含应用程序提供的消息和标题的窗口，以及[消息框样式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)列表中所述的预定义图标和按钮的组合。

```
int MessageBox(
    LPCTSTR lpszText,
    LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK);
```

### <a name="parameters"></a>参数

*lpszText*<br/>
指向包含`CString`要显示的消息的对象或空端接字符串。

*lpszCaption*<br/>
指向要用于`CString`消息框标题的对象或空端接字符串。 如果*lpszCaption*为 NULL，则使用默认标题"错误"。

nType**<br/>
指定消息框的内容和行为。

### <a name="return-value"></a>返回值

此方法利用 Windows SDK 中定义的[MessageBox](/windows/win32/api/winuser/nf-winuser-messagebox)函数。 此方法返回调用此函数的结果。

### <a name="remarks"></a>备注

使用全局函数[AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox)而不是此成员函数在应用程序中实现消息框。

下面显示了可在消息框中使用的各种系统图标：

|||
|-|-|
|![停止&#40;x&#41;图标](../../mfc/reference/media/vc364f1.gif "停止&#40;x&#41;图标")|MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR|
|![帮助&#40;&#41;图标](../../mfc/reference/media/vc364f2.gif "帮助&#40;&#41;图标")|MB_ICONQUESTION|
|![重要 &#40;&#33;&#41; 图标](../../mfc/reference/media/vc364f3.gif "重要 &#40;&#33;&#41; 图标")|MB_ICONEXCLAMATION和MB_ICONWARNING|
|![信息&#40;i&#41;图标](../../mfc/reference/media/vc364f4.gif "信息&#40;i&#41;图标")|MB_ICONASTERISK和MB_ICONINFORMATION|

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]

## <a name="cwndmodifystyle"></a><a name="modifystyle"></a>CWnd：：修改样式

调用此成员函数以修改窗口的样式。

```
BOOL ModifyStyle(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>参数

*dwRemove*<br/>
指定要在样式修改期间删除的窗口样式。

*dwAdd*<br/>
指定要在样式修改期间添加的窗口样式。

*nFlags*<br/>
要传递给[SetWindowPos](#setwindowpos)的标记，如果`SetWindowPos`不应调用，则为零。 默认值为 0。 有关预设标志的列表，请参阅备注部分。

### <a name="return-value"></a>返回值

如果样式已成功修改，则非零;否则，0。

### <a name="remarks"></a>备注

可以使用位或（&#124;）运算符组合要添加或删除的样式。 有关可用窗口样式的信息，请参阅 Windows SDK 中的主题["窗口样式](/windows/win32/winmsg/window-styles)"和["创建窗口](/windows/win32/api/winuser/nf-winuser-createwindoww)"。

如果*nFlags*是非零`ModifyStyle`，请调用 Windows API 函数[SetWindowPos，](/windows/win32/api/winuser/nf-winuser-setwindowpos)并通过将*nFlags*与以下四个预设标志组合来重绘窗口：

- SWP_NOSIZE 保留当前大小。

- SWP_NOMOVE 保留当前位置。

- SWP_NOZORDER保留当前 Z 订单。

- SWP_NOACTIVATE不激活窗口。

要修改窗口的扩展样式，请参阅[修改样式Ex。](#modifystyleex)

> [!NOTE]
> 对于某些控件中的某些样式（例如，编辑控件中的ES_READONLY样式），`ModifyStyle`可能无法正确更改样式，因为控件可能需要执行特殊的内部处理。 在这些情况下，将显示一条相应的消息来更改样式（EM_SETREADONLY上述示例中）。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]

## <a name="cwndmodifystyleex"></a><a name="modifystyleex"></a>CWnd：：修改风格

调用此成员函数以修改窗口的扩展样式。

```
BOOL ModifyStyleEx(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>参数

*dwRemove*<br/>
指定在样式修改期间要删除的扩展样式。

*dwAdd*<br/>
指定样式修改期间要添加的扩展样式。

*nFlags*<br/>
要传递给[SetWindowPos](#setwindowpos)的标记，如果`SetWindowPos`不应调用，则为零。 默认值为 0。 有关预设标志的列表，请参阅备注部分。

### <a name="return-value"></a>返回值

如果样式已成功修改，则非零;否则，0。

### <a name="remarks"></a>备注

可以使用位或（&#124;）运算符组合要添加或删除的样式。 有关可用扩展样式的信息，请参阅本书中的["扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)"和 Windows SDK 中的["创建 WindowEx"](/windows/win32/api/winuser/nf-winuser-createwindowexw)主题

如果*nFlags*是非零`ModifyStyleEx`，请调用 Windows API 函数[SetWindowPos，](/windows/win32/api/winuser/nf-winuser-setwindowpos)并通过将*nFlags*与以下四个预设标志组合来重绘窗口：

- SWP_NOSIZE 保留当前大小。

- SWP_NOMOVE 保留当前位置。

- SWP_NOZORDER保留当前 Z 订单。

- SWP_NOACTIVATE不激活窗口。

要使用常规窗口样式修改窗口，请参阅[修改样式](#modifystyle)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]

## <a name="cwndmovewindow"></a><a name="movewindow"></a>CWnd：：移动窗口

更改位置和尺寸。

```
void MoveWindow(
    int x,
    int y,
    int nWidth,
    int nHeight,
    BOOL bRepaint = TRUE);

void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>参数

** x <br/>
指定 左侧的新位置`CWnd`。

*Y*<br/>
指定 顶部的新位置`CWnd`。

*n 宽度*<br/>
指定 的新`CWnd`宽度。

*nHeight*<br/>
指定 的新`CWnd`高度。

*bRepaint*<br/>
指定是否`CWnd`重新绘制。 如果为`CWnd`TRUE，则像往常一样在其[OnPaint](#onpaint)消息处理程序中接收[WM_PAINT](/windows/win32/gdi/wm-paint)消息。 如果此参数为 FALSE，则不进行任何重新绘制。 这适用于工作区、非工作区（包括标题和滚动条）以及因移动而显示的`CWnd`父窗口的任何部分。 当此参数为 FALSE 时，应用程序必须显式无效或重绘必须重绘`CWnd`的和父窗口的任何部分。

*lpRect*<br/>
指定新大小和位置的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>备注

对于顶级`CWnd`对象 *，x*和*y*参数相对于屏幕的左上角。 对于子`CWnd`对象，它们相对于父窗口工作区的左上角。

函数`MoveWindow`发送[WM_GETMINMAXINFO](#ongetminmaxinfo)消息。 处理此消息提供了`CWnd`修改最大和最小窗口的默认值的机会。 如果成员函数的`MoveWindow`参数超过这些值，则可以将值替换为WM_GETMINMAXINFO处理程序中的最小值或最大值。

### <a name="example"></a>示例

  请参阅[CWnd：：客户端屏幕](#clienttoscreen)的示例。

## <a name="cwndnotifywinevent"></a><a name="notifywinevent"></a>CWnd：：通知温事件

向系统发出信号，指出发生了预定义事件。 如果任何客户端应用程序已注册事件的挂钩函数，系统将调用客户端的挂钩函数。

```
void NotifyWinEvent(
    DWORD event,
    LONG idObjectType,
    LONG idObject);
```

### <a name="parameters"></a>参数

*event*<br/>
指定发生的事件。 此值必须是[事件常量](/windows/win32/WinAuto/event-constants)之一。

*标识对象类型*<br/>
标识生成事件的对象类型。 此值是预定义[对象标识符](/windows/win32/WinAuto/object-identifiers)或自定义对象 ID 值之一。

*idObject*<br/>
标识事件是由对象还是对象的子元素生成的。 如果此值CHILDID_SELF，则事件由对象本身生成。 如果不是，此值是生成事件的元素的子 ID。

### <a name="remarks"></a>备注

此成员函数模拟函数[NotifyWinEvent](/windows/win32/api/winuser/nf-winuser-notifywinevent)的功能，如 Windows SDK 中所述。

## <a name="cwndonactivate"></a><a name="onactivate"></a>Cwnd：：打开激活

当对象被激活或停用时，`CWnd`框架将调用此成员函数。

```
afx_msg void OnActivate(
    UINT nState,
    CWnd* pWndOther,
    BOOL bMinimized);
```

### <a name="parameters"></a>参数

*n州*<br/>
指定 是`CWnd`正在激活还是停用 。 可以为下列值之一：

- WA_INACTIVE 窗口正在停用。

- WA_ACTIVE窗口正在通过单击鼠标以外的方法激活（例如，通过使用键盘界面选择窗口）。

- WA_CLICKACTIVE鼠标单击激活窗口。

*pWnd其他*<br/>
指向`CWnd`正在激活或停用的指针。 指针可以是 NULL，并且可能是临时的。

*b 最小化*<br/>
指定正在激活或停用的`CWnd`最小化状态。 TRUE 值表示窗口最小化。

如果为 TRUE，则 正在激活 ; `CWnd`否则已停用。

### <a name="remarks"></a>备注

如果通过`CWnd`鼠标单击激活对象，它还将收到[OnMouseActivate](#onmouseactivate)成员函数调用。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonactivateapp"></a><a name="onactivateapp"></a>Cwnd：：在激活应用上

该框架将此成员函数调用要激活的任务的所有顶级窗口以及要停用的任务的所有顶级窗口。

```
afx_msg void OnActivateApp(
    BOOL bActive,
    DWORD dwThreadID);
```

### <a name="parameters"></a>参数

*b 活动*<br/>
指定 是`CWnd`正在激活还是停用 。 TRUE 表示`CWnd`正在激活 。 FALSE 表示`CWnd`正在停用 。

*dwThreadID*<br/>
指定线程 ID 的值。 如果*bActive*为 TRUE，dwThreadID 标识拥有已`CWnd`停用的线程。 *dwThreadID* 如果*bActive*是 FALSE，dwThreadID 标识拥有被`CWnd`激活的线程。 *dwThreadID*

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonambientproperty"></a><a name="onambientproperty"></a>Cwnd：：环境物业

框架调用此成员函数以获取包含 OLE 控件的窗口的环境属性值。

```
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,
    DISPID dispid,
    VARIANT* pvar);
```

### <a name="parameters"></a>参数

*pSite*<br/>
指向请求环境属性的控件的站点。

*不一部分*<br/>
请求的环境属性的调度 ID。

*普瓦尔*<br/>
指向调用方分配`VARIANT`结构的指针，通过该结构将返回环境属性的值。

### <a name="return-value"></a>返回值

如果环境属性受支持，则为 TRUE;如果没有，则进行伪造。

### <a name="remarks"></a>备注

重写此函数以更改 OLE 控件容器返回到其控件的默认环境属性值。 任何未由重写函数处理的环境属性请求都应转发到基类实现。

## <a name="cwndonappcommand"></a><a name="onappcommand"></a>Cwnd：：OnApp命令

当用户生成应用程序命令事件时，框架将调用此成员函数。 当用户单击应用程序命令按钮或键入应用程序命令键时，会发生此类事件。

```
afx_msg void OnAppCommand(
    CWnd* pWnd,
    UINT nCmd,
    UINT nDevice,
    UINT nKey);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pwnd*|[在]指向`CWnd`表示用户单击命令按钮或按下命令键的窗口的对象的指针。 此窗口可以是接收消息的窗口的子窗口。|
|*nCmd*|[在]指示应用程序命令。 有关可能值的列表，请参阅[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*参数的*cmd*部分下的命令。|
|*n设备*|[在]生成输入事件的输入设备。 有关可能值的列表，请参阅[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*参数的*uDevice*部分下的设备。|
|*n键*|[在]指示任何向下的虚拟键，如 CTRL 键或鼠标左键。 有关可能值的列表，请参阅[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*参数的*dwKeys*部分下的键。 有关详细信息，请参阅[有关鼠标输入](/windows/win32/inputdev/about-mouse-input)中的"消息参数"副标题。|

### <a name="remarks"></a>备注

此方法接收[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonaskcbformatname"></a><a name="onaskcbformatname"></a>Cwnd：：在AskCb格式名称

当剪贴板包含CF_OWNERDISPLAY格式的数据句柄（即剪贴板所有者将显示剪贴板内容时），框架将调用此成员函数。

```
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,
    LPTSTR lpszString);
```

### <a name="parameters"></a>参数

*nMaxCount*<br/>
指定要复制的最大字节数。

*lpszString*<br/>
指向要存储格式名称副本的缓冲区。

### <a name="remarks"></a>备注

剪贴板所有者应提供其格式的名称。

重写此成员函数，并将CF_OWNERDISPLAY格式的名称复制到指定的缓冲区中，不超过指定的最大字节数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncancelmode"></a><a name="oncancelmode"></a>Cwnd：：打开取消模式

框架调用此成员函数以通知`CWnd`取消任何内部模式。

```
afx_msg void OnCancelMode();
```

### <a name="remarks"></a>备注

如果`CWnd`对象具有焦点，则在显示`OnCancelMode`对话框或消息框时调用其成员函数。 这就有机会`CWnd`取消鼠标捕获等模式。

默认实现通过调用[发布捕获](/windows/win32/api/winuser/nf-winuser-releasecapture)Windows 功能进行响应。 重写派生类中的此成员函数以处理其他模式。

## <a name="cwndoncapturechanged"></a><a name="oncapturechanged"></a>Cwnd：：在捕获上

框架调用此成员函数以通知丢失鼠标捕获的窗口。

```
afx_msg void OnCaptureChanged(CWnd* pWnd);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
指向窗口的指针，以获得鼠标捕获

### <a name="remarks"></a>备注

窗口接收此消息，即使它调用[发布捕获](/windows/win32/api/winuser/nf-winuser-releasecapture)本身。 应用程序不应尝试设置鼠标捕获以响应此消息。 收到此消息时，窗口应在必要时重新绘制自身以反映新的鼠标捕获状态。

有关 Windows 功能的信息，`ReleaseCapture`请参阅 Windows SDK。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonchangecbchain"></a><a name="onchangecbchain"></a>Cwnd：：在转换Cb链

框架为剪贴板-查看器链中的每个窗口调用此成员函数，以通知其正在从链中删除窗口。

```
afx_msg void OnChangeCbChain(
    HWND hWndRemove,
    HWND hWndAfter);
```

### <a name="parameters"></a>参数

*hWndRemove*<br/>
指定从剪贴板查看器链中删除的窗口句柄。

*hWnd 后*<br/>
指定从剪贴板查看器链中删除的窗口后面的窗口句柄。

### <a name="remarks"></a>备注

接收`CWnd``OnChangeCbChain`呼叫的每个对象都应使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函数将[WM_CHANGECBCHAIN](/windows/win32/dataxchg/wm-changecbchain)消息发送到剪贴板查看器链中的下一个窗口（由 返回的`SetClipboardViewer`句柄）。 如果*hWndRemove*是链中的下一个窗口，则*hWnd 后指定的*窗口将成为下一个窗口，剪贴板消息将传递给它。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonchangeuistate"></a><a name="onchangeuistate"></a>Cwnd：：在改变状态

在应更改用户界面 (UI) 状态时调用。

```
afx_msg void OnChangeUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>参数

*nAction*<br/>
指定要执行的操作。 可以是以下值之一：

- UIS_CLEAR应隐藏 UI 状态元素（由*nUIElement*指定）。

- UIS_INITIALIZE 应基于最后一个输入事件更改 UI 状态元素（由*nUIElement*指定）。 有关详细信息，请参阅[WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate)的**备注**部分。

- UIS_SET UI 状态元素（由*nUIElement*指定）应可见。

*nUI元素*<br/>
指定受影响的 UI 状态元素或控件的样式。 可以是以下值之一：

- UISF_HIDEACCEL键盘加速器。

- UISF_HIDEFOCUS焦点指标。

- UISF_ACTIVE Windows XP：控件应以用于活动控件的样式绘制。

### <a name="remarks"></a>备注

此成员函数模拟[WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate)消息的功能，如 Windows SDK 中所述。

## <a name="cwndonchar"></a><a name="onchar"></a>Cwnd：：OnChar

当击键转换为非系统字符时，框架将调用此成员函数。

```
afx_msg void OnChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
包含键的字符代码值。

*恩雷普森特*<br/>
包含重复计数，当用户关闭键时重复击键的次数。

*nFlags*<br/>
包含扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|含义|
|-----------|-------------|
|0-15|指定重复计数。 该值是用户按住键而重复击键的次数。|
|16-23|指定扫描代码。 该值取决于原始设备制造商 （OEM）|
|24|指定该键是否是扩展键，例如显示在增强型 101 键或 102 键键盘上的右侧 ALT 和 CTRL 键。 如果值是扩展键，则值为 1;如果该值是扩展键，则该值为 1。否则，它是 0。|
|25-28|Windows 在内部使用。|
|29|指定上下文代码。 按下键时按住 ALT 键，则该值为 1;否则，该值为 0。|
|30|指定以前的键状态。 如果键在发送消息之前向下，则值为 1;如果键向上，则值为 0。|
|31|指定转换状态。 如果释放键，则值为 1;如果按下该键，则该值为 0。|

### <a name="remarks"></a>备注

此函数在[OnKeyUp](#onkeyup)成员函数之前和调用[OnKeyDown](#onkeydown)成员函数之前调用。 `OnChar`包含要按下或释放的键盘键的值。

由于按下的密钥和`OnChar`生成的调用之间不一定存在一对一的对应关系，因此*nFlags*中的信息通常对应用程序没有用处。 *nFlags*中的信息仅适用于对`OnKeyUp`成员函数或调用`OnKeyDown``OnChar`之前的成员函数的最新调用。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonchartoitem"></a><a name="onchartoitem"></a>Cwnd：：在查托项目

当具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)样式的列表框向其所有者发送[WM_CHARTOITEM](/windows/win32/Controls/wm-chartoitem)消息以响应[WM_CHAR](#onchar)消息时调用。

```
afx_msg int OnCharToItem(
    UINT nChar,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定用户按下的键的值。

*pListBox*<br/>
指定指向列表框的指针。 它可能是暂时的。

*nIndex*<br/>
指定当前位置。

### <a name="return-value"></a>返回值

框架调用此成员函数以指定应用程序为响应调用执行的操作。 返回值 -2 表示应用程序处理了选择项的所有方面，并且不希望列表框执行进一步操作。 返回值 -1 表示列表框应执行默认操作以响应击键。 返回值 0 或更高指定列表框中项的零基索引，并指示列表框应对给定项执行击键的默认操作。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonchildactivate"></a><a name="onchildactivate"></a>Cwnd：：在儿童激活

如果`CWnd`对象是多个文档接口 （MDI） 子窗口，`OnChildActivate`则当用户单击窗口的标题栏或窗口激活、移动或调整大小时，框架将调用该对象。

```
afx_msg void OnChildActivate();
```

## <a name="cwndonchildnotify"></a><a name="onchildnotify"></a>Cwnd：：在儿童通知

当此窗口的父窗口收到应用于此窗口的通知消息时，此成员函数将调用它。

```
virtual BOOL OnChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>参数

*消息*<br/>
发送到父窗口的 Windows 消息编号。

*wParam*<br/>
与消息关联的*wparam。*

*lParam*<br/>
与消息关联的*lparam。*

*pLResult*<br/>
指向要从父窗口过程返回的值的指针。 如果没有返回值，此指针将为 NULL。

### <a name="return-value"></a>返回值

如果此窗口负责处理发送到其父级的消息，则非零;否则 0。

### <a name="remarks"></a>备注

切勿直接调用此成员函数。

此成员函数的默认实现返回 0，这意味着父函数应处理消息。

重写此成员函数以扩展控件响应通知消息的方式。

## <a name="cwndonclipboardupdate"></a><a name="onclipboardupdate"></a>Cwnd：：在剪贴板更新

当剪贴板的内容发生更改时，框架将调用此成员函数。

```
afx_msg void OnClipboardUpdate();
```

## <a name="cwndonclose"></a><a name="onclose"></a>Cwnd：：关闭

框架将此成员函数称为`CWnd`或应用程序要终止的信号。

```
afx_msg void OnClose();
```

### <a name="remarks"></a>备注

默认实现调用`DestroyWindow`。

## <a name="cwndoncolorizationcolorchanged"></a><a name="oncolorizationcolorchanged"></a>Cwnd：：在颜色颜色改变

当非工作区的呈现策略发生更改时，框架将调用此成员。

```
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,
    BOOL bOpacity);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*dwColor 颜色*|[在]指定新的着色颜色。<br /><br /> 颜色格式是窗体 0xAARRGGBB 的十六进制数字，其中四个组件的范围从 0x00 到 0xFF。 AA 分量为 alpha 值，RR 为红色，GG 为绿色，BB 为蓝色。|
|*bOpacity*|[在]如果新颜色与不相加性混合，则为 TRUE;假，如果不是。|

### <a name="remarks"></a>备注

此方法接收[WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmcolorizationcolorchanged)通知消息，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncommand"></a><a name="oncommand"></a>Cwnd：OnCommand

当用户从菜单中选择项目、子控件发送通知消息或翻译快捷键时，框架将调用此成员函数。

```
virtual BOOL OnCommand(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*wParam*<br/>
*wParam*的低阶单词标识菜单项、控件或加速器的命令 ID。 如果消息来自控件，*则 wParam*的高阶单词指定通知消息。 如果消息来自加速器，则高阶单词为 1。 如果消息来自菜单，则高阶单词为 0。

*lParam*<br/>
标识消息来自控件时发送消息的控件。 否则 *，lParam*为 0。

### <a name="return-value"></a>返回值

如果应用程序处理此消息，则返回非零;否则 0。

### <a name="remarks"></a>备注

`OnCommand`处理控制通知和ON_COMMAND条目的消息映射，并调用相应的成员函数。

重写派生类中的此成员函数以处理[WM_COMMAND](/windows/win32/menurc/wm-command)消息。 除非调用基类`OnCommand`，否则重写将不会处理消息映射。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncompacting"></a><a name="oncompacting"></a>Cwnd：：在压缩

当 Windows 检测到在 30 到 60 秒的间隔内超过 12.5% 的系统时间用于压缩内存时，该框架会为所有顶级窗口调用此成员函数。

```
afx_msg void OnCompacting(UINT nCpuTime);
```

### <a name="parameters"></a>参数

*nCpuTime*<br/>
指定 Windows 压缩内存当前花费的 CPU 时间与执行其他操作的 CPU 时间的比率。 例如，8000h 表示压缩内存的 CPU 时间的 50%。

### <a name="remarks"></a>备注

这表示系统内存不足。

当对象`CWnd`收到此调用时，它应该释放尽可能多的内存，同时考虑到应用程序的当前活动级别和在 Windows 中运行的应用程序总数。 应用程序可以调用 Windows 函数来确定正在运行的应用程序数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncompareitem"></a><a name="oncompareitem"></a>Cwnd：：上比较项目

框架调用此成员函数以指定新项目在子排序的所有者绘制组合或列表框中的相对位置。

```
afx_msg int OnCompareItem(
    int nIDCtl,
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```

### <a name="parameters"></a>参数

*nIDCtl*<br/>
发送WM_COMPAREITEM消息的控件的标识符。

*lp比较项目结构*<br/>
包含指向[COMPAREITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-compareitemstruct)数据结构的长指针，其中包含组合或列表框中两个项目的标识符和应用程序提供的数据。

### <a name="return-value"></a>返回值

指示两个项的相对位置。 它可能是以下任何值：

|“值”|含义|
|-----------|-------------|
|-1|项目 1 在项目 2 之前排序。|
|0|项目 1 和项目 2 排序相同。|
|1|项目 1 在项目 2 之后排序。|

### <a name="remarks"></a>备注

如果使用[CBS_SORT](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)或[LBS_SORT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)样式创建组合或列表框，则每当应用程序添加新项时，Windows 都会向组合框或列表框所有者发送WM_COMPAREITEM消息。

组合或列表框中的两个项目在`COMPAREITEMSTRUCT`*lpCompareItemTruct*指向的结构中进行了改革。 `OnCompareItem`应返回一个值，指示哪些项应出现在其他项之前。 通常，Windows 多次进行此调用，直到它确定新项目的确切位置。

如果`COMPAREITEMSTRUCT`结构`hwndItem`的成员属于[CListBox](../../mfc/reference/clistbox-class.md)或[CComboBox](../../mfc/reference/ccombobox-class.md)对象，则调用相应`CompareItem`类的虚拟函数。 重写`CComboBox::CompareItem`或`CListBox::CompareItem`派生`CListBox`或`CComboBox`类中执行项比较。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncompositionchanged"></a><a name="oncompositionchanged"></a>Cwnd：：在作文上

启用或禁用桌面窗口管理器 （DWM） 组合时，框架会为所有顶级窗口调用此成员函数。

```
afx_msg void OnCompositionChanged();
```

### <a name="remarks"></a>备注

此方法接收[WM_DWMCOMPOSITIONCHANGED](/windows/win32/dwm/wm-dwmcompositionchanged)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncontextmenu"></a><a name="oncontextmenu"></a>Cwnd：：在上下文菜单上

当用户单击窗口中的鼠标右键（右键单击）时，由框架调用。

```
afx_msg void OnContextMenu(
    CWnd* pWnd,
    CPoint pos);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
处理用户右键单击鼠标的窗口。 这可以是接收消息的窗口的子窗口。 有关处理此消息的详细信息，请参阅备注部分。

*Pos*<br/>
光标的位置，在屏幕坐标中，在鼠标单击时。

### <a name="remarks"></a>备注

您可以使用[TrackPopupMenu](../../mfc/reference/cmenu-class.md#trackpopupmenu)显示上下文菜单来处理此消息。

如果不显示上下文菜单，则应将此消息传递到[DefWindowProc](#defwindowproc)函数。 如果窗口是子窗口，`DefWindowProc`则将消息发送给父窗口。 否则，`DefWindowProc`如果指定位置位于窗口的标题中，则显示默认上下文菜单。

## <a name="cwndoncopydata"></a><a name="oncopydata"></a>Cwnd：：打开复制数据

框架调用此成员函数将数据从一个应用程序复制到另一个应用程序。

```
afx_msg BOOL OnCopyData(
    CWnd* pWnd,
    COPYDATASTRUCT* pCopyDataStruct);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
指向发送数据的`CWnd`对象的指针。

*pCopy 数据结构*<br/>
指向包含所发送数据的[COPYDATASTRUCT](/windows/win32/api/winuser/ns-winuser-copydatastruct)结构的指针。

### <a name="return-value"></a>返回值

如果接收应用程序成功接受数据，则返回 TRUE。 否则，返回 FALSE。

### <a name="remarks"></a>备注

传递的数据不能包含对接收数据的应用程序无法访问的对象的指针或其他引用。

复制数据时，发送过程的另一个线程不得更改数据。

接收应用程序应考虑数据只读。 参数*pCopyDataTruct*指向的结构仅在数据传输期间有效;但是，接收应用程序不应释放与结构关联的内存。

如果接收应用程序需要在此函数返回后访问数据，则必须将接收到的数据复制到本地缓冲区。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoncreate"></a><a name="oncreate"></a>Cwnd：：打开创建

当应用程序请求通过调用[Create](#create)或[CreateEx](#createex)成员函数创建 Windows 窗口时，框架将调用此成员函数。

```
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>参数

*lpCreatestruct*<br/>
指向包含所创建对象的信息的`CWnd` [CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw)结构。

### <a name="return-value"></a>返回值

`OnCreate`必须返回 0 才能继续创建`CWnd`对象。 如果应用程序返回 -1，窗口将被销毁。

### <a name="remarks"></a>备注

对象`CWnd`在创建窗口后，但在其变得可见之前收到此调用。 `OnCreate`在`Create`返回 或`CreateEx`成员函数之前调用。

重写此成员函数以执行派生类所需的任何初始化。

结构`CREATESTRUCT`包含用于创建窗口的参数的副本。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonctlcolor"></a><a name="onctlcolor"></a>Cwnd：：OnCtlColor

当即将绘制子控件时，框架将调用此成员函数。

```
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,
    CWnd* pWnd,
    UINT nCtlColor);
```

### <a name="parameters"></a>参数

*pDC*<br/>
包含指向子窗口的显示上下文的指针。 可能是暂时的。

*pwnd*<br/>
包含指向要求颜色的控件的指针。 可能是暂时的。

*nCtlColor*<br/>
包含以下值之一，指定控件的类型：

- CTLCOLOR_BTN按钮控件

- CTLCOLOR_DLG对话框

- CTLCOLOR_EDIT编辑控件

- CTLCOLOR_LISTBOX列表框控件

- CTLCOLOR_MSGBOX消息框

- CTLCOLOR_SCROLLBAR滚动条控件

- CTLCOLOR_STATIC静态控件

### <a name="return-value"></a>返回值

`OnCtlColor`必须将用于绘制控制背景的控点返回到画笔。

### <a name="remarks"></a>备注

大多数控件将此消息发送到其父级（通常是对话框），以准备*pDC*使用正确的颜色绘制控件。

要更改文本颜色，请使用所需的`SetTextColor`红色、绿色和蓝色 （RGB） 值调用成员函数。

要更改单行编辑控件的背景颜色，请在CTLCOLOR_EDIT和CTLCOLOR_MSGBOX消息代码中设置画笔句柄，并调用[CDC：：SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor)函数以响应CTLCOLOR_EDIT代码。

`OnCtlColor`不会为下拉组合框的列表框调用，因为下拉列表框实际上是组合框的子级，而不是窗口的子级。 要更改下拉列表框的颜色，请创建`CComboBox`具有该检查的`OnCtlColor`覆盖在参数中CTLCOLOR_LISTBOX。 `nCtlColor` 在此处理程序中，`SetBkColor`必须使用成员函数来设置文本的背景颜色。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。 要将以下方法添加到对话框类，请使用 Visual Studio 属性窗格为WM_CTLCOLOR添加消息处理程序。 或者，您可以手动向消息映射添加ON_WM_CTLCOLOR（）条目。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]

## <a name="cwndondeadchar"></a><a name="ondeadchar"></a>Cwnd：：在死神上

当调用[OnKeyUp](#onkeyup)成员函数和[OnKeyDown](#onkeydown)成员函数时，框架将调用此成员函数。

```
afx_msg void OnDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定死键字符值。

*恩雷普森特*<br/>
指定重复计数。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|说明|
|-----------|-----------------|
|0-7|扫描代码（与 OEM 相关的值）。 高阶字的低字节。|
|8|扩展键，如功能键或数字键盘上的键（1，如果它是扩展键;否则为 0）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1;否则为 0）。|
|14|上一个键状态（如果键在调用之前关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

### <a name="remarks"></a>备注

此成员函数可用于指定死密钥的字符值。 死键是一个键，如 umlaut（双点）字符，与其他字符组合以形成复合字符。 例如，umlaut-O 字符由死键、umlaut 和 O 键组成。

应用程序通常用于`OnDeadChar`向用户提供有关按下的每个密钥的反馈。 例如，应用程序可以在不移动图斯特的情况下在当前字符位置显示重音。

由于按下的密钥和`OnDeadChar`调用之间不一定存在一对一的对应关系，因此*nFlags*中的信息通常对应用程序没有用处。 *nFlags*中的信息仅适用于对[OnKeyUp](#onkeyup)成员函数或`OnDeadChar`调用前面的[OnKeyDown](#onkeydown)成员函数的最新调用。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndondeleteitem"></a><a name="ondeleteitem"></a>Cwnd：：打开删除项目

该框架调用此成员函数，以通知所有者绘制列表框或组合框的所有者列表框已销毁列表框或组合框，或者 CComboBox：:DeleteString、CListBox：:DeleteString、CComboBox：[重置内容](../../mfc/reference/ccombobox-class.md#resetcontent)或[CListBox：重置内容](../../mfc/reference/clistbox-class.md#resetcontent)）已删除项目。 [CComboBox::DeleteString](../../mfc/reference/ccombobox-class.md#deletestring) [CListBox::DeleteString](../../mfc/reference/clistbox-class.md#deletestring)

```
afx_msg void OnDeleteItem(
    int nIDCtl,
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```

### <a name="parameters"></a>参数

*nIDCtl*<br/>
发送WM_DELETEITEM消息的控件的标识符。

*lp 删除项目已删除*<br/>
指定指向[DELETEITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-deleteitemstruct)数据结构的长指针，其中包含有关已删除列表框项的信息。

### <a name="remarks"></a>备注

如果`hwndItem``DELETEITEMSTRUCT`结构的成员属于组合框或列表框，则调用相应类的`DeleteItem`虚拟函数。 重写相应`DeleteItem`控件类的成员函数以删除特定于项的数据。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndondestroy"></a><a name="ondestroy"></a>Cwnd：：On销毁

框架调用此成员函数以通知`CWnd`对象它正在被销毁。

```
afx_msg void OnDestroy();
```

### <a name="remarks"></a>备注

`OnDestroy`在从屏幕中删除`CWnd`对象后调用。

`OnDestroy`首先被称为被破坏，`CWnd`然后为儿童窗口，`CWnd`因为他们被摧毁。 可以假定所有子窗口在`OnDestroy`运行时仍然存在。

如果被`CWnd`销毁的对象是剪贴板-查看器链的一部分（通过调用[SetClipboardViewer](#setclipboardviewer)成员函数设置），`CWnd`则必须在从`OnDestroy`函数返回之前调用[ChangeClipboard 链](#changeclipboardchain)成员函数，从剪贴板-查看器链中删除自身。

## <a name="cwndondestroyclipboard"></a><a name="ondestroyclipboard"></a>Cwnd：：在毁灭夹板上

当剪贴板通过调用["空剪板](/windows/win32/api/winuser/nf-winuser-emptyclipboard)"Windows 功能清空时，框架将此成员功能称为剪贴板所有者。

```
afx_msg void OnDestroyClipboard();
```

## <a name="cwndondevicechange"></a><a name="ondevicechange"></a>Cwnd：：打开设备更改

框架调用此成员函数以通知应用程序或设备驱动程序设备或计算机的硬件配置的更改。

```
afx_msg BOOL OnDeviceChange(
    UINT nEventType,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

*n事件类型*<br/>
事件类型。 有关可用值的说明，请参阅备注部分

*dwData*<br/>
包含事件特定数据的结构的地址。 其含义取决于给定的事件。

### <a name="remarks"></a>备注

对于提供软件可控制功能（如弹出和锁定）的设备，操作系统通常会发送DBT_DEVICEREMOVEPENDING消息，让应用程序和设备驱动程序正常地结束对设备的使用。

如果操作系统强制删除设备，则在执行此操作之前可能不会发送DBT_DEVICEQUERYREMOVE消息。

*nEvent*参数可以是以下值之一：

- [DBT_DEVICEARRIVAL](/windows/win32/DevIO/dbt-devicearrival)设备已插入，现在可用。

- [DBT_DEVICEQUERYREMOVE](/windows/win32/DevIO/dbt-devicequeryremove)请求删除设备的权限。 任何应用程序都可以拒绝此请求并取消删除。

- [DBT_DEVICEQUERYREMOVEFAILED](/windows/win32/DevIO/dbt-devicequeryremovefailed)删除设备的请求已被取消。

- [DBT_DEVICEREMOVEPENDING](/windows/win32/DevIO/dbt-deviceremovepending)设备即将被删除。 无法拒绝。

- [DBT_DEVICEREMOVECOMPLETE](/windows/win32/DevIO/dbt-deviceremovecomplete)设备已被删除。

- [DBT_DEVICETYPESPECIFIC](/windows/win32/DevIO/dbt-devicetypespecific)特定于设备的事件。

- [DBT_CONFIGCHANGED](/windows/win32/DevIO/dbt-configchanged)当前配置已更改。

- DBT_DEVNODES_CHANGED设备节点已更改。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndondevmodechange"></a><a name="ondevmodechange"></a>Cwnd：：在开发模式更改

当用户更改设备模式设置时，框架会为所有顶级`CWnd`对象调用此成员函数。

```
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```

### <a name="parameters"></a>参数

*lpDevice名称*<br/>
指向 Windows 初始化文件 WIN 中指定的设备名称。Ini。

### <a name="remarks"></a>备注

处理WM_DEVMODECHANGE消息的应用程序可能会重新初始化其设备模式设置。 使用 Windows`ExtDeviceMode`功能保存和恢复设备设置的应用程序通常不会处理此功能。

当用户从"控制面板"更改默认打印机时，不会调用此功能。 在这种情况下，调用函数`OnWinIniChange`。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndondrawclipboard"></a><a name="ondrawclipboard"></a>Cwnd：：在画夹板上

当剪贴板的内容发生更改时，框架会为剪贴板-查看器链中的每个窗口调用此成员函数。

```
afx_msg void OnDrawClipboard();
```

### <a name="remarks"></a>备注

只有通过调用[SetClipboardViewer](#setclipboardviewer)成员函数加入剪贴板查看器链的应用程序才能响应此调用。

每个收到`OnDrawClipboard`呼叫的窗口都应调用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函数，将[WM_DRAWCLIPBOARD](/windows/win32/dataxchg/wm-drawclipboard)消息传递到剪贴板-查看器链中的下一个窗口。 下一个窗口的句柄由[SetClipboardViewer](#setclipboardviewer)成员函数返回;可以修改它以响应[OnChangeCbChain](#onchangecbchain)成员函数调用。

## <a name="cwndondrawiconicthumbnailorlivepreview"></a><a name="ondrawiconicthumbnailorlivepreview"></a>Cwnd：：在DrawIconic或生活预览

由框架在需要获取要在 Windows 7 选项卡缩略图上或客户端上（进行应用程序速览）显示的位图时进行调用。

```
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,
    CRect rect,
    CSize szRequiredThumbnailSize,
    BOOL bIsThumbnail,
    BOOL& bAlphaChannelSet);
```

### <a name="parameters"></a>参数

*直流*<br/>
指定设备上下文。

*矩形*<br/>
指定要渲染的区域的边界矩形。

*sz必需缩略图*<br/>
指定目标缩略图的大小。 如果*bIs缩略是 FALSE，* 则应忽略。

*bIs缩略图*<br/>
指定是为标志性缩略图或实时预览（peek）调用此方法。

*bAlpha通道集*<br/>
[出]如果您的实现初始化了在*dc*中选择的位图的 Alpha 通道，请将其设置为 TRUE。

### <a name="remarks"></a>备注

在派生类中重写此方法，并在指定的设备上下文中绘制，以便自定义缩略图和透视。 如果*b缩略图*为 TRUE，则可以忽略*sz"必需缩略器大小*"。 在这种情况下，您应该注意绘制全尺寸位图（即覆盖整个工作区的位图）。 设备上下文 （ *dc*） 附带选定的 32 位位图. 默认实现使用PRF_CLIENT、PRF_CHILDREN和PRF_NONCLIENT标志向此窗口发送WM_PRINT。

## <a name="cwndondrawitem"></a><a name="ondrawitem"></a>Cwnd：：在画项目

当控件或菜单的可视方面发生更改时，框架为所有者绘制按钮控件、组合框控件、列表框控件或菜单的所有者调用此成员函数。

```
afx_msg void OnDrawItem(
    int nIDCtl,
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>参数

*nIDCtl*<br/>
包含发送WM_DRAWITEM消息的控件的标识符。 如果菜单发送了该消息 *，nIDCtl*包含 0。

*lpDraw 项目已结*<br/>
指定指向`DRAWITEMSTRUCT`数据结构的长指针，其中包含有关要绘制的项和所需绘图类型的信息。

### <a name="remarks"></a>备注

`itemAction` [DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)结构的成员定义要执行的绘图操作。 此成员中的数据允许控件的所有者确定需要什么绘制操作。

在从处理此消息返回之前，应用程序应确保`DRAWITEMSTRUCT`结构的*hDC*成员标识的设备上下文还原为默认状态。

如果`hwndItem`成员属于 CButton、CMenu、CListBox 或[CComboBox](../../mfc/reference/ccombobox-class.md)对象，则调用`DrawItem`相应类的虚拟函数。 [CButton](../../mfc/reference/cbutton-class.md) [CMenu](../../mfc/reference/cmenu-class.md) [CListBox](../../mfc/reference/clistbox-class.md) 重写相应`DrawItem`控件类的成员函数以绘制项。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndondropfiles"></a><a name="ondropfiles"></a>Cwnd：：OnDrop文件

当用户将鼠标左键释放到已注册为已删除文件的收件人的窗口上时，框架将调用此成员函数。

```
afx_msg void OnDropFiles(HDROP hDropInfo);
```

### <a name="parameters"></a>参数

*hDropInfo*<br/>
指向描述丢弃文件的内部数据结构的指针。 此句柄由`DragFinish`和`DragQueryFile`和`DragQueryPoint`Windows 函数用于检索有关删除文件的信息。

### <a name="remarks"></a>备注

通常，派生类将设计为支持丢弃的文件，并在窗口构造期间自行注册。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonenable"></a><a name="onenable"></a>Cwnd：启用

当应用程序更改`CWnd`对象的启用状态时，框架将调用此成员函数。

```
afx_msg void OnEnable(BOOL bEnable);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定`CWnd`对象是已启用还是禁用。 如果已启用 ，则`CWnd`此参数为 TRUE;如果已启用 ，则此参数为 TRUE。如果已禁用，`CWnd`则为 FALSE。

### <a name="remarks"></a>备注

`OnEnable`在[启用窗口](#enablewindow)成员函数返回之前调用，但在窗口启用状态[（WS_DISABLED](styles-used-by-mfc.md#window-styles)样式位）更改后。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonendsession"></a><a name="onendsession"></a>Cwnd：：结束会话

该框架在`CWnd`对象从[OnQueryEndSession](#onqueryendsession)成员函数调用返回非零值后调用此成员函数。

```
afx_msg void OnEndSession(BOOL bEnding);
```

### <a name="parameters"></a>参数

*弯曲*<br/>
指定会话是否结束。 如果会话正在结束，则为 TRUE;如果会话已结束，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

`OnEndSession`调用通知`CWnd`对象会话是否实际结束。

如果*bEnding*为 TRUE，则 Windows 可以在处理此调用后的任何时间终止。 因此，让应用程序在 中`OnEndSession`执行终止所需的所有任务。

会话结束时，您无需调用[销毁窗口](#destroywindow)成员函数或[PostQuitMessage](/windows/win32/api/winuser/nf-winuser-postquitmessage) Windows 功能。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonenteridle"></a><a name="onenteridle"></a>Cwnd：：OnEnteridle

框架调用此成员函数以通知应用程序的主窗口过程模式对话框或菜单正在进入空闲状态。

```
afx_msg void OnEnterIdle(
    UINT nWhy,
    CWnd* pWho);
```

### <a name="parameters"></a>参数

*n为什么*<br/>
指定消息是对话框还是显示菜单的结果。 此参数可以是以下值之一：

- MSGF_DIALOGBOX系统处于空闲状态，因为正在显示一个对话框。

- MSGF_MENU系统处于空闲状态，因为正在显示菜单。

*p谁*<br/>
指定指向对话框的指针（如果*MSGF_DIALOGBOX nWhy））* 或包含显示菜单的窗口（如果*nWhy* MSGF_MENU）。 此指针可能是临时指针，不应存储以供以后使用。

### <a name="remarks"></a>备注

当队列中没有消息处理过一个或多个以前的消息后等待时，模式对话框或菜单将进入空闲状态。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonentermenuloop"></a><a name="onentermenuloop"></a>Cwnd：：打开门菜单环线

当输入菜单模式循环时，框架将调用此成员函数。

```
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>参数

*bIsTrackPopupMenu*<br/>
指定所涉及的菜单是否为弹出式菜单。 如果函数成功，则具有非零值;否则 0。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonentersizemove"></a><a name="onentersizemove"></a>Cwnd：：打开"移动"

在受影响的窗口进入移动或调整模式循环的移动或大小调整循环后，框架调用此成员函数一次。

```
afx_msg void OnEnterSizeMove();
```

### <a name="remarks"></a>备注

此方法接收[WM_ENTERSIZEMOVE](/windows/win32/winmsg/wm-entersizemove)通知，这在 Windows SDK 中介绍。

当用户单击窗口的标题栏或大小边框时，或者当窗口将[WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand)消息传递到[CWnd：:DWindowProc](#defwindowproc)函数以及该消息的*wParam*参数指定SC_MOVE或SC_SIZE时，窗口将进入移动或调整大小模式循环。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonerasebkgnd"></a><a name="onerasebkgnd"></a>Cwnd：：OnEraseBkgnd

当`CWnd`对象背景需要正在定义时（例如，调整大小时），框架将调用此成员函数。

```
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
指定设备上下文对象。

### <a name="return-value"></a>返回值

如果擦除背景，则非零;否则 0。

### <a name="remarks"></a>备注

它被调用为绘画准备一个无效的区域。

默认实现使用窗口类结构`hbrBackground`成员指定的窗口类背景画笔擦除背景。

如果`hbrBackground`成员为 NULL，则重写的版本`OnEraseBkgnd`应擦除背景颜色。 您的版本还应通过首先为画笔调用`CWnd`[UnunObject，](/windows/win32/api/wingdi/nf-wingdi-unrealizeobject)然后选择画笔，将预期画笔的原点与坐标对齐。

重写`OnEraseBkgnd`时应返回非零以响应WM_ERASEBKGND，如果它处理消息并擦除背景;如果重写时，应返回非零。"则为响应"未归零"。这表明不需要进一步进行复制。 如果返回 0，窗口将保持标记为需要擦除。 （通常，这意味着`fErase``PAINTSTRUCT`结构的成员将为 TRUE。

Windows 假定使用MM_TEXT映射模式计算背景。 如果设备上下文使用任何其他映射模式，则擦除的区域可能不在工作区的可见部分内。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonexitmenuloop"></a><a name="onexitmenuloop"></a>Cwnd：：打开菜单环线

退出菜单模式循环时，框架将调用此成员函数。

```
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>参数

*bIsTrackPopupMenu*<br/>
指定所涉及的菜单是否为弹出式菜单。 如果函数成功，则具有非零值;否则 0。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonexitsizemove"></a><a name="onexitsizemove"></a>Cwnd：：打开"退出大小移动"

在受影响的窗口退出移动或调整模式循环大小后，框架会调用此成员函数一次。

```
afx_msg void OnExitSizeMove();
```

### <a name="remarks"></a>备注

此方法接收[WM_EXITSIZEMOVE](/windows/win32/winmsg/wm-exitsizemove)通知，这在 Windows SDK 中介绍。

当用户单击窗口的标题栏或大小边框时，或者当窗口将[WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand)消息传递到[CWnd：:DWindowProc](#defwindowproc)函数以及该消息的*wParam*参数指定SC_MOVE或SC_SIZE时，窗口将进入移动或调整大小模式循环。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonfontchange"></a><a name="onfontchange"></a>Cwnd：：OnFontChange

应用程序更改字体资源池后，系统中的所有顶级`OnFontChange`窗口都会收到来自框架的呼叫。

```
afx_msg void OnFontChange();
```

### <a name="remarks"></a>备注

从系统添加或删除字体的应用程序（例如，通过[AddFontResource](/windows/win32/api/wingdi/nf-wingdi-addfontresourcew)或[RemoveFontResource](/windows/win32/api/wingdi/nf-wingdi-removefontresourcew) Windows 功能）应将[WM_FONTCHANGE](/windows/win32/gdi/wm-fontchange)消息发送到所有顶级窗口。

要发送此消息，请使用["发送消息窗口"](/windows/win32/api/winuser/nf-winuser-sendmessage)功能，将*hWnd*参数设置为HWND_BROADCAST。

## <a name="cwndongetdlgcode"></a><a name="ongetdlgcode"></a>Cwnd：：OnGetDlgCode

针对控件进行调用，以便控件可以自己处理箭头键和 TAB 键输入。

```
afx_msg UINT OnGetDlgCode();
```

### <a name="return-value"></a>返回值

以下一个或多个值，指示应用程序处理的输入类型：

- DLGC_BUTTON按钮（通用）。

- DLGC_DEFPUSHBUTTON默认按钮。

- DLGC_HASSETSELEM_SETSEL消息。

- DLGC_UNDEFPUSHBUTTON 没有默认按钮处理。 （应用程序可以使用带有DLGC_BUTTON的标志来指示它处理按钮输入，但依赖于系统进行默认按钮处理。

- DLGC_RADIOBUTTON单选按钮。

- DLGC_STATIC静态控件。

- DLGC_WANTALLKEYS所有键盘输入。

- DLGC_WANTARROWS箭头键。

- DLGC_WANTCHARS消息WM_CHAR。

- DLGC_WANTMESSAGE所有键盘输入。 应用程序将此消息传递到控件。

- DLGC_WANTTAB选项卡键。

### <a name="remarks"></a>备注

通常，Windows 会处理`CWnd`控件的所有箭头键和 TAB 键输入。 通过重写`OnGetDlgCode`，`CWnd`控件可以选择特定类型的输入来处理自身。

预定义的`OnGetDlgCode`控制类的默认函数返回适合每个类的代码。

## <a name="cwndongetminmaxinfo"></a><a name="ongetminmaxinfo"></a>Cwnd：：OnGetMinMaxinfo

每当 Windows 需要知道最大化位置或维度或最小或最大跟踪大小时，框架都会调用此成员函数。

```
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```

### <a name="parameters"></a>参数

*lpMMI*<br/>
指向包含有关`MINMAXINFO`窗口最大大小和位置及其最小和最大跟踪大小的信息的结构。 有关此结构的详细信息，请参阅[MINMAXINFO](/windows/win32/api/winuser/ns-winuser-minmaxinfo)结构。

### <a name="remarks"></a>备注

最大化大小是窗口边界完全扩展时的大小。 窗口的最大跟踪大小是可以使用边框调整窗口大小可以达到的最大窗口大小。 窗口的最小跟踪大小是通过使用边框调整窗口大小可以达到的最小窗口大小。

Windows 填充指定各种位置和维度的默认值的点数组。 应用程序可能会更改 中的`OnGetMinMaxInfo`这些值。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonhelp"></a><a name="onhelp"></a>Cwnd：：上帮助

处理应用程序中的 F1 帮助（使用当前上下文）。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>备注

有关详细信息[，请参阅 CWinApp：OnHelp。](../../mfc/reference/cwinapp-class.md#onhelp)

## <a name="cwndonhelpfinder"></a><a name="onhelpfinder"></a>Cwnd：：OnHelpFinder

处理ID_HELP_FINDER和ID_DEFAULT_HELP命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>备注

有关详细信息，请参阅[CWinApp：OnHelpFinder。](../../mfc/reference/cwinapp-class.md#onhelpfinder)

## <a name="cwndonhelpindex"></a><a name="onhelpindex"></a>Cwnd：：OnHelpIndex

处理ID_HELP_INDEX命令并提供默认帮助主题。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>备注

有关详细信息，请参阅[CWinApp：OnHelpIndex。](../../mfc/reference/cwinapp-class.md#onhelpindex)

## <a name="cwndonhelpinfo"></a><a name="onhelpinfo"></a>Cwnd：：OnHelpInfo

当用户按 F1 键时，由框架调用。

```
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```

### <a name="parameters"></a>参数

*lpHelpInfo*<br/>
指向[HELPINFO](/windows/win32/api/winuser/ns-winuser-helpinfo)结构的指针，该结构包含有关请求帮助的菜单项、控件、对话框或窗口的信息。

### <a name="return-value"></a>返回值

如果窗口具有键盘焦点或菜单在窗口中处于活动状态，则返回 TRUE。 如果没有窗口具有键盘焦点，请返回 FALSE。

### <a name="remarks"></a>备注

如果按下 F1 时菜单处于活动状态，WM_HELP发送到与菜单关联的窗口;如果菜单在按下 F1 时处于活动状态，则将WM_HELP发送到与菜单关联的窗口。否则，WM_HELP发送到具有键盘焦点的窗口。 如果没有窗口具有键盘焦点，WM_HELP将发送到当前活动窗口。

## <a name="cwndonhelpusing"></a><a name="onhelpusing"></a>Cwnd：：OnHelpUsing

处理ID_HELP_USING命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>备注

有关详细信息，请参阅[CWinApp：OnHelpUsing。](../../mfc/reference/cwinapp-class.md#onhelpusing)

## <a name="cwndonhotkey"></a><a name="onhotkey"></a>Cwnd：：上HotKey

当用户按下系统范围的热键时，框架将调用此成员函数。

```
afx_msg void OnHotKey(
    UINT nHotKeyId,
    UINT nKey1,
    UINT nKey2);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nHotKeyId*|[在]生成消息的热键的标识符。 如果消息由系统定义的热键生成，则此参数将是以下值之一：<br /><br /> - IDHOT_SNAPDESKTOP - 按下了捕捉桌面热键。<br />- IDHOT_SNAPWINDOW - 按下卡扣窗口热键。|
|*nKey1*|[在]标志的位组合 （OR），指示与*nKey2*参数指定的键结合按下的键。 可能的值包括：<br /><br /> - MOD_ALT - 任一 ALT 键被关闭。<br />- MOD_CONTROL - 任一 CTRL 密钥被关闭。<br />- MOD_SHIFT - 任一 SHIFT 键被关闭。<br />- MOD_WIN - 任一 WINDOWS 密钥被关闭。 这些密钥标有 Microsoft Windows 徽标。|
|*nKey2*|[在]热键的虚拟密钥代码。|

### <a name="remarks"></a>备注

此方法接收[WM_HOTKEY](/windows/win32/inputdev/wm-hotkey)通知，这在 Windows SDK 中介绍。 此消息放置在与注册热键的线程关联的消息队列的顶部。 使用[RegisterHotKey](/windows/win32/api/winuser/nf-winuser-registerhotkey)功能注册系统范围的热键。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonhscroll"></a><a name="onhscroll"></a>Cwnd：：OnHScroll

当用户单击窗口的水平滚动条时，框架将调用此成员函数。

```
afx_msg void OnHScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>参数

*nSB代码*<br/>
指定指示用户滚动请求的滚动条代码。 此参数可以是以下项之一：

- SB_LEFT向左滚动。

- SB_ENDSCROLL 结束滚动。

- SB_LINELEFT向左滚动。

- SB_LINERIGHT向右滚动。

- SB_PAGELEFT向左滚动一页。

- SB_PAGERIGHT向右滚动一页。

- SB_RIGHT向右滚动。

- SB_THUMBPOSITION滚动到绝对位置。 当前位置由*nPos*参数指定。

- SB_THUMBTRACK将滚动框拖动到指定位置。 当前位置由*nPos*参数指定。

*nPos*<br/>
如果滚动条代码为SB_THUMBPOSITION或SB_THUMBTRACK，则指定滚动框位置;否则，不使用。 根据初始滚动范围 *，nPos*可能是负的，如有必要，应强制转换为**int。**

*pScrollBar*<br/>
如果滚动消息来自滚动条控件，则包含指向该控件的指针。 如果用户单击窗口的滚动条，则此参数为 NULL。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

SB_THUMBTRACK滚动条代码通常由在拖动滚动框时提供一些反馈的应用程序使用。

如果应用程序滚动滚动条控制的内容，则还必须使用[SetScrollPos](#setscrollpos)成员函数重置滚动框的位置。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]

## <a name="cwndonhscrollclipboard"></a><a name="onhscrollclipboard"></a>Cwnd：：OnHScroll剪贴板

当剪贴板数据具有`OnHScrollClipboard``CF_OWNERDISPLAY`格式且剪贴板查看器的水平滚动栏中有事件时，剪贴板所有者的成员函数由剪贴板查看器调用。

```
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>参数

*pClipAppwnd*<br/>
指定指向剪贴板-查看器窗口的指针。 该指针可能是暂时的，不应存储起来供将来使用。

*nSB代码*<br/>
在低阶单词中指定以下滚动条代码之一：

- SB_BOTTOM向右滚动。

- SB_ENDSCROLL 结束滚动。

- SB_LINEDOWN向下滚动一行。

- SB_LINEUP向上滚动一行。

- SB_PAGEDOWN向下滚动一页。

- SB_PAGEUP向上滚动一页。

- SB_THUMBPOSITION滚动到绝对位置。 当前位置以*nPos*提供。

- SB_TOP向左滚动。

*nPos*<br/>
如果滚动条代码为SB_THUMBPOSITION，则包含滚动框位置;否则未使用。

### <a name="remarks"></a>备注

所有者应滚动剪贴板图像，使相应部分无效，并更新滚动条值。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoniconerasebkgnd"></a><a name="oniconerasebkgnd"></a>Cwnd：：OnIconEraseBkgnd

在绘制图标之前必须填充图标的背景时，框架将此`CWnd`成员函数称为最小化（标志性）对象。

```
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
指定图标的设备上下文对象。 可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

`CWnd`仅当为窗口默认实现定义了类图标时，才接收此调用;否则，将调用[OneraseBkgnd。](#onerasebkgnd)

[DefWindowProc](#defwindowproc)成员函数使用父窗口的背景画笔填充图标背景。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoninitmenu"></a><a name="oninitmenu"></a>Cwnd：：Oninitmenu

当菜单即将变为活动时，框架将调用此成员函数。

```
afx_msg void OnInitMenu(CMenu* pMenu);
```

### <a name="parameters"></a>参数

*pMenu*<br/>
指定要初始化的菜单。 可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

`OnInitMenu`当用户单击菜单栏上的项目或按菜单键时，将调用。 在显示菜单之前，重写此成员函数以修改菜单。

`OnInitMenu`首次访问菜单时仅调用一次（例如，当用户单击菜单栏上的项目时）。 此方法不提供有关菜单项的信息。 当用户移动到菜单中的项时（例如，通过跨多个菜单项移动鼠标），不会再次调用该函数。 用户退出菜单（例如，通过单击应用程序工作区）并随后单击菜单栏上的项后，将再次调用该函数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoninitmenupopup"></a><a name="oninitmenupopup"></a>Cwnd：：OninitMenuPopup

当弹出菜单即将变为活动时，框架将调用此成员函数。

```
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nIndex,
    BOOL bSysMenu);
```

### <a name="parameters"></a>参数

*pPopupMenu*<br/>
指定弹出式菜单的菜单对象。 可能是临时的，不应存储以供以后使用。

*nIndex*<br/>
指定主菜单中的弹出式菜单的索引。

*bSysMenu*<br/>
如果弹出式菜单是"控制"菜单，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

这允许应用程序在显示弹出式菜单之前对其进行修改，而无需更改整个菜单。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoninputdevicechange"></a><a name="oninputdevicechange"></a>Cwnd：：输入设备更改

当从系统添加或删除 I/O 设备时，框架将调用此成员函数。

```
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*uFlag*|[在]此标志可以包含以下值：<br /><br /> - GIDC_ARRIVAL - 系统已添加新设备。<br />- GIDC_REMOVAL - 设备已从系统中删除。|

### <a name="remarks"></a>备注

此方法接收[WM_INPUT_DEVICE_CHANGE](/windows/win32/inputdev/wm-input-device-change)通知，这在 Windows SDK 中介绍。 是通用输入设备消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoninputlangchange"></a><a name="oninputlangchange"></a>Cwnd：：在输入朗转换

更改应用程序的输入语言后，框架将此成员称为受影响最大的窗口。

```
afx_msg void OnInputLangChange(
    UINT nCharSet,
    UINT nLocaleId);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nCharSet*|[在]新区域设置的字符集。 有关详细信息，请参阅[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)结构的*lfCharSet*参数。|
|*nLocaleId*|[在]输入区域设置标识符。 有关详细信息，请参阅[语言标识符常量和字符串](/windows/win32/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>备注

此方法接收[WM_INPUTLANGCHANGE](/windows/win32/winmsg/wm-inputlangchange)通知消息，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndoninputlangchangerequest"></a><a name="oninputlangchangerequest"></a>Cwnd：：在输入朗更改请求

当用户选择新的输入语言时，框架将此成员称为具有焦点的窗口。

```
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,
    UINT nLocaleId);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示新区域设置是从已安装区域设置列表中的上一个或下一个区域设置中选择的符号（OR）组合，或者新输入区域设置的键盘布局可与系统字符集一起使用。<br /><br /> 可能的值是INPUTLANGCHANGE_BACKWARD、INPUTLANGCHANGE_FORWARD和INPUTLANGCHANGE_SYSCHARSET。|
|*nLocaleId*|[在]输入区域设置标识符。 有关详细信息，请参阅[语言标识符常量和字符串](/windows/win32/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>备注

此方法接收[WM_INPUTLANGCHANGEREQUEST](/windows/win32/winmsg/wm-inputlangchangerequest)通知消息，这在 Windows SDK 中介绍。 当用户选择使用键盘控制面板应用程序中指定的热键或从系统任务栏上的指示器指定的热键的新输入语言时，将发布此消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonkeydown"></a><a name="onkeydown"></a>Cwnd：：打开键

按下非系统密钥时，框架将调用此成员函数。

```
afx_msg void OnKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定给定密钥的虚拟密钥代码。 有关标准虚拟密钥代码的列表，请参阅 Winuser.h

*恩雷普森特*<br/>
重复计数（由于用户按住键而重复击键的次数）。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|说明|
|-----------|-----------------|
|0-7|扫描代码（与 OEM 相关的值）。|
|8|扩展键，如功能键或数字键盘上的键（如果是扩展键，为 1）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1;否则为 0）。|
|14|上一个键状态（如果键在调用之前关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

对于WM_KEYDOWN消息，密钥转换位（位 15）为 0，上下文代码位（位 13）为 0。

### <a name="remarks"></a>备注

非系统键是在未按下 ALT 键时按下的键盘键，或者在具有输入焦点时`CWnd`按下的键盘键。

由于自动重复，在进行`OnKeyDown`[OnKeyUp](#onkeyup)成员函数调用之前，可能会发生多个调用。 指示前一个键状态的位可用于确定`OnKeyDown`调用是第一个向下转换还是重复向下转换。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonkeyup"></a><a name="onkeyup"></a>Cwnd：：打开

释放非系统密钥时，框架将调用此成员函数。

```
afx_msg void OnKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定给定密钥的虚拟密钥代码。 有关标准虚拟密钥代码的列表，请参阅 Winuser.h

*恩雷普森特*<br/>
重复计数（由于用户按住键而重复击键的次数）。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|说明|
|-----------|-----------------|
|0-7|扫描代码（与 OEM 相关的值）。 高阶字的低字节。|
|8|扩展键，如功能键或数字键盘上的键（1，如果它是扩展键;否则为 0）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1;否则为 0）。|
|14|上一个键状态（如果键在调用之前关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

对于WM_KEYUP消息，密钥转换位（位 15）为 1，上下文代码位（位 13）为 0。

### <a name="remarks"></a>备注

非系统键是在未按下 ALT 键时按下的键盘键，或当具有输入焦点时按下的`CWnd`键盘键。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonkillfocus"></a><a name="onkillfocus"></a>Cwnd：：在基尔焦点

框架在失去输入焦点之前立即调用此成员函数。

```
afx_msg void OnKillFocus(CWnd* pNewWnd);
```

### <a name="parameters"></a>参数

*pNewwnd*<br/>
指定指向接收输入焦点的窗口的指针（可能是 NULL 或可能是临时的）。

### <a name="remarks"></a>备注

如果`CWnd`对象显示一个 care，此时应销毁该 care。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonlbuttondblclk"></a><a name="onlbuttondblclk"></a>克隆：：在LButtonDblClk

当用户双击鼠标左键时，框架将调用此成员函数。

```
afx_msg void OnLButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

只有具有[CS_DBLCLKS WNDCLASS 样式](/windows/win32/api/winuser/ns-winuser-wndclassw)的窗口才会`OnLButtonDblClk`收到呼叫。 这是微软基础类窗口的默认值。 当用户在`OnLButtonDblClk`系统的双击时间限制内再次按下鼠标左键时，Windows 会调用。 双击鼠标左键实际上生成四个事件[：WM_LBUTTONDOWN、WM_LBUTTONUP](#onlbuttondown)消息、WM_LBUTTONDBLCLK调用，以及释放按钮时的另一个WM_LBUTTONUP消息。 [WM_LBUTTONUP](#onlbuttonup)

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonlbuttondown"></a><a name="onlbuttondown"></a>Cwnd：：OnLButtonDown

当用户按下鼠标左键时，框架将调用此成员函数。

```
afx_msg void OnLButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonlbuttonup"></a><a name="onlbuttonup"></a>Cwnd：：OnLButtonUp

当用户释放鼠标左键时，框架将调用此成员函数。

```
afx_msg void OnLButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmbuttondblclk"></a><a name="onmbuttondblclk"></a>Cwnd：：OnMButtonDblClk

当用户双击鼠标中间键时，框架将调用此成员函数。

```
afx_msg void OnMButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

只有具有[CS_DBLCLKS WNDCLASS 样式](/windows/win32/api/winuser/ns-winuser-wndclassw)的窗口才会`OnMButtonDblClk`收到呼叫。 这是所有 Microsoft 基础类窗口的默认值。 当用户在系统的`OnMButtonDblClk`双击时间限制内再次按下鼠标中间键时，Windows 将生成呼叫。 双击鼠标中间键实际上会生成四个事件[：WM_MBUTTONDOWN](#onmbuttondown)和[WM_MBUTTONUP](#onmbuttonup)消息、WM_MBUTTONDBLCLK调用和另一个WM_MBUTTONUP消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmbuttondown"></a><a name="onmbuttondown"></a>Cwnd：：打开按钮

当用户按下鼠标中间键时，框架将调用此成员函数。

```
afx_msg void OnMButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmbuttonup"></a><a name="onmbuttonup"></a>Cwnd：：OnMButtonUp

当用户释放鼠标中间键时，框架将调用此成员函数。

```
afx_msg void OnMButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmdiactivate"></a><a name="onmdiactivate"></a>Cwnd：：OnMDI激活

框架为正在停用的子窗口和正在激活的子窗口调用此成员函数。

```
afx_msg void OnMDIActivate(
    BOOL bActivate,
    CWnd* pActivateWnd,
    CWnd* pDeactivateWnd);
```

### <a name="parameters"></a>参数

*b 激活*<br/>
如果孩子正在激活，则为 TRUE，如果孩子正在停用，则为 FALSE。

*pActivateWnd*<br/>
包含指向要激活的 MDI 子窗口的指针。 当 MDI 子窗口收到时 *，pActivateWnd*包含指向正在激活的子窗口的指针。 此指针可能是临时指针，不应存储以供以后使用。

*pDeactivateWnd*<br/>
包含指向要停用的 MDI 子窗口的指针。 此指针可能是临时指针，不应存储以供以后使用。

### <a name="remarks"></a>备注

独立于 MDI 框架窗口激活 MDI 子窗口。 当帧变为活动状态时，上次使用`OnMDIActivate`呼叫激活的子窗口会收到一条[WM_NCACTIVATE](#onncactivate)消息以绘制活动窗口框和标题栏，但不会收到另一个`OnMDIActivate`呼叫。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmeasureitem"></a><a name="onmeasureitem"></a>Cwnd：：在测量项目上

框架在创建控件时，通过所有者绘制按钮、组合框、列表框或菜单项的所有者的框架调用此成员函数。

```
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```

### <a name="parameters"></a>参数

*nIDCtl*<br/>
控件的 ID。

*lp 测量项目结构*<br/>
指向包含所有者绘制控件维度的["测量项目"](/windows/win32/api/winuser/ns-winuser-measureitemstruct)数据结构。

### <a name="remarks"></a>备注

重写此成员函数并填写`MEASUREITEMSTRUCT`*lpMeasureItemStruct*和返回指向的数据结构;这将通知 Windows 控件的维度，并允许 Windows 正确处理用户与控件的交互。

如果使用LBS_OWNERDRAWVARIABLE或CBS_OWNERDRAWVARIABLE样式创建列表框或组合框，则框架将针对控件中的每个项的所有者调用此函数;如果使用[LBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)或[CBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)样式创建列表框或组合框，则框架将针对控件中的每个项的所有者调用此函数。否则，此函数调用一次。

在发送`OnMeasureItem`[WM_INITDIALOG](/windows/win32/dlgbox/wm-initdialog)消息之前，Windows 会启动使用 OWNERDRAWFIXED 样式创建的组合框和列表框的所有者的调用。 因此，当所有者收到此呼叫时，Windows 尚未确定控件中使用的字体的高度和宽度;因此，Windows 尚未确定控件中使用的字体的高度和宽度。需要这些值的函数调用和计算应出现在应用程序或库的主要函数中。

如果要测量的项是`CMenu`或`CListBox``CComboBox`对象，则调用`MeasureItem`相应类的虚拟函数。 重写相应`MeasureItem`控件类的成员函数，以计算和设置每个项的大小。

`OnMeasureItem`仅当在运行时创建控件的类，或者使用LBS_OWNERDRAWVARIABLE或CBS_OWNERDRAWVARIABLE样式创建控件的类时，才会调用该类。 如果控件由对话框编辑器创建，`OnMeasureItem`则不会调用。 这是因为[WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem)消息在控件的创建过程的早期发送。 如果使用 、`DDX_Control``SubclassDlgItem`或`SubclassWindow`的 子类通常发生在创建过程之后。 因此，在控件`OnChildNotify`的功能中无法处理[WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem)消息，这是 MFC 用于实现ON_WM_MEASUREITEM_REFLECT的机制。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmenuchar"></a><a name="onmenuchar"></a>Cwnd：：OnMenuChar

当用户按下与当前菜单中的任何预定义的助记符不匹配的菜单助记符时，框架将调用此成员函数。

```
afx_msg LRESULT OnMenuChar(
    UINT nChar,
    UINT nFlags,
    CMenu* pMenu);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
根据生成设置，指定用户按下的 ANSI 或 Unicode 字符。

*nFlags*<br/>
如果菜单是弹出式菜单，则包含MF_POPUP标志。 如果菜单是"控件"菜单，则它包含MF_SYSMENU标志。

*pMenu*<br/>
包含指向所选`CMenu`的 的 指针。 指针可能是临时的，不应存储。

### <a name="return-value"></a>返回值

返回值的高阶单词应包含以下命令代码之一：

|“值”|描述|
|-----------|-----------------|
|0|告诉 Windows 放弃用户按下的字符，并在系统扬声器上创建短促的蜂鸣音。|
|1|告诉 Windows 关闭当前菜单。|
|2|通知 Windows 返回值的低阶字包含特定物料的物料编号。 此项目由 Windows 选择。|

如果高阶单词包含 0 或 1，则忽略低阶单词。 当使用快捷键（快捷方式）键选择放置在菜单中的位图时，应用程序应处理此消息。

### <a name="remarks"></a>备注

它发送到拥有菜单的`CWnd`。 `OnMenuChar`当用户按下 ALT 和任何其他键时，也称为，即使该键与助记符不对应也是如此。 在这种情况下 *，pMenu*指向 拥有的菜单`CWnd`*，nFlags*为 0。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmenudrag"></a><a name="onmenudrag"></a>Cwnd：：上菜单拖动

当用户开始拖动菜单项时，框架将调用当前拖放菜单的此成员函数。

```
afx_msg UINT OnMenuDrag(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nPos*|[在]拖动操作开始时菜单项的索引位置。|
|*pMenu*|[在]指向包含菜单项的[CMenu](../../mfc/reference/cmenu-class.md)对象的指针。|

### <a name="return-value"></a>返回值

|返回值|含义|
|------------------|-------------|
|MND_CONTINUE|菜单应保持活动状态。 如果释放鼠标，则应忽略它。|
|MND_ENDMENU|菜单应结束。|

### <a name="remarks"></a>备注

此方法接收[WM_MENUDRAG](/windows/win32/menurc/wm-menudrag)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmenugetobject"></a><a name="onmenugetobject"></a>Cwnd：：在MenugetObject

当鼠标光标进入菜单项或从项的中心移动到项的顶部或底部时，框架将调用当前拖放菜单的此成员函数。

```
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pMenu*|[在]指向[MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)结构的指针，该结构包含有关鼠标光标打开的拖放菜单的信息。|

### <a name="return-value"></a>返回值

|返回值|含义|
|------------------|-------------|
|MNGO_NOERROR|支持拖放和拖动操作的接口指针将返回在`pvObj`[MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)结构的成员中。 目前，仅支持[IDropTarget](/windows/win32/api/oleidl/nn-oleidl-idroptarget)接口。|
|MNGO_NOINTERFACE|不支持拖放接口。|

### <a name="remarks"></a>备注

此方法接收[WM_MENUGETOBJECT](/windows/win32/menurc/wm-menugetobject)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmenurbuttonup"></a><a name="onmenurbuttonup"></a>Cwnd：：OnMenurButtonUp

当用户在光标位于菜单项上时释放鼠标右键时，框架将调用此成员函数。

```
afx_msg void OnMenuRButtonUp(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nPos*|[在]释放鼠标右键时菜单项的索引位置。|
|*pMenu*|[在]指向包含菜单项的[CMenu](../../mfc/reference/cmenu-class.md)对象的指针。|

### <a name="remarks"></a>备注

此方法接收[WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup)通知，这在 Windows SDK 中介绍。 [WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup)消息使应用程序能够为消息中指定的菜单项提供上下文相关的菜单。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmenuselect"></a><a name="onmenuselect"></a>Cwnd：：在Menu选择

如果`CWnd`对象与菜单关联，`OnMenuSelect`则当用户选择菜单项时，框架将调用该对象。

```
afx_msg void OnMenuSelect(
    UINT nItemID,
    UINT nFlags,
    HMENU hSysMenu);
```

### <a name="parameters"></a>参数

*nItemID*<br/>
标识所选项目。 如果所选项目是菜单项，则*nItemID*包含菜单项 ID。 如果所选项目包含弹出式菜单，*则 nItemID*包含弹出式菜单索引 *，hSysMenu*包含主（单击）菜单的句柄。

*nFlags*<br/>
包含以下菜单标志的组合：

- MF_BITMAP项目是位图。

- MF_CHECKED项目已选中。

- MF_DISABLED项目已禁用。

- MF_GRAYED项目变暗。

- MF_MOUSESELECT使用鼠标选择了项目。

- MF_OWNERDRAW项目是所有者绘制项目。

- MF_POPUP项目包含一个弹出式菜单。

- MF_SEPARATOR项目是菜单项分隔符。

- MF_SYSMENU项包含在"控制"菜单中。

*hSysMenu*<br/>
如果*nFlags*包含MF_SYSMENU，则标识与消息关联的菜单。 如果*nFlags*包含MF_POPUP，则标识主菜单的句柄。 如果*nFlags*既不包含MF_SYSMENU也不MF_POPUP，则它未使用。

### <a name="remarks"></a>备注

如果*nFlags*包含 0xFFFF，hSysMenu 包含 0，则 Windows 已关闭菜单，因为用户按下 ESC 键或在菜单外单击。 *hSysMenu*

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmouseactivate"></a><a name="onmouseactivate"></a>Cwnd：：鼠标激活

当光标处于非活动窗口中且用户按下鼠标按钮时，框架将调用此成员函数。

```
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>参数

*pDesktopwnd*<br/>
指定指向要激活的窗口的顶层父窗口的指针。 指针可能是临时的，不应存储。

*nHitTest*<br/>
指定[命中测试](#onnchittest)区域代码。 命中测试是确定光标位置的测试。

*消息*<br/>
指定鼠标消息编号。

### <a name="return-value"></a>返回值

指定是否激活 和`CWnd`是否放弃鼠标事件。 它必须是以下值之一：

- MA_ACTIVATE激活`CWnd`对象。

- MA_NOACTIVATE不要激活`CWnd`对象。

- MA_ACTIVATEANDEAT激活`CWnd`对象并丢弃鼠标事件。

- MA_NOACTIVATEANDEAT不要激活`CWnd`对象并丢弃鼠标事件。

### <a name="remarks"></a>备注

在进行任何处理之前，默认实现将此消息传递给父窗口。 如果父窗口返回 TRUE，则处理将停止。

有关各个命中测试区域代码的说明，请参阅[OnNcHitTest](#onnchittest)成员函数

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCAxCtl#9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]

## <a name="cwndonmousehover"></a><a name="onmousehover"></a>Cwnd：：鼠标悬停

当光标悬停在窗口的工作区上，在之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的时间段时，框架将调用此成员函数。

```
afx_msg void OnMouseHover(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_MOUSEHOVER](/windows/win32/inputdev/wm-mousehover)通知，这在 Windows SDK 中介绍。

*nFlags*参数可以是下表中列出的修改器键的组合。 有关详细信息，请参阅[有关鼠标输入](/windows/win32/inputdev/about-mouse-input)。

|修改器键|说明|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 键。|
|MK_LBUTTON|鼠标左键已按下。|
|MK_MBUTTON|鼠标中键已按下。|
|MK_RBUTTON|鼠标右键已按下。|
|MK_SHIFT|按下 SHIFT 键。|
|MK_XBUTTON1|按下微软智能鼠标的 XBUTTON1 鼠标按钮。|
|MK_XBUTTON2|按下微软智能鼠标的 XBUTTON2 鼠标按钮。|

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmousehwheel"></a><a name="onmousehwheel"></a>Cwnd：：在鼠标上

当当前窗口由桌面窗口管理器 （DWM） 组成且该窗口最大化时，框架将调用此成员。

```
afx_msg void OnMouseHWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。<br /><br /> 有关标志列表，请参阅["关于鼠标输入](/windows/win32/inputdev/about-mouse-input)"中的"消息参数"副标题。|
|*zDelta*|[在]指示车轮旋转的距离，以 WHEEL_DELTA的倍数或分数表示，即 120。 正值表示车轮向右旋转;负值表示车轮向左旋转。|
|*pt*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_MOUSEHWHEEL](/windows/win32/inputdev/wm-mousehwheel)通知消息，这在 Windows SDK 中介绍。 当鼠标的水平滚轮倾斜或旋转时，此消息将发送到具有焦点的窗口。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmouseleave"></a><a name="onmouseleave"></a>Cwnd：：鼠标离开

当光标离开之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的窗口的工作区时，框架将调用此成员函数。

```
afx_msg void OnMouseLeave();
```

### <a name="remarks"></a>备注

此方法接收[WM_MOUSELEAVE](/windows/win32/inputdev/wm-mouseleave)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmousemove"></a><a name="onmousemove"></a>Cwnd：：鼠标移动

当鼠标光标移动时，框架将调用此成员函数。

```
afx_msg void OnMouseMove(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

如果未捕获鼠标，鼠标光标下方`CWnd`的对象将接收WM_MOUSEMOVE消息;否则，消息将转到捕获鼠标的窗口。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmousewheel"></a><a name="onmousewheel"></a>Cwnd：：鼠标轮上

当用户旋转鼠标滚轮并遇到车轮的下一个切口时，框架将调用此成员函数。

```
afx_msg BOOL OnMouseWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，请设置。

- MK_MBUTTON 如果鼠标中键已关闭，则"设置"。

- MK_RBUTTON 如果鼠标右键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*zDelta*<br/>
指示旋转的距离。 *zDelta*值以WHEEL_DELTA的倍数或分表示，即 120。 小于零的值表示旋转回（向用户），而大于零的值表示向前旋转（远离用户）。 用户可以通过更改鼠标软件中的"滚轮"设置来反转此响应。 有关此参数的详细信息，请参阅备注。

*pt*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于屏幕的左上角。

### <a name="return-value"></a>返回值

启用鼠标滚轮时非零;否则 0。

### <a name="remarks"></a>备注

除非重写，否则`OnMouseWheel`调用默认值[WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel)。 Windows 会自动将消息路由到具有焦点的控件或子窗口。 Win32 函数[DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowprocw)将消息向上传播到处理该消息的窗口。

*zDelta*参数是 WHEEL_DELTA的倍数，设置为 120。 此值是要执行的操作的阈值，每个增量应执行一个此类操作（例如，向前滚动一个凹槽）。

WHEEL_DELTA设置为 120，允许更精细的车轮，如无凹口的自由旋转车轮。 更精细的轮轮每次旋转发送更多消息，但每条消息的增量值较小。 要使用此类滚轮，请添加传入*的 zDelta*值，直到达到WHEEL_DELTA（以便获得给定增量旋转的相同响应），或滚动部分行以响应更频繁的消息。 您还可以选择滚动粒度并累积增量，直到达到WHEEL_DELTA。

重写此成员函数以提供您自己的鼠标滚轮滚动行为。

> [!NOTE]
> `OnMouseWheel`处理 Windows NT 4.0 和更高版本的消息。 对于 Windows 95/98 或 Windows NT 3.51 消息处理，请使用[注册鼠标滚轮](#onregisteredmousewheel)。

## <a name="cwndonmove"></a><a name="onmove"></a>Cwnd：：移动

移动对象后，`CWnd`框架将调用此成员函数。

```
afx_msg void OnMove(
    int x,
    int y);
```

### <a name="parameters"></a>参数

** x <br/>
指定工作区左上角的新 x 坐标位置。 此新位置在重叠窗口和弹出窗口的屏幕坐标中提供，以及子窗口的父客户端坐标。

*Y*<br/>
指定工作区左上角的新 y 坐标位置。 此新位置在重叠窗口和弹出窗口的屏幕坐标中提供，以及子窗口的父客户端坐标。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonmoving"></a><a name="onmoving"></a>Cwnd：：移动

当用户移动`CWnd`对象时，框架将调用此成员函数。

```
afx_msg void OnMoving(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>参数

*n侧*<br/>
要移动的窗口的边缘。

*lpRect*<br/>
包含项坐标的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)的地址。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncactivate"></a><a name="onncactivate"></a>Cwnd：：打开NcActivate

当需要更改非工作区以指示活动或非活动状态时，框架将调用此成员函数。

```
afx_msg BOOL OnNcActivate(BOOL bActive);
```

### <a name="parameters"></a>参数

*b 活动*<br/>
指定何时需要更改标题栏或图标以指示活动或非活动状态。 如果要绘制活动标题或图标，*则 bActive*参数为 TRUE。 对于非活动标题或图标，它是 FALSE。

### <a name="return-value"></a>返回值

如果 Windows 应继续默认处理，则非零;0 以防止标题栏或图标停用。

### <a name="remarks"></a>备注

如果*bActive*为 TRUE，则默认实现以其活动颜色绘制标题栏和标题栏文本，如果*bActive*为 FALSE，则以非活动颜色绘制标题栏和标题栏文本。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnccalcsize"></a><a name="onnccalcsize"></a>Cwnd：：在NcCalcsize上

当需要计算工作区的大小和位置时，框架将调用此成员函数。

```
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,
    NCCALCSIZE_PARAMS* lpncsp);
```

### <a name="parameters"></a>参数

*bCalcValidrects*<br/>
指定应用程序是否应指定工作区的哪个部分包含有效信息。 Windows 将有效信息复制到新工作区中的指定区域。 如果此参数为 TRUE，则应用程序应指定工作区的哪个部分有效。

*lpncsp*<br/>
指向[包含](/windows/win32/api/winuser/ns-winuser-nccalcsize_params)应用程序可用于计算`CWnd`矩形的新大小和位置（包括工作区、边框、标题、滚动条等）的信息NCCALCSIZE_PARAMS数据结构。

### <a name="remarks"></a>备注

通过处理此消息，当窗口的大小或位置发生变化时，应用程序可以控制窗口工作区的内容。

无论*bCalcValidRects*的值如何，`rgrc``NCCALCSIZE_PARAMS`结构结构成员指定的数组中的第一个矩形都包含窗口的坐标。 对于子窗口，坐标相对于父窗口的工作区。 对于顶级窗口，坐标是屏幕坐标。 应用程序应修改`rgrc[0]`矩形以反映工作区的大小和位置。

`rgrc[1]`仅当`rgrc[2]`*bCalcValidRects*为 TRUE 时，和矩形才有效。 在这种情况下，`rgrc[1]`矩形在移动或调整窗口大小之前包含窗口的坐标。 该`rgrc[2]`矩形包含窗口在移动窗口之前工作区的坐标。 所有坐标都相对于父窗口或屏幕。

默认实现根据窗口特征（存在滚动条、菜单等）计算工作区的大小，并将结果放在*lpncsp*中。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnccreate"></a><a name="onnccreate"></a>Cwnd：：OnNcCreate

首次创建`CWnd`对象时，该框架在[WM_CREATE](#oncreate)消息之前调用此成员函数。

```
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>参数

*lpCreatestruct*<br/>
指向 的[CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw)数据`CWnd`结构。

### <a name="return-value"></a>返回值

如果创建了非工作区，则为非零。 如果发生错误，为 0;如果发生错误，则为 0。在这种情况下`Create`，函数将返回**故障**。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncdestroy"></a><a name="onncdestroy"></a>Cwnd：：OnNc销毁

在销毁非工作区时由框架调用，是销毁 Windows 窗口时调用的最后一个成员函数。

```
afx_msg void OnNcDestroy();
```

### <a name="remarks"></a>备注

默认实现执行一些清理，然后调用虚拟成员函数[PostNc销毁](#postncdestroy)。

如果要`PostNcDestroy`执行自己的清理（如**删除此操作**）。请覆盖。 如果重写`OnNcDestroy`，则必须在基`OnNcDestroy`类中调用 以确保释放为窗口在内部分配的任何内存。

## <a name="cwndonnchittest"></a><a name="onnchittest"></a>Cwnd：：OnNcHitTest

框架为每次移动鼠标时包含游`CWnd`标（或使用[SetCapture](#setcapture)成员函数`CWnd`捕获鼠标输入的对象）调用此成员函数。

```
afx_msg LRESULT OnNcHitTest(CPoint point);
```

### <a name="parameters"></a>参数

*点*<br/>
包含光标的 x 坐标和 y 坐标。 这些坐标始终是屏幕坐标。

### <a name="return-value"></a>返回值

鼠标命中测试枚举值之一。 有关值列表，请参阅[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnclbuttondblclk"></a><a name="onnclbuttondblclk"></a>Cwnd：：OnNcLButtonDblClk

当用户双击鼠标左键，而光标位于 的非客户端区域中时，框架将调用此成员函数`CWnd`。

```
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。 有关值列表，请参阅[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

如果合适，将发送[WM_SYSCOMMAND](#onsyscommand)消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnclbuttondown"></a><a name="onnclbuttondown"></a>Cwnd：：OnNcLButtonDown

当用户按下鼠标左键，而光标位于`CWnd`对象的非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcLButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。 有关值列表，请参阅[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

如果合适，将发送[WM_SYSCOMMAND。](#onsyscommand)

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递给函数的参数反映收到消息时框架收到的参数。如果调用此函数的基类实现，则该实现将使用最初随消息传递的参数，而不是向函数供电的参数。

## <a name="cwndonnclbuttonup"></a><a name="onnclbuttonup"></a>Cwnd：：OnNcLButtonUp

当用户释放鼠标左键，而光标位于非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcLButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。 有关值列表，请参阅[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

如果合适，将发送[WM_SYSCOMMAND。](#onsyscommand)

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmbuttondblclk"></a><a name="onncmbuttondblclk"></a>Cwnd：：OnNcMButtonDblClk

当用户双击鼠标中间键，而光标位于非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmbuttondown"></a><a name="onncmbuttondown"></a>Cwnd：：打开按钮

当用户在光标位于非工作区内时按下鼠标中间按钮时，框架将调用此成员函数。

```
afx_msg void OnNcMButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmbuttonup"></a><a name="onncmbuttonup"></a>Cwnd：：OnNcMButtonUp

当用户释放鼠标中间键，而光标位于非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcMButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmousehover"></a><a name="onncmousehover"></a>Cwnd：：在NcMouse悬停

当光标悬停在窗口的非工作区上，在之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的时间段时，框架将调用此成员函数。

```
afx_msg void OnNcMouseHover(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nHitTest*|[在][CWnd：:DefWindowProc](#defwindowproc)函数在处理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息时返回的命中测试值。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于屏幕左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_NCMOUSEHOVER](/windows/win32/inputdev/wm-ncmousehover)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmouseleave"></a><a name="onncmouseleave"></a>Cwnd：：在NcMouseLeave

当光标离开之前调用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的窗口的非工作区时，框架将调用此成员函数。

```
afx_msg void OnNcMouseLeave();
```

### <a name="remarks"></a>备注

此方法接收[WM_NCMOUSELEAVE](/windows/win32/inputdev/wm-ncmouseleave)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncmousemove"></a><a name="onncmousemove"></a>Cwnd：：在NcMouseMove

当游标在非工作区中移动时，框架将调用此成员函数。

```
afx_msg void OnNcMouseMove(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

如果合适，将发送[WM_SYSCOMMAND](#onsyscommand)消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncpaint"></a><a name="onncpaint"></a>Cwnd：onNcPaint

当需要绘制非工作区时，框架将调用此成员函数。

```
afx_msg void OnNcPaint();
```

### <a name="remarks"></a>备注

默认实现绘制窗口框架。

应用程序可以重写此调用并绘制自己的自定义窗口框架。 裁剪区域始终为矩形，即使框架的形状已更改也是如此。

## <a name="cwndonncrbuttondblclk"></a><a name="onncrbuttondblclk"></a>Cwnd：：OnNcRButtonDblClk

当用户双击鼠标右键时，当光标位于 的非客户端区域中时，框架将调用此成员函数`CWnd`。

```
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncrbuttondown"></a><a name="onncrbuttondown"></a>Cwnd：：OnNcRButtonDown

当用户在光标位于非工作区内时按下鼠标右键时，框架将调用此成员函数。

```
afx_msg void OnNcRButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncrbuttonup"></a><a name="onncrbuttonup"></a>Cwnd：：OnNcRButtonUp

当用户释放鼠标右键时，当光标位于非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcRButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>参数

*nHitTest*<br/>
指定[命中测试代码](#onnchittest)。 命中测试是确定光标位置的测试。

*点*<br/>
指定包含`CPoint`光标位置的 x 和 y 屏幕坐标的对象。 这些坐标始终相对于屏幕的左上角。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncrenderingchanged"></a><a name="onncrenderingchanged"></a>Cwnd：：打开呈现

当非工作区的呈现策略发生更改时，框架将调用此成员。

```
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*bIs渲染*|[在]如果为窗口的非工作区启用桌面窗口管理器 （DWM） 呈现，则为 TRUE;如果禁用渲染，则 FALSE。|

### <a name="remarks"></a>备注

此方法接收[WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmncrenderingchanged)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncxbuttondblclk"></a><a name="onncxbuttondblclk"></a>Cwnd：：OnNcXButtonDblClk

当用户双击 XBUTTON1 或 XBUTTON2 时，当用户双击 XBUTTON1 或 XBUTTON2 时，当用户在窗口的非工作区中时，框架将调用此成员函数。

```
void OnNcXButtonDblClk(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nHitTest*|[在][CWnd：:DefWindowProc](#defwindowproc)函数在处理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息时返回的命中测试值。|
|*nButton*|[在]如果双击第一个 Microsoft 智能鼠标 X 按钮，则值为 XBUTTON1;如果双击第二个 X 按钮，则为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk)通知，这在 Windows SDK 中介绍。 此消息将发布到包含光标的窗口。 如果窗口捕获了鼠标，则不会发布此消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncxbuttondown"></a><a name="onncxbuttondown"></a>Cwnd：：OnNcX按钮向下

当用户按下鼠标的 XBUTTON1 或 XBUTTON2 时，当光标位于窗口的非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcXButtonDown(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nHitTest*|[在][CWnd：:DefWindowProc](#defwindowproc)函数在处理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息时返回的命中测试值。|
|*nButton*|[在]如果按下第一个鼠标 X 按钮，则为 XBUTTON1 的值;如果按下第二个 X 按钮，则为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于屏幕左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_NCXBUTTONDOWN](/windows/win32/inputdev/wm-ncxbuttondown)通知，这在 Windows SDK 中介绍。 此消息将发布到包含光标的窗口。 如果窗口捕获了鼠标，则不会发布此消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonncxbuttonup"></a><a name="onncxbuttonup"></a>Cwnd：：OnNcXButtonUp

当用户释放鼠标的 XBUTTON1 或 XBUTTON2 时，当光标位于窗口的非工作区中时，框架将调用此成员函数。

```
afx_msg void OnNcXButtonUp(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nHitTest*|[在][CWnd：:DefWindowProc](#defwindowproc)函数在处理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息时返回的命中测试值。|
|*nButton*|[在]如果释放第一个鼠标 X 按钮，则为 XBUTTON1 的值;如果释放第二个 X 按钮，则为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于屏幕左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_NCXBUTTONUP](/windows/win32/inputdev/wm-ncxbuttonup)通知，这在 Windows SDK 中介绍。 此消息将发布到包含光标的窗口。 如果窗口捕获了鼠标，则不会发布此消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnextmenu"></a><a name="onnextmenu"></a>Cwnd：：上一个菜单

当使用右箭头或左箭头键在菜单栏和系统菜单之间切换时，框架将调用此成员函数。

```
afx_msg void OnNextMenu(
    UINT nKey,
    LPMDINEXTMENU lpMdiNextMenu);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*n键*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。<br /><br /> 有关标志列表，请参阅["关于鼠标输入](/windows/win32/inputdev/about-mouse-input)"中的"消息参数"副标题。|
|*lpMdiNextMenu*|[在]指向包含要激活的菜单信息的[MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu)结构的指针。|

### <a name="remarks"></a>备注

此方法接收[WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup)通知，这在 Windows SDK 中介绍。 为了响应此消息，应用程序可以设置`hmenuNext`[MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu)结构的成员以指定要切换到的菜单，以及指定窗口以接收菜单通知`hwndNext`消息的成员。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonnotify"></a><a name="onnotify"></a>Cwnd：：打开通知

框架调用此成员函数以通知控件的父窗口控件中发生了事件或该控件需要某种信息。

```
virtual BOOL OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>参数

*wParam*<br/>
标识消息来自控件时发送消息的控件。 否则 *，wParam*为 0。

*lParam*<br/>
指向包含通知代码和其他信息`NMHDR`的通知消息 （ ） 结构的指针。 对于某些通知消息，此参数指向具有`NMHDR`结构作为其第一个成员的较大结构。

*pResult*<br/>
指向 LRESULT 变量的指针，在其中存储结果代码（如果消息已处理）。

### <a name="return-value"></a>返回值

如果应用程序处理此消息，则返回非零;否则 0。

### <a name="remarks"></a>备注

`OnNotify`处理消息映射以进行控制通知。

重写派生类中的此成员函数以处理WM_NOTIFY消息。 除非调用基类`OnNotify`，否则重写将不会处理消息映射。

有关WM_NOTIFY消息的详细信息，请参阅技术说明 61 （TN061）、ON_NOTIFY[和WM_NOTIFY消息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您可能还对[控件主题](../../mfc/controls-mfc.md)和 TN062"Windows[控件的消息反射"](../../mfc/tn062-message-reflection-for-windows-controls.md)中描述的相关主题感兴趣。

## <a name="cwndonnotifyformat"></a><a name="onnotifyformat"></a>Cwnd：：打开Notify格式

框架调用此成员函数以确定当前窗口是否接受WM_NOTIFY通知消息中的 ANSI 或 Unicode 结构。

```
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,
    UINT nCommand);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pwnd*|[在]指向表示发送`CWnd`[WM_NOTIFY](/windows/win32/controls/wm-notify)消息的窗口的对象的指针。<br /><br /> 如果*nCommand*参数NF_QUERY，则此参数是指向控件的指针，或者指向控件的父窗口（如果*nCommand* NF_REQUERY则指向控件的父窗口的指针）。|
|*nCommand*|[在]专门化WM_NOTIFY消息的命令值。 可能的值包括：<br /><br /> - NF_QUERY -<br />     该消息是确定是否应在WM_NOTIFY消息中使用 ANSI 或 Unicode 结构的查询。 在创建控件期间，此消息从控件发送到其父窗口，并响应此消息的NF_REQUERY形式。<br />- NF_REQUERY -<br />     该消息是控件向其父窗口发送此消息NF_QUERY形式的请求。 此请求从父窗口发送，并要求控件重新查询父级WM_NOTIFY消息中要使用的结构类型。 如果*nCommand*参数NF_REQUERY，则返回值是重新查询操作的结果。|

### <a name="return-value"></a>返回值

|返回值|含义|
|------------------|-------------|
|NFR_ANSI|ANSI 结构应用于控件发送WM_NOTIFY消息。|
|NFR_UNICODE|Unicode 结构应用于控件发送WM_NOTIFY消息。|
|0|出现了错误。|

### <a name="remarks"></a>备注

此方法接收[WM_NOTIFYFORMAT](/windows/win32/Controls/wm-notifyformat)通知，这在 Windows SDK 中介绍。 WM_NOTIFY消息从公共控件发送到其父窗口，从父窗口发送到公共控件。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonpaint"></a><a name="onpaint"></a>Cwnd：：上漆

当 Windows 或应用程序发出重新绘制应用程序窗口的一部分的请求时，框架将调用此成员函数。

```
afx_msg void OnPaint();
```

### <a name="remarks"></a>备注

调用["更新窗口](#updatewindow)"或["重绘窗口](#redrawwindow)"成员函数时，将发送[WM_PAINT](/windows/win32/gdi/the-wm-paint-message)消息。

窗口可能会接收内部绘制消息，因为使用RDW_INTERNALPAINT标志集调用`RedrawWindow`成员函数。 在这种情况下，窗口可能没有更新区域。 应用程序应调用[GetUpdateRect](#getupdaterect)成员函数以确定窗口是否具有更新区域。 如果`GetUpdateRect`返回 0，则应用程序不应调用[BeginPaint](#beginpaint)和[EndPaint](#endpaint)成员函数。

应用程序有责任通过查看每个WM_PAINT消息的内部数据结构来检查任何必要的内部重新绘制或更新，因为WM_PAINT消息可能是由无效区域和使用RDW_INTERNALPAINT标志集的成员`RedrawWindow`函数调用引起的。

内部WM_PAINT消息仅由 Windows 发送一次。 在`UpdateWindow`成员函数将内部WM_PAINT消息发送到窗口后，在窗口失效或使用RDW_INTERNALPAINT标志集再次调用`RedrawWindow`成员函数之前，不会再发送或发布任何WM_PAINT消息。

有关在文档/视图应用程序中渲染图像的信息，请参阅[CView：：：OnDraw](../../mfc/reference/cview-class.md#ondraw)。

有关使用`WM_Paint`的详细信息，请参阅 Windows SDK 中的以下主题：

- [WM_PAINT消息](/windows/win32/gdi/the-wm-paint-message)

- [使用WM_PAINT消息](/windows/win32/gdi/using-the-wm-paint-message)

## <a name="cwndonpaintclipboard"></a><a name="onpaintclipboard"></a>Cwnd：：在画夹板上

当剪贴板所有者以`OnPaintClipboard`CF_OWNERDISPLAY格式在剪贴板上放置数据且剪贴板查看器的工作区需要重新绘制时，剪贴板所有者的成员函数由剪贴板查看器调用。

```
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hPaintStruct);
```

### <a name="parameters"></a>参数

*pClipAppwnd*<br/>
指定指向剪贴板应用程序窗口的指针。 该指针可能是暂时的，不应存储起来供将来使用。

*hPaintStruct*<br/>
标识一个 [PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct) 数据结构，该数据结构可定义要绘制的工作区部分。

### <a name="remarks"></a>备注

要确定整个工作区或其中的一部分是否需要重新绘制，剪贴板所有者必须将`rcpaint``PAINTSTRUCT`结构成员中给出的绘图区域的尺寸与最近的[OnSizeClipboard](#onsizeclipboard)成员函数调用中给出的尺寸进行比较。

`OnPaintClipboard`应使用[GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) Windows 函数锁定包含`PAINTSTRUCT`数据结构的内存，并在该内存退出之前使用[全局解锁](/windows/win32/api/winbase/nf-winbase-globalunlock)Windows 功能解锁该内存。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonpalettechanged"></a><a name="onpalettechanged"></a>Cwnd：：打开调色板

在具有输入焦点的窗口实现其逻辑调色板后，框架将此成员函数调用所有顶级窗口，从而更改系统调色板。

```
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```

### <a name="parameters"></a>参数

*pFocusWnd*<br/>
指定指向导致系统调色板更改的窗口的指针。 指针可能是临时的，不应存储。

### <a name="remarks"></a>备注

此调用允许没有使用调色板的输入焦点的窗口来实现其逻辑调色板并更新其工作区。

对于`OnPaletteChanged`所有顶级和重叠窗口（包括更改系统调色板并导致发送WM_PALETTECHANGED消息的窗口，将调用成员函数。 如果任何子窗口使用调色板，则必须将此消息传递给它。

为了避免无限循环，窗口不应实现其调色板，除非它确定*pFocusWnd*不包含指向自身的指针。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonpaletteischanging"></a><a name="onpaletteischanging"></a>Cwnd：：在Paletteis改变

该框架调用此成员函数，通知应用程序将实现其逻辑调色板。

```
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```

### <a name="parameters"></a>参数

*p实现*<br/>
指定即将实现其逻辑调色板的窗口。

### <a name="remarks"></a>备注

框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonparentnotify"></a><a name="onparentnotify"></a>Cwnd：：在家长通知

当创建或销毁`OnParentNotify`父成员窗口时，或者当用户单击鼠标按钮时光标位于子窗口上时，框架将调用父成员函数。

```
afx_msg void OnParentNotify(
    UINT message,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定通知父级的事件以及子窗口的标识符。 该事件是低阶*消息*词。 如果事件是WM_CREATE或WM_DESTROY，则高阶*消息*词是子窗口的标识符;如果事件是WM_DESTROY，则消息的显示值是子窗口的标识符。否则，高阶单词未定义。 事件（低阶*消息*字）可以是以下任一值：

- WM_CREATE正在创建子窗口。

- WM_DESTROY子窗口正在销毁。

- WM_LBUTTONDOWN 用户将鼠标光标放在子窗口上并单击鼠标左键。

- WM_MBUTTONDOWN 用户将鼠标光标放在子窗口上并单击鼠标中间按钮。

- WM_RBUTTONDOWN 用户将鼠标光标放在子窗口上并单击右鼠标按钮。

*lParam*<br/>
如果消息的事件（低阶字）WM_CREATE或WM_DESTROY，*则 lParam*指定子窗口的窗口句柄;如果*消息*的事件（低阶字）WM_CREATE或WM_DESTROY，则指定子窗口的窗口句柄。否则*lParam*包含光标的 x 和 y 坐标。 x 坐标位于低阶单词中，y 坐标位于高阶单词中。

### <a name="remarks"></a>备注

创建子窗口时，系统将在创建窗口的`OnParentNotify`["创建](#create)成员"函数返回之前调用。 销毁子窗口时，系统在进行任何处理之前调用`OnParentNotify`以销毁窗口。

`OnParentNotify`为子窗口的所有祖先窗口（包括顶层窗口）调用。

除具有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)样式的所有子窗口外，所有子窗口都向其父窗口发送此消息。 默认情况下，对话框中的子窗口具有WS_EX_NOPARENTNOTIFY样式，除非通过调用[CreateEx](#createex)成员函数在没有此样式的情况下创建子窗口。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonpowerbroadcast"></a><a name="onpowerbroadcast"></a>Cwnd：：在电力广播

当发生电源管理事件时，框架将调用此成员函数。

```
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,
    UINT nEventData);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nPower事件*|[在]电源管理事件。|
|*n事件数据*|[在]特定于事件的数据。|

### <a name="return-value"></a>返回值

如果事件是请求，请返回 TRUE 以授予请求，或BROADCAST_QUERY_DENY拒绝请求。

### <a name="remarks"></a>备注

此方法接收[WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast)消息，这在 Windows SDK 中介绍。

*nPowerEvent*参数指定事件，如电池电量不足、电源状态已更改、请求或拒绝挂起操作权限、事件发生后操作自动恢复、系统正在暂停操作或挂起后正在恢复操作。 *nEventData*参数通常不使用。 有关详细信息，请参阅[WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast)消息的*wParam*和*lParam*参数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonquerydragicon"></a><a name="onquerydragicon"></a>Cwnd：：上查询德拉吉肯

框架通过没有为其类定义的图标的最小化（标志性）窗口调用此成员函数。

```
afx_msg HCURSOR OnQueryDragIcon();
```

### <a name="return-value"></a>返回值

包含低阶单词中的光标或图标句柄的双字值。 光标或图标必须与显示驱动程序的分辨率兼容。 如果应用程序返回 NULL，系统将显示默认光标。 默认返回值为 NULL。

### <a name="remarks"></a>备注

系统进行此调用以获取在用户拖动最小化窗口时显示的光标。 如果应用程序返回图标或光标的句柄，系统将转换为黑白。 如果应用程序返回句柄，句柄必须标识与显示驱动程序分辨率兼容的单色光标或图标。 应用程序可以调用[CWinApp：：LoadCursor 或](../../mfc/reference/cwinapp-class.md#loadcursor) [CWinApp：LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon)成员函数，以从其可执行文件中的资源加载光标或图标，并获取此句柄。

## <a name="cwndonqueryendsession"></a><a name="onqueryendsession"></a>Cwnd：：在查询结束会话

当用户选择结束 Windows 会话或应用程序调用[ExitWindows Windows](/windows/win32/api/winuser/nf-winuser-exitwindows)函数时，框架将调用此成员函数。

```
afx_msg BOOL OnQueryEndSession();
```

### <a name="return-value"></a>返回值

如果应用程序可以方便地关闭，则非零;否则 0。

### <a name="remarks"></a>备注

如果任何应用程序返回 0，则 Windows 会话不会结束。 一旦一`OnQueryEndSession`个应用程序返回 0，Windows 就会停止调用，并且为任何已返回非零的应用程序发送参数值为 FALSE[的WM_ENDSESSION](#onendsession)消息。

## <a name="cwndonquerynewpalette"></a><a name="onquerynewpalette"></a>Cwnd：：打开查询新调色板

当对象即将接收输入焦点时，`CWnd`框架将调用此成员函数，从而`CWnd`有机会在接收焦点时实现其逻辑调色板。

```
afx_msg BOOL OnQueryNewPalette();
```

### <a name="return-value"></a>返回值

如果实现其逻辑`CWnd`调色板，则非零;否则 0。

## <a name="cwndonqueryopen"></a><a name="onqueryopen"></a>Cwnd：：打开查询打开

当`CWnd`对象最小化，并且用户要求将 该成员还原到其预最小化的大小和位置`CWnd`时，框架将调用此成员函数。

```
afx_msg BOOL OnQueryOpen();
```

### <a name="return-value"></a>返回值

如果可以打开图标，则为非零，或 0 以防止打开图标。

### <a name="remarks"></a>备注

在`OnQueryOpen`中`CWnd`时不应执行任何会导致激活或焦点更改的操作（例如，创建对话框）。

## <a name="cwndonqueryuistate"></a><a name="onqueryuistate"></a>Cwnd：：在查询

调用以检索窗口的用户界面 (UI) 状态。

```
afx_msg UINT OnQueryUIState();
```

### <a name="return-value"></a>返回值

如果焦点指示器和键盘快捷键可见，则返回值为 NULL。 否则，返回值可以是以下一个或多个值：

- UISF_HIDEFOCUS焦点指示灯处于隐藏状态。

- UISF_HIDEACCEL键盘加速器是隐藏的。

- UISF_ACTIVE Windows XP：控件应以用于活动控件的样式绘制。

### <a name="remarks"></a>备注

此成员函数模拟[WM_QUERYUISTATE](/windows/win32/menurc/wm-queryuistate)消息的功能，如 Windows SDK 中所述。

## <a name="cwndonrawinput"></a><a name="onrawinput"></a>Cwnd：：OnRawInput

当当前窗口获取原始输入时，框架将调用此成员函数。

```
afx_msg void OnRawInput(
    UINT nInputCode,
    HRAWINPUT hRawInput);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nInput代码*|[在]指示输入是否发生在应用程序在前台时发生的输入代码。 在这两种情况下，应用程序都必须调用[CWnd：:DefWindowProc，](#defwindowproc)以便系统可以执行清理。<br /><br /> 此参数可以是以下值之一：<br /><br /> - RIM_INPUT - 在应用程序在前台时发生输入。<br />- RIM_INPUTSINK - 当应用程序不在前台时发生输入。|
|*hRawInput*|[在]处理包含设备原始输入的[RAWINPUT](/windows/win32/api/winuser/ns-winuser-rawinput)结构。|

### <a name="remarks"></a>备注

此方法接收[WM_INPUT](/windows/win32/inputdev/wm-appcommand)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonrbuttondblclk"></a><a name="onrbuttondblclk"></a>克隆：：OnRButtonDblClk

当用户双击鼠标右键时，框架将调用此成员函数。

```
afx_msg void OnRButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，则"设置"。

- MK_MBUTTON 如果鼠标中键已关闭，请设置。

- MK_RBUTTON 如果鼠标右键已关闭，则"设置"。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

只有具有 CS_DBLCLKS [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw)样式的窗口才能`OnRButtonDblClk`接收呼叫。 这是 Microsoft 基础类库中窗口的默认值。 当用户按下`OnRButtonDblClk`、释放时，Windows 会调用，然后在系统的双击时间限制内再次按下鼠标右键。 双击鼠标右键实际上会生成四个事件[：WM_RBUTTONDOWN](#onrbuttondown)和[WM_RBUTTONUP](#onrbuttonup)消息、`OnRButtonDblClk`呼叫，以及释放该按钮时的另一个WM_RBUTTONUP消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonrbuttondown"></a><a name="onrbuttondown"></a>Cwnd：：OnRButtonDown

当用户按下鼠标右键时，框架将调用此成员函数。

```
afx_msg void OnRButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，则"设置"。

- MK_MBUTTON 如果鼠标中键已关闭，请设置。

- MK_RBUTTON 如果鼠标右键已关闭，则"设置"。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonrbuttonup"></a><a name="onrbuttonup"></a>Cwnd：：OnRButtonUp

当用户释放鼠标右键时，框架将调用此成员函数。

```
afx_msg void OnRButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指示各种虚拟密钥是否关闭。 此参数可以是以下值的任意组合：

- MK_CONTROL 如果 CTRL 密钥已关闭，则设置。

- MK_LBUTTON 如果鼠标左键已关闭，则"设置"。

- MK_MBUTTON 如果鼠标中键已关闭，请设置。

- MK_SHIFT 如果 SHIFT 键已关闭，则设置。

*点*<br/>
指定光标的 x 和 y 坐标。 这些坐标始终相对于窗口的左上角。

### <a name="remarks"></a>备注

框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonregisteredmousewheel"></a><a name="onregisteredmousewheel"></a>Cwnd：：注册鼠标轮

当用户旋转鼠标滚轮并遇到车轮的下一个切口时，框架将调用此成员函数。

```
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*wParam*<br/>
指针的水平位置。

*lParam*<br/>
指针的垂直位置。

### <a name="return-value"></a>返回值

此时微不足道。 总是为零。

### <a name="remarks"></a>备注

除非重写，否则`OnRegisteredMouseWheel`将消息路由到相应的窗口（具有焦点的父窗口），并调用该窗口[的WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel)处理程序。

重写此成员函数以提供您自己的消息路由或更改鼠标滚轮滚动行为。

> [!NOTE]
> `OnRegisteredMouseWheel`处理 Windows 95/98 和 Windows NT 3.51 的消息。 对于 Windows NT 4.0 消息处理，请使用[鼠标滚轮](#onmousewheel)。

## <a name="cwndonrenderallformats"></a><a name="onrenderallformats"></a>Cwnd：：在渲染所有格式

当所有者应用程序被销毁时`OnRenderAllFormats`，框架将调用剪贴板所有者的成员函数。

```
afx_msg void OnRenderAllFormats();
```

### <a name="remarks"></a>备注

剪贴板所有者应以它能够生成所有格式的数据呈现数据，并通过调用[SetClipboard 数据](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 函数将每种格式的数据句柄传递给剪贴板。 这可确保剪贴板包含有效数据，即使呈现数据的应用程序已销毁。 应用程序在调用[SetClipboard 数据](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 功能之前应调用[OpenClipboard](#openclipboard)成员函数，并在之后调用[CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) Windows 功能。

## <a name="cwndonrenderformat"></a><a name="onrenderformat"></a>Cwnd：：在渲染格式上

当需要渲染具有延迟`OnRenderFormat`呈现的特定格式时，框架将调用剪贴板所有者的成员函数。

```
afx_msg void OnRenderFormat(UINT nFormat);
```

### <a name="parameters"></a>参数

*nFormat*<br/>
指定剪贴板格式。

### <a name="remarks"></a>备注

接收方应以该格式呈现数据，并通过调用[SetClipboard 数据](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 功能将其传递给剪贴板。

不要从 调用`OpenClipboard`成员函数或`CloseClipboard`Windows 函数`OnRenderFormat`。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsessionchange"></a><a name="onsessionchange"></a>Cwnd：：会话更改

框架调用此成员函数以通知应用程序会话状态的更改。

```
afx_msg void OnSessionChange(
    UINT nSessionState,
    UINT nId);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*n 会话状态*|[在]状态代码描述会话状态更改。|
|*nId*|[在]会话标识符。|

### <a name="remarks"></a>备注

此方法接收[WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change)通知，这在 Windows SDK 中介绍。

*nSessionState*参数指定会话已连接或断开与控制台或远程终端的连接、用户登录或关闭、会话锁定或解锁或会话已更改为远程控制状态。 有关详细信息，请参阅[WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change)消息的*wParam*参数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsetcursor"></a><a name="onsetcursor"></a>Cwnd：：打开游标

如果未捕获鼠标输入，并且鼠标导致`CWnd`对象内的光标移动，则框架将调用此成员函数。

```
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
指定指向包含光标的窗口的指针。 该指针可能是暂时的，不应存储起来供将来使用。

*nHitTest*<br/>
指定[命中测试](#onnchittest)区域代码。 命中测试确定光标的位置。

*消息*<br/>
指定鼠标消息编号。

### <a name="return-value"></a>返回值

非零停止进一步处理，或 0 继续。

### <a name="remarks"></a>备注

默认实现在处理`OnSetCursor`之前调用父窗口。 如果父窗口返回 TRUE，则停止进一步处理。 调用父窗口可使父窗口控制子窗口中的光标设置。

如果游标不在工作区中，则默认实现将游标设为箭头，如果游标不在工作区，则将其设为已注册类游标（如果为）。

如果*nHitTest*是 HTERROR，*并且消息*是鼠标按钮消息，`MessageBeep`则调用成员函数。

进入菜单模式时`CWnd`*，消息*参数为 0。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsetfocus"></a><a name="onsetfocus"></a>Cwnd：：打开焦点

获得输入焦点后，框架将调用此成员函数。

```
afx_msg void OnSetFocus(CWnd* pOldWnd);
```

### <a name="parameters"></a>参数

*普奥德恩德*<br/>
包含丢失输入`CWnd`焦点的对象（可能是 NULL）。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

要显示 care，`CWnd`此时应调用相应的加贴函数。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsettingchange"></a><a name="onsettingchange"></a>Cwnd：：打开设置更改

当 Win32 系统参数信息函数更改系统范围设置时，该框架将调用`OnSettingChange`所有顶级窗口。

```
afx_msg void OnSettingChange(
    UINT uFlags,
    LPCTSTR lpszSection);
```

### <a name="parameters"></a>参数

*uFlags*<br/>
当系统通过`SystemParametersInfo`调用发送消息时，此参数是指示已更改的系统参数的标志。 有关值列表，请参阅 Windows SDK 中的[系统参数信息](/windows/win32/api/winuser/nf-winuser-systemparametersinfow)。 当应用程序发送消息时，此参数必须为 0。

*lpsz节*<br/>
指向指定已更改的节的名称的字符串。 （字符串不包括包含节名称的方括号。

### <a name="remarks"></a>备注

应用程序应在更改系统参数时将消息发送到所有顶级窗口，如果用户通过"控制面板"更改设置，Windows 将发送消息。

ON_WM_SETTINGCHANGE消息类似于ON_WM_WININICHANGE消息，有以下区别：

- 在运行 Windows NT 4.0 或更新时或在 Windows 95/98 下使用ON_WM_SETTINGCHANGE。

- 运行 Windows NT 3.51 或更旧时使用ON_WININICHANGE。 此消息现已过时。

消息映射中应只有其中一个宏。 要编写适用于 Windows 95/98 和 Windows NT 4.0 的程序，请为ON_WM_SETTINGCHANGE编写处理程序。 在 Windows NT 3.51 下，处理程序`OnSettingChange`将被和*uFlags*调用，并且始终为零。

## <a name="cwndonshowwindow"></a><a name="onshowwindow"></a>Cwnd：：在显示窗口

当对象即将被隐藏或显示时`CWnd`，框架将调用此成员函数。

```
afx_msg void OnShowWindow(
    BOOL bShow,
    UINT nStatus);
```

### <a name="parameters"></a>参数

*b显示*<br/>
指定是否显示窗口。 如果显示窗口，则为 TRUE;如果显示窗口，则为 TRUE。如果窗口被隐藏，则为 FALSE。

*n状态*<br/>
指定显示的窗口的状态。 如果消息是因`ShowWindow`成员函数调用而发送的，则为 0;如果消息是因成员函数调用而发送的，则为 0。否则*nStatus*是以下原因之一：

- SW_PARENTCLOSING父窗口正在关闭（成为标志性窗口）或弹出窗口被隐藏。

- SW_PARENTOPENING父窗口正在打开（正在显示）或显示弹出窗口。

### <a name="remarks"></a>备注

当调用`ShowWindow`成员函数时，当重叠窗口最大化或还原时，或者当重叠或弹出窗口关闭（成为标志性窗口）或打开（显示在屏幕上）时，窗口将隐藏或显示。 关闭重叠窗口时，将隐藏与该窗口关联的所有弹出窗口。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsize"></a><a name="onsize"></a>Cwnd：：打开尺寸

窗口大小更改后，框架将调用此成员函数。

```
afx_msg void OnSize(
    UINT nType,
    int cx,
    int cy);
```

### <a name="parameters"></a>参数

nType**<br/>
指定大小调整请求的类型。 此参数可以是以下值之一：

- SIZE_MAXIMIZED窗口已最大化。

- SIZE_MINIMIZED窗口已最小化。

- SIZE_RESTORED窗口已调整大小，但SIZE_MINIMIZED和SIZE_MAXIMIZED均不适用。

- SIZE_MAXHIDE消息在最大化其他窗口时发送到所有弹出窗口。

- SIZE_MAXSHOW消息将发送到所有弹出窗口时，一些其他窗口已恢复到其以前的大小。

*残雪*<br/>
指定工作区的新宽度。

*cy*<br/>
指定工作区的新高度。

### <a name="remarks"></a>备注

如果为 中的`OnSize`子窗口调用[SetScrollPos](#setscrollpos)或[MoveWindow](#movewindow)成员函数`bRedraw`，`SetScrollPos`则`MoveWindow`中的 参数应为 或`CWnd`应为非零，以便重新绘制 。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]

## <a name="cwndonsizeclipboard"></a><a name="onsizeclipboard"></a>Cwnd：：在尺寸上夹板

当剪贴板包含具有`OnSizeClipboard``CF_OWNERDISPLAY`属性的数据且剪贴板查看器窗口的工作区大小已更改时，剪贴板所有者的成员函数由剪贴板查看器调用。

```
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hRect);
```

### <a name="parameters"></a>参数

*pClipAppwnd*<br/>
标识剪贴板应用程序窗口。 指针可能是临时的，不应存储。

*hRect*<br/>
标识全局内存对象。 内存对象包含 RECT 数据结构，该结构指定剪贴板所有者要绘制的区域。

### <a name="remarks"></a>备注

当`OnSizeClipboard`剪贴板应用程序即将被销毁或最小化时，成员函数使用空矩形 （0，0，0，0） 作为新大小调用。 这允许剪贴板所有者释放其显示资源。

在`OnSizeClipboard`中，应用程序必须使用[GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) Windows 函数来锁定包含 RECT 数据结构的内存。 让应用程序在生成或返回控件之前，使用[全局解锁](/windows/win32/api/winbase/nf-winbase-globalunlock)Windows 功能解锁该内存。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsizing"></a><a name="onsizing"></a>Cwnd：：打开

框架调用此成员函数以指示用户调整矩形大小。

```
afx_msg void OnSizing(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>参数

*n侧*<br/>
要移动的窗口的边缘。

*lpRect*<br/>
包含项坐标的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)的地址。

### <a name="remarks"></a>备注

通过处理此消息，应用程序可以监视拖动矩形的大小和位置，并在必要时更改其大小或位置。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]

## <a name="cwndonspoolerstatus"></a><a name="onspoolerstatus"></a>Cwnd：：打开器状态

每当作业添加到打印管理器队列或从打印管理器队列中删除时，框架都会从打印管理器调用此成员函数。

```
afx_msg void OnSpoolerStatus(
    UINT nStatus,
    UINT nJobs);
```

### <a name="parameters"></a>参数

*n状态*<br/>
指定SP_JOBSTATUS标志。

*n工作*<br/>
指定打印管理器队列中剩余的作业数。

### <a name="remarks"></a>备注

此呼叫仅供参考。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonstylechanged"></a><a name="onstylechanged"></a>Cwnd：：打开样式

[在 SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw)函数更改了一个或多个窗口的样式后，框架将调用此成员函数。

```
afx_msg void OnStyleChanged(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>参数

*n样式类型*<br/>
指定窗口的扩展样式或非扩展样式是否已更改。 此参数可以是以下值的组合：

- GWL_EXSTYLE 窗口的扩展样式已更改。

- GWL_STYLE 窗口的非扩展样式已更改。

*lpStylestruct*<br/>
指向包含窗口新样式的[STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct)结构。 应用程序可以检查样式，但不能更改它们。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonstylechanging"></a><a name="onstylechanging"></a>Cwnd：：打开样式

当[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw)函数即将更改窗口的一个或多个样式时，框架将调用此成员函数。

```
afx_msg void OnStyleChanging(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>参数

*n样式类型*<br/>
指定窗口的扩展样式或非扩展样式是否已更改。 此参数可以是以下值的组合：

- GWL_EXSTYLE 窗口的扩展样式已更改。

- GWL_STYLE 窗口的非扩展样式已更改。

*lpStylestruct*<br/>
指向包含窗口新样式的[STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct)结构。 应用程序可以检查样式并更改它们。

### <a name="remarks"></a>备注

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsyschar"></a><a name="onsyschar"></a>Cwnd：：OnSysChar

如果`CWnd`具有输入焦点并翻译[WM_SYSKEYUP](#onsyskeyup)和[WM_SYSKEYDOWN](#onsyskeydown)消息，则框架将调用此成员函数。

```
afx_msg void OnSysChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定控制菜单键的 ASCII 字符密钥代码。

*恩雷普森特*<br/>
指定重复计数（由于用户按住键而重复击键的次数）。

*nFlags*<br/>
*nFlags*参数可以具有以下值：

|“值”|含义|
|-----------|-------------|
|0-15|指定重复计数。 该值是用户按住键而重复击键的次数。|
|16-23|指定扫描代码。 该值取决于原始设备制造商 （OEM）|
|24|指定该键是否是扩展键，例如显示在增强型 101 键或 102 键键盘上的右侧 ALT 和 CTRL 键。 如果值是扩展键，则值为 1;如果该值是扩展键，则该值为 1。否则，它是 0。|
|25-28|Windows 在内部使用。|
|29|指定上下文代码。 按下键时按住 ALT 键，则该值为 1;否则，该值为 0。|
|30|指定以前的键状态。 如果键在发送消息之前向下，则值为 1;如果键向上，则值为 0。|
|31|指定转换状态。 如果释放键，则值为 1;如果按下该键，则该值为 0。|

### <a name="remarks"></a>备注

它指定控制菜单键的虚拟密钥代码。 （有关标准虚拟密钥代码的列表，请参阅 Winuser.h）

当上下文代码为 0 时，WM_SYSCHAR可以将[WM_SYSCHAR](/windows/win32/menurc/wm-syschar)消息传递给[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函数，该函数将像处理正常键消息而不是系统字符键一样处理该函数。 这允许将快捷键与活动窗口一起使用，即使活动窗口没有输入焦点也是如此。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsyscolorchange"></a><a name="onsyscolorchange"></a>Cwnd：：OnSys颜色变化

当系统颜色设置发生更改时，框架会为所有顶级窗口调用此成员函数。

```
afx_msg void OnSysColorChange();
```

### <a name="remarks"></a>备注

Windows`OnSysColorChange`调用受系统颜色更改影响的任何窗口。

具有使用现有系统颜色的画笔的应用程序应删除这些画笔，并使用新的系统颜色重新创建它们。

## <a name="cwndonsyscommand"></a><a name="onsyscommand"></a>Cwnd：：OnSys命令

当用户从"控制"菜单中选择命令或用户选择"最大化"或"最小化"按钮时，框架将调用此成员函数。

```
afx_msg void OnSysCommand(
    UINT nID,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*nID*<br/>
指定请求的系统命令的类型。 此参数可以是以下任一值：

- SC_CLOSE关闭`CWnd`对象。

- SC_HOTKEY激活与`CWnd`应用程序指定的热键关联的对象。 *lParam*的低阶字标识要激活的窗口的 HWND。

- SC_HSCROLL水平滚动。

- SC_KEYMENU通过击键检索菜单。

- SC_MAXIMIZE（或SC_ZOOM）最大化`CWnd`对象。

- SC_MINIMIZE（或SC_ICON）最小化`CWnd`对象。

- SC_MOUSEMENU通过鼠标单击检索菜单。

- SC_MOVE 移动`CWnd`对象。

- SC_NEXTWINDOW移动到下一个窗口。

- SC_PREVWINDOW移动到上一个窗口。

- SC_RESTORE 将窗口还原到正常位置和大小。

- SC_SCREENSAVE执行 SYSTEM [启动] 部分中指定的屏幕保护程序应用程序。INI 文件。

- SC_SIZE 大小`CWnd`对象。

- SC_TASKLIST 执行或激活 Windows 任务管理器应用程序。

- SC_VSCROLL垂直滚动。

*lParam*<br/>
如果使用鼠标选择了"控制菜单"命令，则*lParam*包含光标坐标。 低阶单词包含 x 坐标，高阶单词包含 y 坐标。 否则，不使用此参数。

- SC_HOTKEY激活与应用程序指定的热键关联的窗口。 *lParam*的低阶字标识要激活的窗口。

- SC_SCREENSAVE 执行"控制面板桌面"部分中指定的屏幕保存应用程序。

### <a name="remarks"></a>备注

默认情况下，`OnSysCommand`对上表中指定的预定义操作执行控制菜单请求。

在WM_SYSCOMMAND消息中，Windows 在内部使用*nID*参数的四个低阶位。 当应用程序测试*nID*的值时，它必须使用位-AND 运算符将值 0xFFF0 与*nID*值合并，以获得正确的结果。

可以使用`GetSystemMenu`、、`AppendMenu``InsertMenu`和`ModifyMenu`成员函数修改"控件"菜单项。 修改"控制"菜单的应用程序必须处理WM_SYSCOMMAND消息，并且应用程序未处理的任何WM_SYSCOMMAND消息都必须传递给`OnSysCommand`。 应用程序添加的任何命令值必须由应用程序处理，不能传递给`OnSysCommand`。

应用程序可以通过将WM_SYSCOMMAND消息传递到`OnSysCommand`，随时执行任何系统命令。

定义为从"控制"菜单中选择项的加速器（快捷方式）击键将转换为`OnSysCommand`调用;所有其他加速器击键将转换为[WM_COMMAND](#oncommand)消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsysdeadchar"></a><a name="onsysdeadchar"></a>Cwnd：：OnsysDeadchar

如果调用[OnSysKeyUp 或 OnSysKeyDown](#onsyskeyup)成员函数时对象具有[OnSysKeyDown](#onsyskeydown)输入焦点，`CWnd`则框架将调用此成员函数。

```
afx_msg void OnSysDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定死键字符值。

*恩雷普森特*<br/>
指定重复计数。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|含义|
|-----------|-------------|
|0-7|扫描代码（与 OEM 相关的值）。 高阶字的低字节。|
|8|扩展键，如功能键或数字键盘上的键（1，如果它是扩展键;否则为 0）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1;否则为 0）。|
|14|上一个键状态（如果键在调用之前关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

### <a name="remarks"></a>备注

它指定死密钥的字符值。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsyskeydown"></a><a name="onsyskeydown"></a>Cwnd：：OnsysKeyDown

如果`CWnd`对象具有输入焦点，则当用户按下`OnSysKeyDown`ALT 键然后按下另一个键时，框架将调用成员函数。

```
afx_msg void OnSysKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定要按下的密钥的虚拟密钥代码。 有关标准虚拟密钥代码的列表，请参阅 Winuser.h

*恩雷普森特*<br/>
指定重复计数。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|含义|
|-----------|-------------|
|0-7|扫描代码（与 OEM 相关的值）。 高阶字的低字节。|
|8|扩展键，如功能键或数字键盘上的键（1，如果它是扩展键;否则为 0）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1，否则为 0）。|
|14|以前的键状态（如果密钥在发送消息之前已关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

对于`OnSysKeyDown`呼叫，键转换位（位 15）为 0。 如果按下键时 ALT 键关闭，则上下文代码位（位 13）为 1;如果消息发送到活动窗口，则为 0，因为没有窗口具有输入焦点。

### <a name="remarks"></a>备注

如果当前没有窗口具有输入焦点，则调用活动窗口的成员`OnSysKeyDown`函数。 接收`CWnd`消息的对象可以通过在 中`nFlags`检查上下文代码来区分这两个上下文。

当上下文代码为 0 时，接收`OnSysKeyDown`WM_SYSKEYDOWN消息可以传递到[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函数，该函数将像处理正常密钥消息而不是系统键消息一样处理它。 这允许将快捷键与活动窗口一起使用，即使活动窗口没有输入焦点也是如此。

由于自动重复，在收到[WM_SYSKEYUP](#onsyskeyup)消息之前`OnSysKeyDown`，可能会发生多个调用。 以前的键状态（位 14）可用于确定`OnSysKeyDown`调用是指示第一个向下转换还是重复向下转换。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonsyskeyup"></a><a name="onsyskeyup"></a>Cwnd：：onsysKeyup

如果`CWnd`对象具有焦点，则当用户释放`OnSysKeyUp`在 ALT 键按住时按下的键时，框架将调用成员函数。

```
afx_msg void OnSysKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定要按下的密钥的虚拟密钥代码。 有关标准虚拟密钥代码的列表，请参阅 Winuser.h

*恩雷普森特*<br/>
指定重复计数。

*nFlags*<br/>
指定扫描代码、密钥转换代码、以前的密钥状态和上下文代码，如以下列表所示：

|“值”|含义|
|-----------|-------------|
|0-7|扫描代码（与 OEM 相关的值）。 高阶字的低字节。|
|8|扩展键，如功能键或数字键盘上的键（1，如果它是扩展键;否则为 0）。|
|9-10|未使用。|
|11-12|Windows 在内部使用。|
|13|上下文代码（如果按下键时按住 ALT 键，则为 1，否则为 0）。|
|14|以前的键状态（如果密钥在发送消息之前已关闭，则为 0，如果键已打开，则为 0）。|
|15|转换状态（如果释放键，为 1，则为 0，如果按下键，则为 0）。|

对于`OnSysKeyUp`呼叫，密钥转换位（位 15）为 1。 如果按下键时 ALT 键关闭，则上下文代码位（位 13）为 1;如果消息发送到活动窗口，则为 0，因为没有窗口具有输入焦点。

### <a name="remarks"></a>备注

如果当前没有窗口具有输入焦点，则调用活动窗口的成员`OnSysKeyUp`函数。 接收`CWnd`调用的对象可以通过在*nFlags*中检查上下文代码来区分这两个上下文。

当上下文代码为 0 时，接收WM_SYSKEYUP`OnSysKeyUp`消息可以传递到[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函数，该函数将像处理正常密钥消息而不是系统键消息一样处理它。 这允许将快捷键（快捷方式）键与活动窗口一起使用，即使活动窗口没有输入焦点也是如此。

对于 IBM 增强型 101 键和 102 键键盘，增强键是键盘主部分的正确 ALT 和正确的 CTRL 键;数字键盘左侧的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭头键;和数字键盘中的斜杠 （/） 和 ENTER 键。 其他一些键盘可能支持*nFlags*中的扩展键位。

对于非美国增强型 102 键键盘，正确的 ALT 键作为 CTRL_ALT 键组合处理。 下面显示了用户按下并释放此密钥时导致的消息和调用的顺序：

|序列|函数已访问|已传递消息|
|--------------|-----------------------|--------------------|
|1.|[WM_KEYDOWN](#onkeydown)|VK_CONTROL|
|2.|[WM_KEYDOWN](#onkeydown)|VK_MENU|
|3.|[WM_KEYUP](#onkeyup)|VK_CONTROL|
|4.|[WM_SYSKEYUP](/windows/win32/inputdev/wm-syskeyup)|VK_MENU|

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndontcard"></a><a name="ontcard"></a>Cwnd：：开T卡

当用户单击可创作按钮时，框架将调用此成员函数。

```
afx_msg void OnTCard(
    UINT idAction,
    DWORD dwActionData);
```

### <a name="parameters"></a>参数

*idAction*<br/>
指示用户已执行的操作。 此参数可以是以下值之一：

- IDABORT 用户单击了可创作中止按钮。

- IDCANCEL 用户单击了可创作的"取消"按钮。

- IDCLOSE 用户关闭培训卡。

- IDHELP 用户单击了可创作的 Windows 帮助按钮。

- IDIGNORE 用户单击了可创作的"忽略"按钮。

- IDOK 用户单击了可创作的"确定"按钮。

- IDNO 用户单击了可创作的"无"按钮。

- 用户单击了可创作的重试按钮。

- HELP_TCARD_DATA 用户单击了可创作按钮。 *dwActionData*参数包含帮助作者指定的长整数。

- HELP_TCARD_NEXT用户单击了可创作的"下一步"按钮。

- HELP_TCARD_OTHER_CALLER 另一个应用程序已申请培训卡。

- IDYES 用户单击了可创作"是"按钮。

*dwActionData*<br/>
如果*idAction*指定HELP_TCARD_DATA，则此参数是帮助作者指定的长整数。 否则，此参数为零。

### <a name="remarks"></a>备注

仅当应用程序使用 Windows 帮助启动培训卡时，才会调用此功能。 应用程序通过在对[WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)函数的调用中指定HELP_TCARD命令来启动培训卡。

## <a name="cwndontimechange"></a><a name="ontimechange"></a>Cwnd：：准时更改

更改系统时间后，框架将调用此成员函数。

```
afx_msg void OnTimeChange();
```

### <a name="remarks"></a>备注

让任何更改系统时间的应用程序将此消息发送到所有顶级窗口。 要将WM_TIMECHANGE消息发送到所有顶级窗口，应用程序可以使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函数，其*hwnd*参数设置为HWND_BROADCAST。

## <a name="cwndontimer"></a><a name="ontimer"></a>Cwnd：：开启计时器

框架在[SetTimer](#settimer)成员函数中指定的每个时间间隔后调用此成员函数，用于安装计时器。

```
afx_msg void OnTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>参数

*nIDEvent*<br/>
指定计时器的标识符。

### <a name="remarks"></a>备注

当应用程序的消息队列中没有其他消息时[，DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函数将发送[WM_TIMER](/windows/win32/winmsg/wm-timer)消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

### <a name="example"></a>示例

  请参阅[CWnd：：SetTimer](#settimer)中的示例。

## <a name="cwndontoolhittest"></a><a name="ontoolhittest"></a>Cwnd：：在工具命中测试

框架调用此成员函数以确定点是否位于指定工具的边界矩形中。

```
virtual INT_PTR OnToolHitTest(
    CPoint point,
    TOOLINFO* pTI) const;
```

### <a name="parameters"></a>参数

*点*<br/>
指定光标的 x 坐标和 y 坐标。 这些坐标始终相对于窗口的左上角

*Pti*<br/>
指向[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)结构的指针。 默认情况下设置以下结构值：

- *hwnd* = `m_hWnd`手柄 到窗口

- *uId* = `(UINT)hWndChild`句柄到子窗口

- *uFlags* &#124;= TTF_IDISHWND工具的手柄

- *lpszText* = LPSTR_TEXTCALLBACK指针指向要显示在指定窗口中的字符串

### <a name="return-value"></a>返回值

如果找到工具提示控件，则窗口控制 ID。 如果未找到工具提示控件，则 -1。

### <a name="remarks"></a>备注

如果点位于矩形中，则会检索有关该工具的信息。

如果工具提示关联的区域不是按钮，则`OnToolHitTest`将结构标志设置为TTF_NOTBUTTON并TTF_CENTERTIP。

覆盖`OnToolHitTest`以提供与默认提供的信息不同的信息。

有关结构的详细信息，请参阅 Windows SDK 中的[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)。

## <a name="cwndontouchinput"></a><a name="ontouchinput"></a>Cwnd：：OnTouch输入

处理来自 Windows 触摸屏的单个输入。

```
virtual BOOL OnTouchInput(
    CPoint pt,
    int nInputNumber,
    int nInputsCount,
    PTOUCHINPUT pInput);
```

### <a name="parameters"></a>参数

*pt*<br/>
触摸屏幕的点（在客户端坐标中）。

*nInput 编号*<br/>
触摸输入数。

*n 输入计数*<br/>
触摸输入总数。

*pInput*<br/>
指向触摸输入结构的指针。

### <a name="return-value"></a>返回值

如果应用程序处理 Windows 触摸输入，则为 TRUE;如果应用程序处理 Windows 触摸输入，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

## <a name="cwndontouchinputs"></a><a name="ontouchinputs"></a>Cwnd：：OnTouch输入

处理来自 Windows 触摸的输入。

```
virtual BOOL OnTouchInputs(
    UINT nInputsCount,
    PTOUCHINPUT pInputs);
```

### <a name="parameters"></a>参数

*n 输入计数*<br/>
Windows 触摸输入的总数。

*p输入*<br/>
触控图的数组。

### <a name="return-value"></a>返回值

如果应用程序处理 Windows 触摸输入，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

## <a name="cwndonunichar"></a><a name="onunichar"></a>Cwnd：：OnUniChar

按下键时，框架将调用此成员函数。 也就是说，当前窗口具有键盘焦点，并且[翻译Message](/windows/win32/api/winuser/nf-winuser-translatemessage)函数将[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)消息翻译。

```
afx_msg void OnUniChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*n查尔*|[在]指定按下键的字符代码。|
|*恩雷普森特*|[在]指定当前消息的重复计数。 该值是用户按住键后自动重复击键的次数。 如果击键保持足够长的时间，则发送多条消息。 但是，重复计数不是累积的。|
|*nFlags*|[在]指定扫描代码、扩展密钥、上下文代码、以前键状态和转换状态的标志，如下表所示：<br /><br /> **0-7：** 指定扫描代码。 该值取决于原始设备制造商 （OEM）。<br /><br /> **8：** 指定扩展键，例如显示在增强的 101 或 102 键键盘上的右侧 ALT 和 CTRL 键。 如果键是扩展键，则标志为 1;如果键是扩展键，则标志为 1。否则，它是 0。<br /><br /> **9-12：** Windows 在内部使用。<br /><br /> **13：** 指定上下文代码。 如果按下 ALT 键时按住 ALT 键，则标志为 1;如果按下该键时，则标志为 1。否则，该值为 0。<br /><br /> **14：** 指定以前的键状态。 如果键在发送消息之前向下，则标志为 1;如果键已打开，则为 0。<br /><br /> **15：** 指定转换状态。 如果释放键，则标志为 1;如果按下键，则为 0。|

### <a name="remarks"></a>备注

此方法接收[WM_UNICHAR](/windows/win32/inputdev/wm-unichar)通知，这在 Windows SDK 中介绍。 [WM_UNICHAR](/windows/win32/inputdev/wm-unichar)消息旨在向 ANSI 窗口发送或发布 Unicode 字符。 它等效于[WM_CHAR](/windows/win32/inputdev/wm-char)消息，但使用 Unicode 转换格式-32 编码 （UTF-32），而[WM_CHAR](/windows/win32/inputdev/wm-char)消息使用 UTF-16。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonuninitmenupopup"></a><a name="onuninitmenupopup"></a>Cwnd：：OninitMenuPopup

当下拉菜单或子菜单被销毁时，框架将调用此成员函数。

```
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nFlags);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pMenu*|[在]指向表示菜单或子菜单的[CMenu](../../mfc/reference/cmenu-class.md)对象的指针。|
|*nFlags*|[在]已销毁的菜单。 目前，它只能是窗口菜单，MF_SYSMENU。|

### <a name="remarks"></a>备注

此方法接收[WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup)通知，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonupdateuistate"></a><a name="onupdateuistate"></a>Cwnd：：更新

调用以更改指定窗口及其所有子窗口的用户界面 (UI) 状态。

```
afx_msg void OnUpdateUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>参数

*nAction*<br/>
指定要执行的操作。 可以是以下值之一：

- UIS_CLEAR应隐藏 UI 状态元素（由*nUIElement*指定）。

- UIS_INITIALIZE 应基于最后一个输入事件更改 UI 状态元素（由*nUIElement*指定）。 有关详细信息，请参阅[WM_UPDATEISTATE](/windows/win32/menurc/wm-updateuistate)的**备注**部分。

- UIS_SET UI 状态元素（由*nUIElement*指定）应可见。

*nUI元素*<br/>
指定受影响的 UI 状态元素或控件的样式。 可以是以下值之一：

- UISF_HIDEACCEL键盘加速器。

- UISF_HIDEFOCUS焦点指标。

- UISF_ACTIVE Windows XP：控件应以用于活动控件的样式绘制。

### <a name="remarks"></a>备注

此成员函数模拟[WM_UPDATEUISTATE](/windows/win32/menurc/wm-updateuistate)消息的功能，如 Windows SDK 中所述。

## <a name="cwndonuserchanged"></a><a name="onuserchanged"></a>Cwnd：：打开用户

当用户登录或注销后，框架将此成员称为所有窗口。

```
afx_msg void OnUserChanged();
```

### <a name="remarks"></a>备注

此方法接收[WM_USERCHANGED](/windows/win32/winmsg/wm-userchanged)通知消息，这在 Windows SDK 中介绍。 当用户登录或注销时，操作系统将更新特定于用户的设置。 系统在更新设置后立即发送此消息。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonvkeytoitem"></a><a name="onvkeytoitem"></a>Cwnd：：在Vkeyto项目

如果`CWnd`对象拥有具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)样式的列表框，则列表框将发送WM_VKEYTOITEM消息以响应WM_KEYDOWN消息。

```
afx_msg int OnVKeyToItem(
    UINT nKey,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>参数

*n键*<br/>
指定用户按下的密钥的虚拟密钥代码。 有关标准虚拟密钥代码的列表，请参阅 Winuser.h

*pListBox*<br/>
指定指向列表框的指针。 该指针可能是暂时的，不应存储起来供将来使用。

*nIndex*<br/>
指定当前位置。

### <a name="return-value"></a>返回值

指定应用程序为响应消息执行的操作。 返回值 -2 表示应用程序处理了选择项的所有方面，并且不需要列表框执行进一步操作。 返回值 -1 表示列表框应执行默认操作以响应击键。 返回值 0 或更高指定列表框中项的零基索引，并指示列表框应对给定项执行击键的默认操作。

### <a name="remarks"></a>备注

此成员函数仅由具有[LBS_HASSTRINGS](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)样式的列表框框架调用。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonvscroll"></a><a name="onvscroll"></a>Cwnd：：OnVScroll

当用户单击窗口的垂直滚动条时，框架将调用此成员函数。

```
afx_msg void OnVScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>参数

*nSB代码*<br/>
指定指示用户滚动请求的滚动条代码。 此参数可以是以下项之一：

- SB_BOTTOM滚动到底部。

- SB_ENDSCROLL 结束滚动。

- SB_LINEDOWN向下滚动一行。

- SB_LINEUP向上滚动一行。

- SB_PAGEDOWN向下滚动一页。

- SB_PAGEUP向上滚动一页。

- SB_THUMBPOSITION滚动到绝对位置。 当前位置以*nPos*提供。

- SB_THUMBTRACK将滚动框拖动到指定位置。 当前位置以*nPos*提供。

- SB_TOP滚动到顶部。

*nPos*<br/>
如果滚动条代码SB_THUMBPOSITION或SB_THUMBTRACK，则包含当前滚动框位置;否则未使用。 根据初始滚动范围 *，nPos*可能是负的，如有必要，应强制转换为**int。**

*pScrollBar*<br/>
如果滚动消息来自滚动条控件，则包含指向该控件的指针。 如果用户单击窗口的滚动条，则此参数为 NULL。 该指针可能是暂时的，不应存储起来供将来使用。

### <a name="remarks"></a>备注

`OnVScroll`通常在拖动滚动框时提供一些反馈的应用程序使用。

如果`OnVScroll`滚动`CWnd`对象的内容，则还必须使用[SetScrollPos](#setscrollpos)成员函数重置滚动框的位置。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonvscrollclipboard"></a><a name="onvscrollclipboard"></a>Cwnd：：OnVScroll剪贴板

当剪贴板数据具有`OnVScrollClipboard`CF_OWNERDISPLAY格式且剪贴板查看器的垂直滚动栏中有事件时，剪贴板所有者的成员函数由剪贴板查看器调用。

```
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>参数

*pClipAppwnd*<br/>
指定指向剪贴板-查看器窗口的指针。 该指针可能是暂时的，不应存储起来供将来使用。

*nSB代码*<br/>
指定以下滚动条值之一：

- SB_BOTTOM滚动到底部。

- SB_ENDSCROLL 结束滚动。

- SB_LINEDOWN向下滚动一行。

- SB_LINEUP向上滚动一行。

- SB_PAGEDOWN向下滚动一页。

- SB_PAGEUP向上滚动一页。

- SB_THUMBPOSITION滚动到绝对位置。 当前位置以*nPos*提供。

- SB_TOP滚动到顶部。

*nPos*<br/>
如果滚动条代码为SB_THUMBPOSITION，则包含滚动框位置;否则不使用*nPos。*

### <a name="remarks"></a>备注

所有者应滚动剪贴板图像，使相应部分无效，并更新滚动条值。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonwindowmaximizedchanged"></a><a name="onwindowmaximizedchanged"></a>Cwnd：：在窗口最大化更改

当当前窗口最大化且窗口由桌面窗口管理器 （DWM） 组成时，框架将调用此成员。

```
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*b 最大化*|[在]如果当前窗口最大化，则为 TRUE，如果不是，则为 FALSE。|

### <a name="remarks"></a>备注

此方法接收[WM_DWMWINDOWMAXIMIZEDCHANGE](/windows/win32/dwm/wm-dwmwindowmaximizedchange)通知消息，这在 Windows SDK 中介绍。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonwindowposchanged"></a><a name="onwindowposchanged"></a>Cwnd：：在WindowPos上

当大小、位置或 Z 顺序因调用[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)成员函数或其他窗口管理功能而发生更改时，框架将调用此成员函数。

```
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>参数

*lpwndpos*<br/>
指向包含窗口新大小和位置信息的[WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos)数据结构。

### <a name="remarks"></a>备注

默认实现将[WM_SIZE](/windows/win32/winmsg/wm-size)和[WM_MOVE](/windows/win32/winmsg/wm-move)消息发送到窗口。 如果应用程序在不调用其基类的情况下处理调用`OnWindowPosChanged`，则不会发送这些消息。 在调用`OnWindowPosChanged`期间执行任何移动或大小更改处理而不调用其基类会更有效。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonwindowposchanging"></a><a name="onwindowposchanging"></a>Cwnd：：在窗口Pos改变

当大小、位置或 Z 顺序即将由于对[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)成员函数或其他窗口管理函数的调用而更改时，框架将调用此成员函数。

```
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>参数

*lpwndpos*<br/>
指向包含有关窗口`WINDOWPOS`新大小和位置的信息的数据结构。

### <a name="remarks"></a>备注

应用程序可以通过设置或清除[WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos)结构**的标志**成员中的相应位来防止对窗口的更改。

对于具有[WS_OVERLAPPED](styles-used-by-mfc.md#window-styles)或[WS_THICKFRAME](styles-used-by-mfc.md#window-styles)样式的窗口，默认实现向该窗口发送[WM_GETMINMAXINFO](/windows/win32/winmsg/wm-getminmaxinfo)消息。 这样做是为了验证窗口的新大小和位置，并强制实施CS_BYTEALIGNCLIENT和CS_BYTEALIGN客户端样式。 应用程序可以通过不调用其基类来覆盖此功能。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonwininichange"></a><a name="onwininichange"></a>Cwnd：：OnWininiChange

对 Windows 初始化文件 WIN 进行更改后，框架将调用此成员函数。Ini。

```
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```

### <a name="parameters"></a>参数

*lpsz节*<br/>
指向指定已更改的节的名称的字符串。 （字符串不包括包含节名称的方括号。

### <a name="remarks"></a>备注

[系统参数信息](/windows/win32/api/winuser/nf-winuser-systemparametersinfow)Windows 函数在`OnWinIniChange`应用程序使用该函数更改 WIN 中的设置后调用。INI 文件。

要将WM_WININICHANGE消息发送到所有顶级窗口，应用程序可以使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函数，其*hwnd*参数设置为HWND_BROADCAST。

如果应用程序更改 WIN 中的许多不同的部分。同时，应用程序应发送一条WM_WININICHANGE消息 *，lpszSection*设置为 NULL。 否则，应用程序应在每次更改 WIN 时发送WM_WININICHANGE。Ini。

如果应用程序收到`OnWinIniChange`*lpszSection*设置为 NULL 的呼叫，则应用程序应检查 WIN 中的所有部分。影响应用程序的 INI。

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonwndmsg"></a><a name="onwndmsg"></a>Cwnd：：OnwndMsg

此成员函数由`WindowProc`调用，或在消息反射期间调用。

```
virtual BOOL OnWndMsg(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要发送的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

*pResult*<br/>
[WindowProc](#windowproc)的返回值 。 取决于消息;可能是 NULL。

### <a name="return-value"></a>返回值

如果处理了消息，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

`OnWndMsg`确定消息类型，并调用相应的框架函数（例如，WM_COMMAND [OnCommand），](#oncommand)或在消息映射中查找相应的消息。

有关消息反射的详细信息，请参阅[处理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndonxbuttondblclk"></a><a name="onxbuttondblclk"></a>Cwnd：：OnXButtonDblClk

当用户双击 XBUTTON1 或 XBUTTON2 时，当用户在窗口的工作区中时，框架将调用此成员函数。

```
afx_msg void OnXButtonDblClk(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。|
|*nButton*|[在]如果双击第一个 Microsoft 智能鼠标 X 按钮，则值为 XBUTTON1;如果双击第二个 X 按钮，则为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk)通知，这在 Windows SDK 中介绍。 如果未捕获鼠标，则消息将发布到光标下方的窗口。 否则，消息将发布到捕获鼠标的窗口。

*nFlags*参数可以是下表中列出的修改器键的组合。 有关详细信息，请参阅[有关鼠标输入](/windows/win32/inputdev/about-mouse-input)。

|修改器键|说明|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 键。|
|MK_LBUTTON|鼠标左键已按下。|
|MK_MBUTTON|鼠标中键已按下。|
|MK_RBUTTON|鼠标右键已按下。|
|MK_SHIFT|按下 SHIFT 键。|
|MK_XBUTTON1|按下微软智能鼠标的 XBUTTON1 鼠标按钮。|
|MK_XBUTTON2|按下微软智能鼠标的 XBUTTON2 鼠标按钮。|

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonxbuttondown"></a><a name="onxbuttondown"></a>Cwnd：：打开按钮

当用户在光标位于窗口的工作区中时按下 XBUTTON1 或 XBUTTON2 时，框架将调用此成员函数。

```
afx_msg void OnXButtonDown(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。|
|*nButton*|[在]如果单击第一个 Microsoft 智能鼠标 X 按钮，则值为 XBUTTON1;单击第二个 X 按钮时为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_XBUTTONDOWN](/windows/win32/inputdev/wm-xbuttondown)通知，这在 Windows SDK 中介绍。 如果未捕获鼠标，则消息将发布到光标下方的窗口。 否则，消息将发布到捕获鼠标的窗口。

*nFlags*参数可以是下表中列出的修改器键的组合。 有关详细信息，请参阅[有关鼠标输入](/windows/win32/inputdev/about-mouse-input)。

|修改器键|说明|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 键。|
|MK_LBUTTON|鼠标左键已按下。|
|MK_MBUTTON|鼠标中键已按下。|
|MK_RBUTTON|鼠标右键已按下。|
|MK_SHIFT|按下 SHIFT 键。|
|MK_XBUTTON1|按下微软智能鼠标的 XBUTTON1 鼠标按钮。|
|MK_XBUTTON2|按下微软智能鼠标的 XBUTTON2 鼠标按钮。|

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndonxbuttonup"></a><a name="onxbuttonup"></a>Cwnd：：OnXButtonUp

当用户释放 XBUTTON1 或 XBUTTON2 时，当光标位于窗口的工作区中时，框架将调用此成员函数。

```
afx_msg void OnXButtonUp(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改键的标志的位组合 （OR）。 例如，MK_CONTROL标志指示按下 CTRL 键。|
|*nButton*|[在]如果双击第一个 Microsoft 智能鼠标 X 按钮，则值为 XBUTTON1;如果双击第二个 X 按钮，则为 XBUTTON2。|
|*点*|[在]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象，它指定光标相对于工作区左上角的*x*和*y*坐标。|

### <a name="remarks"></a>备注

此方法接收[WM_XBUTTONUP](/windows/win32/inputdev/wm-xbuttonup)通知，这在 Windows SDK 中介绍。 如果未捕获鼠标，则消息将发布到光标下方的窗口。 否则，消息将发布到捕获鼠标的窗口。

*nFlags*参数可以是下表中列出的修改器键的组合。 有关详细信息，请参阅[有关鼠标输入](/windows/win32/inputdev/about-mouse-input)。

|修改器键|说明|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 键。|
|MK_LBUTTON|鼠标左键已按下。|
|MK_MBUTTON|鼠标中键已按下。|
|MK_RBUTTON|鼠标右键已按下。|
|MK_SHIFT|按下 SHIFT 键。|
|MK_XBUTTON1|按下微软智能鼠标的 XBUTTON1 鼠标按钮。|
|MK_XBUTTON2|按下微软智能鼠标的 XBUTTON2 鼠标按钮。|

> [!NOTE]
> 框架调用此成员函数来支持你的应用程序处理 Windows 消息。 传递到函数的参数反映了收到消息时框架所接收的参数。 如果调用此函数的基类实现，该实现将使用最初随消息传递的参数，而不是你提供给该函数的参数。

## <a name="cwndopenclipboard"></a><a name="openclipboard"></a>CWnd：：打开剪板

打开剪贴板。

```
BOOL OpenClipboard();
```

### <a name="return-value"></a>返回值

如果通过`CWnd`打开 剪贴板，则为非零;如果其他应用程序或窗口打开了剪贴板，则为 0。

### <a name="remarks"></a>备注

在调用[CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) Windows 功能之前，其他应用程序将无法修改剪贴板。

在调用`CWnd`["空剪贴板](/windows/win32/api/winuser/nf-winuser-emptyclipboard)"Windows 函数之前，当前对象不会成为剪贴板的所有者。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]

## <a name="cwndoperator-hwnd"></a><a name="operator_hwnd"></a>CWnd：：操作员HWND

使用此运算符获取`CWnd`对象的句柄。

```
operator HWND() const;
```

## <a name="cwndoperator-"></a><a name="operator_neq"></a>CWnd：：操作员！*

比较两`CWnd`个对象以确定它们是否具有相同的[m_hWnd。](#m_hwnd)

```
BOOL operator!=(const CWnd& wnd) const;
```

### <a name="parameters"></a>参数

*wnd*<br/>
对 `CWnd` 对象的引用。

### <a name="return-value"></a>返回值

等于非零;否则 0。

## <a name="cwndoperator-"></a><a name="operator_eq_eq"></a>CWnd：：操作员 |

比较两`CWnd`个对象以确定它们是否具有相同的[m_hWnd](#m_hwnd)。

```
BOOL operator==(const CWnd& wnd) const;
```

### <a name="parameters"></a>参数

*wnd*<br/>
对 `CWnd` 对象的引用。

### <a name="return-value"></a>返回值

等于非零;否则 0。

## <a name="cwndpaintwindowlesscontrols"></a><a name="paintwindowlesscontrols"></a>CWnd：:P无窗口控制

在控件容器上绘制无窗口控件。

```
BOOL PaintWindowlessControls(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
要在其中绘制无窗口控件的设备上下文。

### <a name="return-value"></a>返回值

如果有控件容器，并且已成功绘制无窗口控件，则返回 TRUE，否则为 FALSE。

## <a name="cwndpostmessage"></a><a name="postmessage"></a>CWnd：:Post消息

将消息放在窗口的消息队列中，然后返回而不等待相应的窗口来处理消息。

```
BOOL PostMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要过帐的消息。

*wParam*<br/>
指定其他消息信息。 此参数的内容取决于要发布的消息。

*lParam*<br/>
指定其他消息信息。 此参数的内容取决于要发布的消息。

### <a name="return-value"></a>返回值

如果消息已过帐，则非零;否则 0。

### <a name="remarks"></a>备注

通过调用[GetMessage](/windows/win32/api/winuser/nf-winuser-getmessage)或[PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagew) Windows 功能检索消息队列中的消息。

Windows [PostMessage](/windows/win32/api/winuser/nf-winuser-postmessagew)功能可用于访问其他应用程序。

### <a name="example"></a>示例

  请参阅[AfxGetMainwnd 的示例](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)。

## <a name="cwndpostncdestroy"></a><a name="postncdestroy"></a>CWnd：:PostNc破坏

在窗口被破坏后，由默认[OnNc销毁](#onncdestroy)成员函数调用。

```
virtual void PostNcDestroy();
```

### <a name="remarks"></a>备注

派生类可以使用此函数进行自定义清理，例如删除**此**指针。

## <a name="cwndprecreatewindow"></a><a name="precreatewindow"></a>CWnd：:P重新创建窗口

在创建附加到此`CWnd`对象的 Windows 窗口之前，由框架调用。

```
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```

### <a name="parameters"></a>参数

*cs*<br/>
[一个创造结构](/windows/win32/api/winuser/ns-winuser-createstructw)。

### <a name="return-value"></a>返回值

如果窗口创建应继续，则非零;0 表示创建失败。

### <a name="remarks"></a>备注

> [!WARNING]
> `CWnd::PreCreateWindow`现在，如果菜单为 NULL 且样式包含WS_CHILD，则将*cs*的 hMenu 成员分配给**此**指针。 要获得正确的功能，请确保对话框控件的 ID 不是 NULL。
>
> 此更改修复了托管/本机互操作方案中的崩溃。 中的`CWnd::Create`TRACE 语句提醒开发人员问题。

切勿直接调用此函数。

此函数的默认实现检查 NULL 窗口类名称，并替换适当的默认值。 重写此成员函数，在`CREATESTRUCT`创建窗口之前修改结构。

派生自 的每个`CWnd`类都会将自己的功能添加到其对`PreCreateWindow`的重写中。 根据设计，这些派生`PreCreateWindow`没有记录。 要确定适合每个类的样式和样式之间的相互依赖性，可以检查应用程序的基类的 MFC 源代码。 如果选择重写`PreCreateWindow,`，则可以确定应用程序基类中使用的样式是否通过使用从 MFC 源代码收集的信息提供所需的功能。

有关更改窗口样式的详细信息，请参阅[更改 MFC 创建的窗口样式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]

## <a name="cwndpresubclasswindow"></a><a name="presubclasswindow"></a>CWnd：:P重子类窗口

框架调用此成员函数，以便在子类窗口之前进行其他必要的子类。

```
virtual void PreSubclassWindow();
```

### <a name="remarks"></a>备注

重写此成员函数允许对控件进行动态子类化。 这是一个先进的超易。

## <a name="cwndpretranslatemessage"></a><a name="pretranslatemessage"></a>CWnd：:P重新翻译消息

类[CWinApp](../../mfc/reference/cwinapp-class.md)在窗口消息发送到[翻译消息](/windows/win32/api/winuser/nf-winuser-translatemessage)和[调度消息](/windows/win32/api/winuser/nf-winuser-dispatchmessage)窗口功能之前，用于转换窗口消息。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>参数

*pMsg*<br/>
指向包含要处理的消息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)结构。

### <a name="return-value"></a>返回值

如果邮件已翻译且不应发送，则非零;0 如果邮件未翻译，则应调度。

## <a name="cwndprint"></a><a name="print"></a>CWnd：:P

调用此成员函数以在指定的设备上下文中绘制当前窗口，这在打印机设备上下文中很常见。

```
void Print(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>参数

*pDC*<br/>
一个指向设备上下文的指针。

dwFlags**<br/>
指定绘图选项。 此参数可以是以下一个或多个标志：

- PRF_CHECKVISIBLE仅当窗口可见时才绘制窗口。

- PRF_CHILDREN绘制所有可见的子窗口。

- PRF_CLIENT绘制窗口的工作区。

- PRF_ERASEBKGND在绘制窗口之前擦除背景。

- PRF_NONCLIENT绘制窗口的非工作区。

- PRF_OWNED绘制所有拥有的窗口。

### <a name="remarks"></a>备注

[CWnd：:DefWindowProc](#defwindowproc)函数根据指定绘图选项处理此消息：

- 如果指定了PRF_CHECKVISIBLE并且窗口不可见，则不执行任何操作。

- 如果指定PRF_NONCLIENT，则在给定设备上下文中绘制非工作区。

- 如果指定了PRF_ERASEBKGND，则向窗口发送[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息。

- 如果指定了PRF_CLIENT，则向窗口发送[WM_PRINTCLIENT](/windows/win32/gdi/wm-printclient)消息。

- 如果设置了PRF_CHILDREN，则为每个可见的子窗口发送[一WM_PRINT](/windows/win32/gdi/wm-print)消息。

- 如果设置了PRF_OWNED，则向每个可见拥有的窗口发送一条WM_PRINT消息。

## <a name="cwndprintclient"></a><a name="printclient"></a>CWnd：:PrintClient

调用此成员函数以在指定的设备上下文中（通常是打印机设备上下文）中绘制任何窗口。

```
void PrintClient(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>参数

*pDC*<br/>
一个指向设备上下文的指针。

dwFlags**<br/>
指定绘图选项。 此参数可以是以下一个或多个标志：

- PRF_CHECKVISIBLE仅当窗口可见时才绘制窗口。

- PRF_CHILDREN绘制所有可见的子窗口。

- PRF_CLIENT绘制窗口的工作区。

- PRF_ERASEBKGND在绘制窗口之前擦除背景。

- PRF_NONCLIENT绘制窗口的非工作区。

- PRF_OWNED绘制所有拥有的窗口。

## <a name="cwndprintwindow"></a><a name="printwindow"></a>CWnd：:P林特窗口

将可视窗口复制到指定设备上下文（通常是打印机设备上下文）。

```
BOOL PrintWindow(
    CDC* pDC,
    UINT nFlags) const;
```

### <a name="parameters"></a>参数

*pDC*<br/>
指向要打印到的设备上下文的指针。

*nFlags*<br/>
指定绘图选项。 有关可能值的列表，请参阅[打印窗口](/windows/win32/api/winuser/nf-winuser-printwindow)。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[PrintWindow](/windows/win32/api/winuser/nf-winuser-printwindow)的功能，如 Windows SDK 中所述。

## <a name="cwndredrawwindow"></a><a name="redrawwindow"></a>CWnd：：重绘窗口

更新给定窗口工作区中的指定矩形或区域。

```
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,
    CRgn* prgnUpdate = NULL,
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```

### <a name="parameters"></a>参数

*lprect更新*<br/>
指向包含更新矩形坐标的[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。 如果*prgnUpdate*包含有效的区域句柄，则忽略此参数。

*prgnUpdate*<br/>
标识更新区域。 如果*prgnUpdate*和*lpRectUpdate*均为 NULL，则整个工作区将添加到更新区域。

*标志*<br/>
以下标志用于使窗口无效：

- RDW_ERASE 使窗口在重新绘制窗口时接收[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息。 还必须指定RDW_INVALIDATE标志;否则RDW_ERASE无效。

- RDW_FRAME 使窗口的非工作区与更新区域相交的任何部分接收[WM_NCPAINT](/windows/win32/gdi/wm-ncpaint)消息。 还必须指定RDW_INVALIDATE标志;否则RDW_FRAME无效。

- RDW_INTERNALPAINT 使[WM_PAINT](/windows/win32/gdi/wm-paint)消息发布到窗口，而不考虑窗口是否包含无效区域。

- RDW_INVALIDATE无效*的 lpRect 更新*或*prgnUpdate（* 只有一个可能不是 NULL）。 如果两者均为 NULL，则整个窗口将失效。

以下标志用于验证窗口：

- RDW_NOERASE禁止任何挂起WM_ERASEBKGND消息。

- RDW_NOFRAME禁止任何挂起的WM_NCPAINT消息。 此标志必须与RDW_VALIDATE一起使用，通常与RDW_NOCHILDREN一起使用。 此选项应谨慎使用，因为它可以防止窗口的某些部分正确绘制。

- RDW_NOINTERNALPAINT禁止任何挂起的内部WM_PAINT消息。 此标志不会影响由无效区域产生的WM_PAINT消息。

- RDW_VALIDATE验证*lpRect 更新*或*prgnUpdate（* 只有一个可能不是 NULL）。 如果两者均为 NULL，则验证整个窗口。 此标志不会影响内部WM_PAINT消息。

重新绘制时，以下标志控件。 除非指定了其中一个`RedrawWindow`位，否则函数不会执行绘制。

- RDW_ERASENOW 使受影响的窗口（如RDW_ALLCHILDREN和RDW_NOCHILDREN标志）在函数返回之前接收WM_NCPAINT和WM_ERASEBKGND消息。 WM_PAINT消息被延迟。

- RDW_UPDATENOW 使受影响的窗口（如RDW_ALLCHILDREN和RDW_NOCHILDREN标志）在函数返回之前接收WM_NCPAINT、WM_ERASEBKGND和WM_PAINT消息。

默认情况下，受`RedrawWindow`该函数影响的窗口取决于指定的窗口是否具有WS_CLIPCHILDREN样式。 WS_CLIPCHILDREN窗口的子窗口不受影响。 但是，在遇到WS_CLIPCHILDREN窗口之前，那些不是窗口WS_CLIPCHILDREN的窗口将递归验证或失效。 以下标志控制哪些窗口受`RedrawWindow`该函数影响：

- RDW_ALLCHILDREN在重新绘制操作中包括子窗口（如果有）。

- RDW_NOCHILDREN 从重新绘制操作中排除子窗口（如果有）。

### <a name="return-value"></a>返回值

如果窗口已成功重绘，则非零;否则 0。

### <a name="remarks"></a>备注

当`RedrawWindow`成员函数用于使桌面窗口的一部分无效时，该窗口不会收到[WM_PAINT](/windows/win32/gdi/wm-paint)消息。 要重新绘制桌面，应用程序应使用[CWnd：：验证](#validatergn)Rgn，CWnd：：验证Rgn，CWnd：：[更新窗口](#updatewindow)，或[重绘窗口](/windows/win32/api/winuser/nf-winuser-redrawwindow)[CWnd::InvalidateRgn](#invalidatergn)

## <a name="cwndreflectchildnotify"></a><a name="reflectchildnotify"></a>CWnd：：反映儿童通知

此消息函数由[来自 OnChildNotify](#onchildnotify)的框架调用。

```
BOOL ReflectChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要反射的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

*pResult*<br/>
子窗口生成的结果，由父窗口返回。 可以为 NULL。

### <a name="return-value"></a>返回值

如果消息被反映为 TRUE;如果消息被反映，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

它是一个帮助函数，它反映*消息*到它的源。

反射的消息直接发送到[CWnd：：OnwndMsg](#onwndmsg)或[CCmdTarget：：OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。

有关消息反射的详细信息，请参阅[处理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreflectlastmsg"></a><a name="reflectlastmsg"></a>CWnd：：反映

框架调用此成员函数以向子窗口反映最后一条消息。

```
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,
    LRESULT* pResult = NULL);
```

### <a name="parameters"></a>参数

*hWndChild*<br/>
子窗口的句柄。

*pResult*<br/>
子窗口生成的结果，由父窗口返回。 可以为 NULL。

### <a name="return-value"></a>返回值

处理消息时非零;否则 0。

### <a name="remarks"></a>备注

如果*hWndChild*标识的窗口是 OLE 控件或永久地图中的窗口，则此成员函数将调用[SendChildNotifyLastMsg。](#sendchildnotifylastmsg)

有关消息反射的详细信息，请参阅[处理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreleasedc"></a><a name="releasedc"></a>CWnd：：释放DC

释放设备上下文，将其释放供其他应用程序使用。

```
int ReleaseDC(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
标识要发布的设备上下文。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

`ReleaseDC`成员函数的效果取决于设备上下文类型。

应用程序必须调用`ReleaseDC`对[GetWindowDC](#getwindowdc)成员函数的每个调用以及对[GetDC](#getdc)成员函数的每个调用的成员函数。

## <a name="cwndrepositionbars"></a><a name="repositionbars"></a>CWnd：：重新定位条

调用以重新定位和调整窗口工作区中的控制栏的大小。

```
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;
```

### <a name="parameters"></a>参数

*nID第一*<br/>
用于重新定位和调整大小的控制栏中第一个的 ID。

*nIDLast*<br/>
要重新定位和调整大小的控制栏范围内最后一个的 ID。

*nID剩下*<br/>
指定填充工作区其余部分的窗格的 ID。

*nFlag*<br/>
可以是下列值之一：

- `CWnd::reposDefault`执行控制栏的布局。 *不使用 lpRectParam，* 可以为 NULL。

- `CWnd::reposQuery`控制栏的布局未完成;未完成控制栏的布局。相反 *，lpRectParam*会用工作区的大小进行初始化，就像布局实际上已经完成一样。

- `CWnd::reposExtra`将*lpRectParam*的值添加到*nIDLast*的工作区，并执行布局。

*lpRectParam*<br/>
指向[RECT 结构](/windows/win32/api/windef/ns-windef-rect);其用法取决于*nFlag*的值。

*lpRectClient*<br/>
指向包含可用工作区的[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。 如果 NULL，将使用窗口的工作区。

*b 拉伸*<br/>
指示是否应将条形拉伸到框架的大小。

### <a name="remarks"></a>备注

*nIDFirst*和*nIDLast*参数定义要重新定位在工作区中的控制栏 ID 范围。 *nIDLeftOver*参数指定子窗口（通常是视图）的 ID，该 ID 被重新定位并调整大小以填充控件栏未填充的工作区的其余部分。

## <a name="cwndrunmodalloop"></a><a name="runmodalloop"></a>CWnd：：运行模式环

调用此成员函数以检索、翻译或调度消息，直到["继续模式"](#continuemodal)返回 FALSE。

```
int RunModalLoop(DWORD dwFlags = 0);
```

### <a name="parameters"></a>参数

dwFlags**<br/>
指定要发送的 Windows 消息。 可以是以下值之一：

- MLF_NOIDLEMSG不要向父发送[WM_ENTERIDLE](/windows/win32/dlgbox/wm-enteridle)消息。

- MLF_NOKICKIDLE不要向窗口发送WM_KICKIDLE消息。

- MLF_SHOWONIDLE消息队列空闲时显示窗口。

### <a name="return-value"></a>返回值

指定传递给[EndModalLoop](#endmodalloop)成员函数的*nResult*参数的值，然后用于结束模式循环。

### <a name="remarks"></a>备注

默认情况下，`ContinueModal`在调用后`EndModalLoop`返回 FALSE。 将作为*nResult*提供的值`EndModalLoop`返回 到 。

## <a name="cwndscreentoclient"></a><a name="screentoclient"></a>Cwnd：：屏幕客户端

将显示中的给定点或矩形的屏幕坐标转换为客户端坐标。

```
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
指向包含要转换的屏幕坐标的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象或[POINT 结构](/windows/win32/api/windef/ns-windef-point)。

*lpRect*<br/>
指向包含要转换的屏幕坐标的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>备注

成员`ScreenToClient`函数将*lpPoint*或*lpRect*中给出的屏幕坐标替换为客户端坐标。 新坐标相对于`CWnd`工作区的左上角。

### <a name="example"></a>示例

  请参阅[CListCtrl 的示例：获取项目重新完成](../../mfc/reference/clistctrl-class.md#getitemrect)。

## <a name="cwndscrollwindow"></a><a name="scrollwindow"></a>CWnd：：滚动窗口

滚动当前`CWnd`对象的工作区的内容。

```
void ScrollWindow(
    int xAmount,
    int yAmount,
    LPCRECT lpRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>参数

*x数量*<br/>
指定水平滚动的数量（以设备单位为单位）。 此参数必须是向左滚动的负值。

*y 数量*<br/>
指定垂直滚动的数量（以设备单位为单位）。 此参数必须是负值才能向上滚动。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)，该结构指定要滚动的工作区部分。 如果*lpRect*为 NULL，则滚动整个工作区。 如果光标矩形与滚动矩形相交，则重新定位。

*lpClipRect*<br/>
指向指定要`CRect`滚动的`RECT`裁剪矩形的对象或结构。 仅滚动此矩形内的位。 此矩形外部的位不受影响，即使它们位于*lpRect*矩形中也是如此。 如果*lpClipRect*为 NULL，则滚动矩形上不执行任何剪辑。

### <a name="remarks"></a>备注

如果 care 在`CWnd`正在滚动中，`ScrollWindow`则会自动隐藏 caret 以防止其被擦除，然后在滚动完成后还原 care。 护理位置会相应地调整。

成员函数覆盖的区域`ScrollWindow`不会重新绘制，而是合并到当前`CWnd`对象的更新区域中。 应用程序最终将收到[一条WM_PAINT](/windows/win32/gdi/wm-paint)消息，通知它该区域需要重新绘制。 要在滚动完成的同时重新绘制未覆盖的区域，请调用`ScrollWindow`后立即调用[UpdateWindow](#updatewindow)成员函数。

如果*lpRect*为 NULL，则窗口中任何子窗口的位置都由*x量*和*y量*指定的量偏移，并且 中`CWnd`的任何无效（未上漆）区域也会偏移。 `ScrollWindow`当*lpRect*为 NULL 时，速度更快。

如果*lpRect*不是 NULL，则子窗口的位置不会更改，并且 中的`CWnd`无效区域不会偏移。 为了防止*在 lpRect*不是 NULL 时更新问题`UpdateWindow`，请调用成员函数`CWnd`在调用`ScrollWindow`之前重新绘制 。

## <a name="cwndscrollwindowex"></a><a name="scrollwindowex"></a>CWnd：：滚动窗口Ex

滚动窗口工作区的内容。

```
int ScrollWindowEx(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* prgnUpdate,
    LPRECT lpRectUpdate,
    UINT flags);
```

### <a name="parameters"></a>参数

*Dx*<br/>
指定水平滚动的数量（以设备单位为单位）。 此参数必须具有负值才能向左滚动。

*Dy*<br/>
指定垂直滚动的数量（以设备单位为单位）。 此参数必须具有负值才能向上滚动。

*lpRectScroll*<br/>
指向指定要滚动的工作区部分的[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。 如果此参数为 NULL，则滚动整个工作区。

*lprectClip*<br/>
指向指定要`RECT`滚动的裁剪矩形的结构。 此结构优先于*lpRectScroll*指向的矩形。 仅滚动此矩形内的位。 此矩形外部的位不受影响，即使它们位于*lpRectScroll*矩形中也是如此。 如果此参数为 NULL，则滚动矩形上不执行剪切。

*prgnUpdate*<br/>
标识已修改的区域，以便通过滚动保持区域无效。 此参数可能为 NULL。

*lprect更新*<br/>
指向将接收`RECT`通过滚动而失效的矩形边界的结构。 此参数可能为 NULL。

*标志*<br/>
可以是下列值之一：

- SW_ERASE 使用SW_INVALIDATE指定时，通过向窗口发送[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息来擦除新失效的区域。

- SW_INVALIDATE在滚动后使*prgnUpdate*标识的区域无效。

- SW_SCROLLCHILDREN滚动所有与*lpRectScroll*指向的矩形相交的子窗口，按*dx*和*dy*中指定的像素数。 Windows 向所有与*lpRectScroll*相交的子窗口发送[WM_MOVE](/windows/win32/winmsg/wm-move)消息，即使它们不移动也是如此。 当滚动子窗口且光标矩形与滚动矩形相交时，将重新定位该图。

### <a name="return-value"></a>返回值

如果函数成功，返回值为 SIMPLEREGION（矩形失效区域）、复杂区域（非矩形失效区域;重叠矩形）或 NULLREGION（无失效区域）;否则返回值为错误。

### <a name="remarks"></a>备注

此功能类似于["滚动窗口"](/windows/win32/api/winuser/nf-winuser-scrollwindow)功能，并具有一些附加功能。

如果未指定[SW_INVALIDATE](/windows/win32/api/winuser/nf-winuser-scrollwindowex)和[SW_ERASE，](/windows/win32/api/winuser/nf-winuser-scrollwindowex)`ScrollWindowEx`则成员函数不会使滚动离开的区域无效。 如果设置了这些标志中的任何一个，`ScrollWindowEx`则使此区域失效。 在应用程序调用[UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow)成员函数、调用[重绘窗口](/windows/win32/api/winuser/nf-winuser-redrawwindow)成员函数（指定[RDW_UPDATENOW](/windows/win32/api/winuser/nf-winuser-redrawwindow)或[RDW_ERASENOW）](/windows/win32/api/winuser/nf-winuser-redrawwindow)或从应用程序队列中检索[WM_PAINT](/windows/win32/gdi/wm-paint)消息之前，不会更新该区域。

如果窗口具有[WS_CLIPCHILDREN](/windows/win32/api/winuser/nf-winuser-createwindoww)样式，*则 prgnUpdate*和*lpRectUpdate*指定的返回区域表示必须更新的滚动窗口的总面积，包括子窗口中需要更新的任何区域。

如果指定[了SW_SCROLLCHILDREN](/windows/win32/api/winuser/nf-winuser-scrollwindowex)标志，则如果滚动了子窗口的一部分，Windows 将无法正确更新屏幕。 位于源矩形外的滚动子窗口部分将不会擦除，也不会在其新目标中正确重绘。 使用["延迟窗口Pos"](/windows/win32/api/winuser/nf-winuser-deferwindowpos)窗口函数移动未完全位于*lpRectScroll*矩形内的子窗口。 如果设置了SW_SCROLLCHILDREN标志，并且倾斜矩形与滚动矩形相交，则重新定位光标。

所有输入和输出坐标（对于 lpRectScroll、lpRectClip、lpRectUpdate 和*prgnUpdate）* 都假定在客户端坐标中，而不考虑窗口具有CS_OWNDC还是CS_CLASSDC类样式。 *lpRectScroll* *lpRectClip* *lpRectUpdate* 如有必要，使用[LPtoDP](/windows/win32/api/wingdi/nf-wingdi-lptodp)和[DPtoLP](/windows/win32/api/wingdi/nf-wingdi-dptolp) Windows 函数转换到逻辑坐标和从逻辑坐标转换。

## <a name="cwndsendchildnotifylastmsg"></a><a name="sendchildnotifylastmsg"></a>CWnd：：发送儿童通知最后Msg

框架调用此成员函数，以便从父窗口向子窗口提供通知消息，以便子窗口可以处理任务。

```
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```

### <a name="parameters"></a>参数

*pResult*<br/>
子窗口生成的结果，由父窗口返回。

### <a name="return-value"></a>返回值

如果子窗口已处理发送到其父级的消息，则非零;否则 0。

### <a name="remarks"></a>备注

`SendChildNotifyLastMsg`如果当前消息是反映的消息，则将当前消息发送到源。

有关消息反射的详细信息，请参阅[处理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndsenddlgitemmessage"></a><a name="senddlgitemmessage"></a>CWnd：：发送DlgItem消息

向控件发送消息。

```
LRESULT SendDlgItemMessage(
    int nID,
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>参数

*nID*<br/>
指定将接收消息的对话框控件的标识符。

*消息*<br/>
指定要发送的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

### <a name="return-value"></a>返回值

指定控件的窗口过程返回的值，如果找不到控件，则指定 0。

### <a name="remarks"></a>备注

在`SendDlgItemMessage`处理消息之前，成员函数不会返回。

使用`SendDlgItemMessage`与获取给定控件的`CWnd`* 并调用[SendMessage](#sendmessage)成员函数相同。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]

## <a name="cwndsendmessage"></a><a name="sendmessage"></a>CWnd：：发送消息

将指定的消息发送到此窗口。

```
LRESULT SendMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要发送的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

### <a name="return-value"></a>返回值

消息处理的结果;其值取决于发送的消息。

### <a name="remarks"></a>备注

成员`SendMessage`函数直接调用窗口过程，直到该窗口过程处理该消息之前不会返回。 这与[PostMessage](#postmessage)成员函数不同，该函数将消息放入窗口的消息队列并立即返回。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndsendmessagetodescendants"></a><a name="sendmessagetodescendants"></a>Cwnd：：向后代发送消息

调用此成员函数将指定的 Windows 消息发送到所有后代窗口。

```
void SendMessageToDescendants(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0,
    BOOL bDeep = TRUE,
    BOOL bOnlyPerm = FALSE);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要发送的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

*bDeep*<br/>
指定要搜索到的级别。 如果为 TRUE，则递归地搜索所有子级;如果 FALSE，则仅搜索直系子。

*b 只*<br/>
指定是否由临时窗口接收消息。 如果为 TRUE，临时窗口可以接收消息;如果为 TRUE，则临时窗口可以接收消息。如果 FALSE，则只有永久窗口才会收到消息。 有关临时窗口的详细信息，请参阅[技术说明 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="remarks"></a>备注

如果*bDeep*是 FALSE，则消息将仅发送给窗口的直系子级;否则，消息将发送到所有后代窗口。

如果*bDeep*和*bOnlyPerm*为 TRUE，则搜索将继续在临时窗口下方。 在这种情况下，搜索期间遇到的永久窗口才会收到消息。 如果*bDeep*是 FALSE，则消息仅发送给窗口的直系子级。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]

## <a name="cwndsendnotifymessage"></a><a name="sendnotifymessage"></a>CWnd：：发送通知消息

将指定的消息发送到窗口。

```
BOOL SendNotifyMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要发送的消息。

*wParam*<br/>
指定其他与消息相关的信息。

*lParam*<br/>
指定其他与消息相关的信息。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果窗口由调用线程创建，`SendNotifyMessage`请调用窗口的窗口过程，直到窗口过程处理该消息才返回。 如果窗口由其他线程创建，`SendNotifyMessage`则将消息传递到窗口过程并立即返回;如果窗口由其他线程创建，则将消息传递到窗口过程，然后返回窗口。它不等待窗口过程完成消息的处理。

## <a name="cwndsetactivewindow"></a><a name="setactivewindow"></a>CWnd：：设置活动窗口

使`CWnd`活动窗口。

```
CWnd* SetActiveWindow();
```

### <a name="return-value"></a>返回值

以前处于活动状态的窗口。

返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

`SetActiveWindow`成员函数应谨慎使用，因为它允许应用程序任意接管活动窗口和输入焦点。 通常，Windows 负责所有激活。

## <a name="cwndsetcapture"></a><a name="setcapture"></a>CWnd：：设置捕获

导致所有后续鼠标输入发送到当前`CWnd`对象，而不考虑光标的位置。

```
CWnd* SetCapture();
```

### <a name="return-value"></a>返回值

指向以前接收所有鼠标输入的窗口对象的指针。 如果没有这样的窗口，则为 NULL。 返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

当`CWnd`不再需要所有鼠标输入时，应用程序应调用[ReleaseCapture](/windows/win32/api/winuser/nf-winuser-releasecapture)函数，以便其他窗口可以接收鼠标输入。

捕获鼠标输入时，不会向活动窗口发送WM_NCHITTEST或WM_SETCURSOR消息。

## <a name="cwndsetcaretpos"></a><a name="setcaretpos"></a>CWnd：：SetCaretPos

设置卡便的位置。

```
static void PASCAL SetCaretPos(POINT point);
```

### <a name="parameters"></a>参数

*点*<br/>
指定 caret 的新 x 和 y 坐标（在客户端坐标中）。

### <a name="remarks"></a>备注

仅当`SetCaretPos`该图由当前任务中的窗口拥有时，成员函数才会移动该 caret。 `SetCaretPos`移动护理是否隐藏。

care 是共享资源。 如果窗口不拥有该图子，则不应移动该图。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]

## <a name="cwndsetclipboardviewer"></a><a name="setclipboardviewer"></a>CWnd：：设置剪贴板查看器

每当剪贴板的内容发生更改时，都会将此窗口添加到通知（通过WM_DRAWCLIPBOARD消息）的窗口链中。

```
HWND SetClipboardViewer();
```

### <a name="return-value"></a>返回值

如果成功，则对剪贴板-查看器链中下一个窗口的句柄。 应用程序应保存此句柄（它可以作为成员变量存储），并在响应剪贴板-查看器链消息时使用它。

### <a name="remarks"></a>备注

作为剪贴板查看器链一部分的窗口必须响应[WM_DRAWCLIPBOARD、WM_CHANGECBCHAIN](#onchangecbchain)[WM_DRAWCLIPBOARD](#ondrawclipboard)和[消息WM_DESTROY，](#ondestroy)并将消息传递到链中的下一个窗口。

此成员函数向窗口发送WM_DRAWCLIPBOARD消息。 由于尚未返回 Clipboard-查看器链中下一个窗口的句柄，因此应用程序不应传递它在调用 期间接收到 的消息WM_DRAWCLIPBOARD`SetClipboardViewer`消息。

要从剪贴板查看器链中删除自身，应用程序必须调用[ChangeClipboard 链](#changeclipboardchain)成员函数。

## <a name="cwndsetdlgctrlid"></a><a name="setdlgctrlid"></a>CWnd：：SetDlgCtrlID

将窗口的窗口 ID 或控件 ID 设置为新值。

```
int SetDlgCtrlID(int nID);
```

### <a name="parameters"></a>参数

*nID*<br/>
要为控件的标识符设置的新值。

### <a name="return-value"></a>返回值

窗口的上一个标识符（如果成功）;否则 0。

### <a name="remarks"></a>备注

窗口可以是任何子窗口，而不仅仅是对话框中的控件。 窗口不能是顶级窗口。

## <a name="cwndsetdlgitemint"></a><a name="setdlgitemint"></a>Cwnd：：塞特德格·特斯特

在对话框中设置给定控件的文本到指定整数值的字符串表示形式。

```
void SetDlgItemInt(
    int nID,
    UINT nValue,
    BOOL bSigned = TRUE);
```

### <a name="parameters"></a>参数

*nID*<br/>
指定要更改的控件的整数 ID。

*n值*<br/>
指定用于生成项文本的整数值。

*b签名*<br/>
指定整数值是签名还是未签名。 如果此参数为 TRUE，则*对 nValue*进行签名。 如果此参数为*TRUE，nValue*小于 0，则在字符串中的第一个数字之前放置一个减号。 如果此参数为 FALSE，*则 nValue*是无符号的。

### <a name="remarks"></a>备注

`SetDlgItemInt`向给定控件发送[WM_SETTEXT](/windows/win32/winmsg/wm-settext)消息。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：setDlgItemText](#setdlgitemtext)。

## <a name="cwndsetdlgitemtext"></a><a name="setdlgitemtext"></a>Cwnd：：SetDlgItemText

设置窗口或对话框拥有的控件的标题或文本。

```
void SetDlgItemText(
    int nID,
    LPCTSTR lpszString);
```

### <a name="parameters"></a>参数

*nID*<br/>
标识要设置其文本的控件。

*lpszString*<br/>
指向包含要复制到控件的文本的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象或空端接字符串。

### <a name="remarks"></a>备注

`SetDlgItemText`向给定控件发送[WM_SETTEXT](/windows/win32/winmsg/wm-settext)消息。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]

## <a name="cwndsetforegroundwindow"></a><a name="setforegroundwindow"></a>CWnd：：设置前景窗口

将创建窗口的线程置于前台，并激活窗口。

```
BOOL SetForegroundWindow();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

键盘输入定向到窗口，并更改用户的各种视觉提示。 前景窗口是用户当前正在使用的窗口。 前景窗口仅适用于顶级窗口（框架窗口或对话框）。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：查找窗口](#findwindow)。

## <a name="cwndsetfocus"></a><a name="setfocus"></a>CWnd：：设置焦点

声明输入焦点。

```
CWnd* SetFocus();
```

### <a name="return-value"></a>返回值

指向以前具有输入焦点的窗口对象的指针。 如果没有这样的窗口，则为 NULL。 返回的指针可能是临时的，不应存储。

### <a name="remarks"></a>备注

输入焦点将所有后续键盘输入定向到此窗口。 以前具有输入焦点的任何窗口都丢失它。

成员`SetFocus`函数向丢失输入焦点的窗口发送[WM_KILLFOCUS](/windows/win32/inputdev/wm-killfocus)消息，向接收输入焦点的窗口发送[WM_SETFOCUS](/windows/win32/inputdev/wm-setfocus)消息。 它还激活窗口或其父级。

如果当前窗口处于活动状态但没有焦点（即没有窗口具有焦点），则按下的任何键都会生成[消息WM_SYSCHAR、WM_SYSKEYDOWN](#onsyschar)或[WM_SYSKEYUP](#onsyskeyup)。 [WM_SYSKEYDOWN](#onsyskeydown)

## <a name="cwndsetfont"></a><a name="setfont"></a>CWnd：：SetFont

将WM_SETFONT消息发送到窗口以使用指定的字体。

```
void SetFont(
    CFont* pFont,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>参数

*pFont*<br/>
指向 `CFont` 对象的指针。

*bredraw*<br/>
如果窗口在处理WM_SETFONT消息后立即重绘，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

除非窗口处理WM_SETFONT消息，否则此方法无效。 许多 MFC 类从`CWnd`处理此消息派生，因为它们附加到预定义的窗口类，该类包含WM_SETFONT消息的消息处理程序。 要使用此方法，派生自的`CWnd`类必须为WM_SETFONT消息定义方法处理程序。

## <a name="cwndseticon"></a><a name="seticon"></a>CWnd：：SetIcon

调用此成员函数将句柄设置为特定图标，由*hIcon*标识。

```
HICON SetIcon(
    HICON hIcon,
    BOOL bBigIcon);
```

### <a name="parameters"></a>参数

*hIcon*<br/>
前一个图标的句柄。

*bBigIcon*<br/>
如果为 TRUE，则指定 32 像素 x 32 像素图标;如果 FALSE，则指定 16 像素 x 16 像素图标。

### <a name="return-value"></a>返回值

图标的图柄。

### <a name="remarks"></a>备注

注册窗口类时，它将选择一个图标。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：获取系统菜单](#getsystemmenu)。

## <a name="cwndsetlayeredwindowattributes"></a><a name="setlayeredwindowattributes"></a>CWnd：：设置分层窗口属性

设置分层窗口的不透明度和透明度颜色键。

```
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
```

### <a name="parameters"></a>参数

*crKey*<br/>
指向 COLORREF 值的指针，该值指定在组合分层窗口时要使用的透明度颜色键。 此颜色的窗口绘制的所有像素都将是透明的。 要生成 COLORREF，请使用 RGB 宏。

*b阿尔法*<br/>
用于描述分层窗口的不恰当性的 Alpha 值。 有关详细信息，请参阅`SourceConstantAlpha`[BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction)结构的成员。 当*bAlpha*为 0 时，窗口是完全透明的。 当*bAlpha*为 255 时，窗口是不透明的。

dwFlags**<br/>
指定要执行的操作。 此参数可以是以下一个或多个值。 有关可能值的列表，请参阅[设置分层窗口属性](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[SetLayeredWindowattributes](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)的功能，如 Windows SDK 中所述。

## <a name="cwndsetmenu"></a><a name="setmenu"></a>CWnd：：SetMenu

将当前菜单设置到指定的菜单。

```
BOOL SetMenu(CMenu* pMenu);
```

### <a name="parameters"></a>参数

*pMenu*<br/>
标识新菜单。 如果此参数为 NULL，则删除当前菜单。

### <a name="return-value"></a>返回值

如果菜单已更改，则非零;否则 0。

### <a name="remarks"></a>备注

使窗口重新绘制以反映菜单更改。

`SetMenu`不会破坏以前的菜单。 应用程序应调用[CMenu：:DestroyMenu](../../mfc/reference/cmenu-class.md#destroymenu)成员函数来完成此任务。

### <a name="example"></a>示例

  请参阅[CMenu：：LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)的示例。

## <a name="cwndsetowner"></a><a name="setowner"></a>CWnd：：SetOwner

将当前窗口的所有者设置到指定的窗口对象。

```
void SetOwner(CWnd* pOwnerWnd);
```

### <a name="parameters"></a>参数

*普恩·恩德*<br/>
标识窗口对象的新所有者。 如果此参数为 NULL，则窗口对象没有所有者。

### <a name="remarks"></a>备注

然后，此所有者可以从当前窗口对象接收命令消息。 默认情况下，当前窗口的父窗口是其所有者。

在窗口层次结构无关的窗口对象之间建立连接通常很有用。 例如[，CToolBar](../../mfc/reference/ctoolbar-class.md)会向其所有者发送通知，而不是向其父级发送通知。 这允许工具栏成为一个窗口（如 OLE 容器应用程序窗口）的子窗口，同时向另一个窗口（如就地框架窗口）发送通知。 此外，当服务器窗口在就地编辑期间停用或激活时，帧窗口拥有的任何窗口将隐藏或显示。 此所有权与 调用`SetOwner`显式设置。

该函数的所有权概念不同于[GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的所有权概念。

## <a name="cwndsetparent"></a><a name="setparent"></a>CWnd：：设置父级

更改子窗口的父窗口。

```
CWnd* SetParent(CWnd* pWndNewParent);
```

### <a name="parameters"></a>参数

*pWnd 新家长*<br/>
标识新的父窗口。

### <a name="return-value"></a>返回值

如果成功，指向前一个父窗口对象的指针。 返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

如果子窗口可见，Windows 将执行相应的重绘和重绘。

## <a name="cwndsetproperty"></a><a name="setproperty"></a>CWnd：：Set属性

调用此成员函数以设置*dwDispID*指定的 OLE 控件属性。

```
void AFX_CDECL SetProperty(
    DISPID dwDispID,
    VARTYPE vtProp, ...);
```

### <a name="parameters"></a>参数

*dwDispID*<br/>
标识要设置的属性。

*vtProp*<br/>
指定要设置的属性的类型。 有关可能的值，请参阅备注部分 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。

*...*<br/>
*vtProp*指定的类型的单个参数。

### <a name="remarks"></a>备注

> [!NOTE]
> 此函数应仅在表示 OLE`CWnd`控件的对象上调用。

有关将此成员函数与 OLE 控制容器一起使用的详细信息，请参阅文章[ActiveX 控制容器：在 ActiveX 控件容器中编程 ActiveX 控件](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndsetredraw"></a><a name="setredraw"></a>CWnd：：设置重新绘制

应用程序调用`SetRedraw`以允许重绘更改或防止重绘更改。

```
void SetRedraw(BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>参数

*bredraw*<br/>
指定重绘标志的状态。 如果此参数为 TRUE，则设置重绘标志;如果此参数为 TRUE，则重新绘制标志将设置为 TRUE。如果 FALSE，则清除标志。

### <a name="remarks"></a>备注

此成员函数设置或清除重绘标志。 清除重绘标志时，每次更改后不会更新内容，在设置重绘标志之前不会重新绘制。 例如，需要向列表框添加多个项的应用程序可以清除重绘标志、添加项，然后设置重绘标志。 最后，应用程序可以调用[无效](#invalidate)或[无效 Rect](#invalidaterect)成员函数，以便重新绘制列表框。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]

## <a name="cwndsetscrollinfo"></a><a name="setscrollinfo"></a>CWnd：：SetScrollInfo

调用此成员函数以设置`SCROLLINFO`结构维护有关滚动条的信息。

```
BOOL SetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定滚动条是控件还是窗口的非工作区的一部分。 如果它是非工作区的一部分，nBar 还会指示滚动条是水平、垂直还是两者兼而有之。 它必须是以下项之一：

- SB_CTL包含滚动条控件的参数。 数据`m_hWnd`成员必须是滚动条控件的句柄。

- SB_HORZ 指定窗口是水平滚动条。

- SB_VERT 指定窗口是垂直滚动条。

*lpScrollInfo*<br/>
指向[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)结构的指针。 有关此结构的详细信息，请参阅 Windows SDK。

*bredraw*<br/>
指定是否应重绘滚动条以反映新位置。 如果*bRedraw*为 TRUE，则重绘滚动条。 如果是 FALSE，则不重绘。 默认情况下，滚动条将重绘。

### <a name="return-value"></a>返回值

如果成功，则返回为 TRUE。 否则，它是 FALSE。

### <a name="remarks"></a>备注

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)结构包含有关滚动条的信息，包括最小和最大滚动位置、页面大小和滚动框（拇指）的位置。 有关更改`SCROLLINFO`结构默认值的详细信息，请参阅 Windows SDK 中的结构主题。

指示滚动条位置的 MFC Windows 消息处理程序[，CWnd：onHScroll](#onhscroll)和[CWnd：：onVScroll，](#onvscroll)仅提供 16 位位置数据。 [GetScrollInfo](#getscrollinfo) `SetScrollInfo`并提供 32 位滚动条位置数据。 因此，应用程序可以在处理或`GetScrollInfo``CWnd::OnHScroll``CWnd::OnVScroll`获取 32 位滚动条位置数据时调用。

> [!NOTE]
> [CWnd：getScrollInfo](#getscrollinfo)使应用程序能够使用 32 位滚动条位置。

## <a name="cwndsetscrollpos"></a><a name="setscrollpos"></a>CWnd：：SetScrollPos

设置滚动框的当前位置，如果请求，请重绘滚动条以反映滚动框的新位置。

```
int SetScrollPos(
    int nBar,
    int nPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定要设置的滚动条。 此参数可以是以下任一参数：

- SB_HORZ 设置窗口水平滚动条中的滚动框的位置。

- SB_VERT 设置窗口垂直滚动栏中的滚动框的位置。

*nPos*<br/>
指定滚动框的新位置。 它必须在滚动范围内。

*bredraw*<br/>
指定是否应重新绘制滚动条以反映新的滚动框位置。 如果此参数为 TRUE，则重新绘制滚动条;如果此参数为 TRUE，则重新绘制滚动条。如果 FALSE，则滚动条不会重新绘制。

### <a name="return-value"></a>返回值

滚动框的上一个位置。

### <a name="remarks"></a>备注

每当滚动条由后续调用到另一个函数重新绘制时，将*bredraw*设置为 FALSE 非常有用。

## <a name="cwndsetscrollrange"></a><a name="setscrollrange"></a>CWnd：：SetScrollRange

设置给定滚动条的最小和最大位置值。

```
void SetScrollRange(
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定要设置的滚动条。 此参数可以是以下值之一：

- SB_HORZ 设置窗口的水平滚动条的范围。

- SB_VERT 设置窗口垂直滚动条的范围。

*nMinPos*<br/>
指定最小滚动位置。

*nMaxPos*<br/>
指定最大滚动位置。

*bredraw*<br/>
指定是否应重绘滚动条以反映更改。 如果 bRedraw 为 TRUE，则重绘滚动条;如果*bredraw*为 TRUE，则重新绘制滚动条。如果 FALSE，则滚动条不会重绘。

### <a name="remarks"></a>备注

它还可用于隐藏或显示标准滚动条。

应用程序在处理滚动条通知消息时不应调用此函数来隐藏滚动条。

如果调用`SetScrollRange`后立即调用[SetScrollPos](#setscrollpos)成员函数，则`SetScrollPos`成员函数中的*bRedraw*参数应为 0，以防止滚动条绘制两次。

标准滚动条的默认范围为 0 到 100。 滚动条控件的默认范围为空 *（nMinPos*和*nMaxPos*值均为 0）。 *nMinPos*和*nMaxPos*指定的值之间的差异不得大于INT_MAX。

## <a name="cwndsettimer"></a><a name="settimer"></a>CWnd：：SetTimer

安装系统计时器。

```
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,
    UINT nElapse,
    void (CALLBACK* lpfnTimer)(HWND,
    UINT,
    UINT_PTR,
    DWORD));
```

### <a name="parameters"></a>参数

*nIDEvent*<br/>
指定非零计时器标识符。 如果计时器标识符是唯一的，则此值由 返回`SetTimer`。 否则，`SetTimer`确定一个新的唯一值，并返回该值。 对于具有 NULL 回调函数的窗口计时器，该值必须仅对与当前窗口关联的其他窗口计时器是唯一的。 对于回调计时器，该值对于所有进程中的所有计时器都必须是唯一的。 因此，在创建回调计时器时，返回的值很可能与您指定的值不同。

*脱位*<br/>
指定超时值或间隔（以毫秒为单位）。

*lpfnTimer*<br/>
指定处理`TimerProc`[WM_TIMER](/windows/win32/winmsg/wm-timer)消息的应用程序提供的回调函数的地址。 如果此参数为 NULL，则WM_TIMER消息将放置在应用程序的消息队列中并由`CWnd`对象处理。

### <a name="return-value"></a>返回值

如果函数成功，则新计时器的计时器标识符。 此值可能等于也可能不等于通过*nIDEvent*参数传入的值。 应用程序应始终将返回值传递给[KillTimer](#killtimer)成员函数以终止计时器。 如果成功，则非零;否则，0。

### <a name="remarks"></a>备注

指定间隔值，每次间隔过去时，系统都会将WM_TIMER消息发布到安装应用程序的安装消息队列，或将消息传递给应用程序定义的`TimerProc`回调功能。

*lpfnTimer*回调函数不需要命名`TimerProc`，但必须声明为静态函数，并定义如下。

```
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer
    UINT nMsg,   // WM_TIMER
    UINT_PTR nIDEvent,   // timer identification
    DWORD dwTime    // system time);
```

### <a name="example"></a>示例

此示例使用`CWnd::SetTimer``CWnd::OnTimer`和`CWnd::KillTimer`来处理WM_TIMER消息。 第一个计时器设置为在 中`OnStartTimer`每 2 秒向主帧窗口发送WM_TIMER消息。 事件`OnTimer`处理程序处理主框架窗口WM_TIMER消息。 此方法使 PC 扬声器每 2 秒发出一次蜂鸣音。 第二个计时器每 3.75 秒向回调功能发送消息。 `OnStopTimer`将通过调用`CWnd::KillTimer`每个计时器 ID 停止两个计时器。

[!code-cpp[NVC_MFCWindowing#118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]

## <a name="cwndsetwindowcontexthelpid"></a><a name="setwindowcontexthelpid"></a>CWnd：：设置窗口上下文帮助Id

调用此成员函数将帮助上下文标识符与指定的窗口相关联。

```
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```

### <a name="parameters"></a>参数

*dwContextHelpId*<br/>
帮助上下文标识符。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果子窗口没有帮助上下文标识符，它将继承其父窗口的标识符。 同样，如果拥有的窗口没有帮助上下文标识符，它将继承其所有者窗口的标识符。 帮助上下文标识符的这种继承允许应用程序仅为对话框及其所有控件设置一个标识符。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]

## <a name="cwndsetwindowplacement"></a><a name="setwindowplacement"></a>CWnd：：设置窗口放置

设置窗口的显示状态以及正常（已还原）、最小化和最大化位置。

```
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```

### <a name="parameters"></a>参数

*普尔温德普尔*<br/>
指向指定新显示状态和位置的[WINDOW 放置](/windows/win32/api/winuser/ns-winuser-windowplacement)结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cwndsetwindowpos"></a><a name="setwindowpos"></a>CWnd：：设置窗口Pos

更改子窗口、弹出窗口和顶级窗口的大小、位置和 Z 顺序。

```
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*pWndInsert 后*<br/>
标识将在`CWnd`Z 顺序中在此`CWnd`对象之前（高于）的对象。 此参数可以是指向 或`CWnd`指向以下值之一的指针：

- `wndBottom`将窗口放在 Z 顺序的底部。 如果这是最`CWnd`顶层的窗口，则窗口将失去其最上面状态;如果该窗口是最顶层窗口。"系统将窗口放在所有其他窗口的底部。

- `wndTop`将窗口放在 Z 顺序的顶部。

- `wndTopMost`将窗口置于所有非顶部窗口之上。 即使该窗口已停用，该窗口也能保持其最顶层位置。

- `wndNoTopMost`将窗口重新定位到所有非最顶层窗口的顶部（即所有最顶层窗口后面）。 如果窗口已经是非最顶层的窗口，则此标志不起作用。

有关如何使用此参数的规则，请参阅本主题的"备注"部分。

** x <br/>
指定窗口左侧的新位置。

*Y*<br/>
指定窗口顶部的新位置。

*残雪*<br/>
指定窗口的新宽度。

*cy*<br/>
指定窗口的新高度。

*nFlags*<br/>
指定大小调整和定位选项。 此参数可以是以下标志的组合：

- SWP_DRAWFRAME在窗口周围绘制框架（在创建窗口时定义）。

- SWP_FRAMECHANGED向窗口发送WM_NCCALCSIZE消息，即使窗口的大小未更改也是如此。 如果未指定此标志，则仅在更改窗口大小时发送WM_NCCALCSIZE。

- SWP_HIDEWINDOW隐藏窗口。

- SWP_NOACTIVATE不激活窗口。 如果未设置此标志，则窗口将激活并移动到最顶层或最顶层组的顶部（具体取决于*pWndInsert 后*参数的设置）。

- SWP_NOCOPYBITS丢弃工作区的全部内容。 如果未指定此标志，则在窗口调整大小或重新定位后，将保存工作区的有效内容并复制回工作区。

- SWP_NOMOVE 保留当前位置（忽略*x*和*y*参数）。

- SWP_NOOWNERZORDER不更改所有者窗口在 Z 顺序中的位置。

- SWP_NOREDRAW不重绘更改。 如果设置了此标志，则不进行任何重新绘制。 这适用于工作区、非工作区（包括标题和滚动条）以及因移动窗口而打开的父窗口的任何部分。 设置此标志时，应用程序必须显式无效或重绘窗口和父窗口必须重绘的任何部分。

- SWP_NOREPOSITION 与SWP_NOOWNERZORDER相同。

- SWP_NOSENDCHANGING 防止窗口接收WM_WINDOWPOSCHANGING消息。

- SWP_NOSIZE 保留当前大小（忽略*cx*和*cy*参数）。

- SWP_NOZORDER 保留当前排序（忽略*pWndInsert 后*）。

- SWP_SHOWWINDOW 显示窗口。

### <a name="return-value"></a>返回值

如果函数成功，则非零;否则，0。

### <a name="remarks"></a>备注

视窗按 Z 顺序在屏幕上订购;Z 顺序顶部的窗口显示在顺序中所有其他窗口的顶部。

子窗口的所有坐标都是客户端坐标（相对于父窗口工作区的左上角）。

窗口可以通过将*pWndInsertAfter*参数设置为 **&wndTopMost**并确保未设置SWP_NOZORDER标志或设置窗口的 Z 顺序，使其位于任何现有最顶层窗口之上，从而将窗口移动到 Z 顺序的顶部。 当非最顶层窗口位于最上面时，其拥有的窗口也会成为最顶端的窗口。 其所有者不会更改。

如果最顶层窗口重新定位到 Z 顺序的底部 **（&wndBottom）** 或任何非最顶层窗口之后，则该窗口将不再最顶端。 当最顶层的窗口非顶部时，其所有所有者及其拥有的窗口也创建非最顶端窗口。

如果未指定SWP_NOACTIVATE或SWP_NOZORDER（即，当应用程序请求同时激活窗口并将其置于指定的 Z 顺序中时），则仅在以下情况下使用*pWndInsert 后*指定的值：

- **&wndTopMost**或 **&wndNoTopMost**在*pwndInsert 后参数*中指定。

- 此窗口不是活动窗口。

应用程序无法激活非活动窗口，而不将其带到 Z 顺序的顶部。 应用程序可以不受限制地更改激活窗口的 Z 顺序。

非最顶层窗口可能拥有最顶层窗口，但反之亦然。 最顶层窗口拥有的任何窗口（例如，对话框）本身都是最顶层的窗口，以确保所有拥有的窗口都位于其所有者之上。

使用 Windows 版本 3.1 及更高版本时，窗口可以移动到 Z 顺序的顶部，并通过设置其WS_EX_TOPMOST样式将其锁定在那里。 即使停用，这种最顶层的窗口也能保持其最顶层的位置。 例如，选择"WinHelp 始终位于顶部"命令使"帮助"窗口成为最顶层，然后在返回到应用程序时保持可见。

若要创建最顶层窗口，请在创建`SetWindowPos`窗口时使用*pWndInsert 后参数*&**wndTopMost**调用，或在创建窗口时设置WS_EX_TOPMOST样式。

如果 Z 顺序包含具有WS_EX_TOPMOST样式的任何窗口，则使用 **&wndTopMost**值移动的窗口将放置在所有非最顶层窗口的顶部，但位于任何最顶层窗口的下方。 当应用程序激活没有WS_EX_TOPMOST位的非活动窗口时，该窗口将移动到所有非最顶层窗口之上，但位于任何最顶层窗口下方。

如果在`SetWindowPos` *pwndInsert 后一个*参数 **&wndBottom** `CWnd`并且是最顶端窗口时调用，则窗口将失去其最上面状态（WS_EX_TOPMOST清除），并且系统将窗口置于 Z 顺序的底部。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]

## <a name="cwndsetwindowrgn"></a><a name="setwindowrgn"></a>Cwnd：：SetWindowRgn

调用此成员函数以设置窗口的区域。

```
int SetWindowRgn(
    HRGN hRgn,
    BOOL bRedraw);
```

### <a name="parameters"></a>参数

*hRgn*<br/>
区域句柄。

*bredraw*<br/>
如果为 TRUE，操作系统在设置区域后重绘窗口;如果为 TRUE，则在设置区域后重新绘制窗口。否则，它不。 通常，如果窗口可见，则将*bredraw*设置为 TRUE。 如果设置为 TRUE，系统会向窗口发送WM_WINDOWPOSCHANGING并WM_WINDOWPOSCHANGED消息。

### <a name="return-value"></a>返回值

如果函数成功，则返回值为非零。 如果函数失败，则返回值为零。

### <a name="remarks"></a>备注

窗口窗口区域的坐标相对于窗口的左上角，而不是窗口的工作区。

成功调用 后`SetWindowRgn`， 操作系统拥有区域句柄*hRgn*指定的区域。 操作系统不创建区域的副本，因此不要使用此区域句柄进行任何进一步的函数调用，也不会关闭此区域句柄。

## <a name="cwndsetwindowtext"></a><a name="setwindowtext"></a>CWnd：：设置窗口文本

将窗口的标题设置为指定的文本。

```
void SetWindowText(LPCTSTR lpszString);
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象或 null 终止字符串，以用作新标题或控件文本。

### <a name="remarks"></a>备注

如果窗口是控件，则设置控件中的文本。

此功能会导致[将WM_SETTEXT](/windows/win32/winmsg/wm-settext)消息发送到此窗口。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]

## <a name="cwndshowcaret"></a><a name="showcaret"></a>CWnd：：秀卡丁

在护台的当前位置显示屏幕上的护台。

```
void ShowCaret();
```

### <a name="remarks"></a>备注

显示之后，插入符号开始自动闪烁。

仅当`ShowCaret`该图具有当前形状且未连续隐藏两次或更多次时，成员函数才会显示该 care。 如果该护图不归此窗口所有，则不显示该护图。

隐藏隐匿是累积的。 如果连续调用了五次[HideCaret](#hidecaret)成员函数，`ShowCaret`则必须调用五次才能显示该图。

care 是共享资源。 仅当具有输入焦点或处于活动状态时，窗口才应显示该说明。

### <a name="example"></a>示例

  请参阅[CWnd 示例：createCare。](#createcaret)

## <a name="cwndshowownedpopups"></a><a name="showownedpopups"></a>CWnd：：显示拥有的Popups

显示或隐藏此窗口拥有的所有弹出窗口。

```
void ShowOwnedPopups(BOOL bShow = TRUE);
```

### <a name="parameters"></a>参数

*b显示*<br/>
指定弹出窗口是显示还是隐藏。 如果此参数为 TRUE，则显示所有隐藏的弹出窗口。 如果此参数为 FALSE，则所有可见的弹出窗口都将隐藏。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：SetWindowPos](#setwindowpos)。

## <a name="cwndshowscrollbar"></a><a name="showscrollbar"></a>CWnd：：显示滚动栏

显示或隐藏滚动条。

```
void ShowScrollBar(
    UINT nBar,
    BOOL bShow = TRUE);
```

### <a name="parameters"></a>参数

*nBar*<br/>
指定滚动条是控件还是窗口的非工作区的一部分。 如果它是非工作区的一部分 *，nBar*还会指示滚动条是水平、垂直还是两者兼而有之。 它必须是以下项之一：

- SB_BOTH 指定窗口的水平和垂直滚动条。

- SB_HORZ 指定窗口是水平滚动条。

- SB_VERT 指定窗口是垂直滚动条。

*b显示*<br/>
指定 Windows 是显示还是隐藏滚动条。 如果此参数为 TRUE，将显示滚动条;如果此参数为 TRUE，则显示滚动条。否则滚动条将隐藏。

### <a name="remarks"></a>备注

在处理滚动条通知消息`ShowScrollBar`时，应用程序不应调用以隐藏滚动条。

## <a name="cwndshowwindow"></a><a name="showwindow"></a>CWnd：：显示窗口

设置窗口的可见性状态。

```
BOOL ShowWindow(int nCmdShow);
```

### <a name="parameters"></a>参数

*nCmdShow*<br/>
指定如何显示`CWnd`。 它必须是以下值之一：

- SW_HIDE隐藏此窗口并将激活传递到另一个窗口。

- SW_MINIMIZE最小化窗口并激活系统列表中的顶级窗口。

- SW_RESTORE 激活并显示窗口。 如果窗口最小化或最大化，Windows 会将其还原到其原始大小和位置。

- SW_SHOW激活窗口，并将其以当前大小和位置显示。

- SW_SHOWMAXIMIZED激活窗口并将其显示为最大化窗口。

- SW_SHOWMINIMIZED激活窗口并将其显示为图标。

- SW_SHOWMINNOACTIVE将窗口显示为图标。 当前处于活动状态的窗口保持活动状态。

- SW_SHOWNA 显示窗口当前状态。 当前处于活动状态的窗口保持活动状态。

- SW_SHOWNOACTIVATE 以最新的大小和位置显示窗口。 当前处于活动状态的窗口保持活动状态。

- SW_SHOWNORMAL 激活并显示窗口。 如果窗口最小化或最大化，Windows 会将其还原到其原始大小和位置。

### <a name="return-value"></a>返回值

如果窗口以前可见，则非零;0，`CWnd`如果以前隐藏。

### <a name="remarks"></a>备注

`ShowWindow`对于[CWinApp：：m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)的主窗口，每个应用程序只能调用一次。 后续调用`ShowWindow`必须使用上面列出的值之一，而不是 指定的`CWinApp::m_nCmdShow`值之一。

### <a name="example"></a>示例

  请参阅[CWnd：：CalcWindowRect 的示例](#calcwindowrect)。

## <a name="cwndsubclassdlgitem"></a><a name="subclassdlgitem"></a>Cwnd：：子类Dlg项目

将此成员函数调用"动态子类"从对话框模板创建的控件并将其附加到此`CWnd`对象。

```
BOOL SubclassDlgItem(
    UINT nID,
    CWnd* pParent);
```

### <a name="parameters"></a>参数

*nID*<br/>
控件的 ID。

*p 父级*<br/>
控件的父级（通常是对话框）。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

当控件动态下课时，窗口消息将路由通过`CWnd`''的消息映射和调用消息处理程序在`CWnd`''类第一。 传递给基类的消息将传递到控件中的默认消息处理程序。

此成员函数将 Windows 控件附加到`CWnd`对象，并替换控件和`WndProc``AfxWndProc`函数。 该函数将旧存储在`WndProc``GetSuperWndProcAddr`成员函数返回的位置中。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]

## <a name="cwndsubclasswindow"></a><a name="subclasswindow"></a>CWnd：：子类窗口

将此成员函数调用为"动态子类"窗口并将其附加到此`CWnd`对象。

```
BOOL SubclassWindow(HWND hWnd);
```

### <a name="parameters"></a>参数

*hwnd*<br/>
窗口的句柄。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

动态子分类窗口时，窗口消息将路由通过`CWnd`'的消息映射和调用消息处理程序在`CWnd`''类第一。 传递给基类的消息将传递到窗口中的默认消息处理程序。

此成员函数将 Windows 控件附加到`CWnd`对象，并替换窗口和`WndProc``AfxWndProc`函数。 函数在对象中存储指向旧`WndProc`项的`CWnd`指针。

> [!NOTE]
> 调用此函数时，窗口不能已附加到 MFC 对象。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]

## <a name="cwndunlockwindowupdate"></a><a name="unlockwindowupdate"></a>CWnd：：解锁窗口更新

调用此成员函数以解锁与`CWnd::LockWindowUpdate`锁定的窗口。

```
void UnlockWindowUpdate();
```

### <a name="remarks"></a>备注

一次只能使用锁定一个窗口`LockWindowUpdate`。 有关锁定窗口的详细信息，请参阅[CWnd：锁窗口更新](#lockwindowupdate)或 Win32 功能[LockWindow 更新](/windows/win32/api/winuser/nf-winuser-lockwindowupdate)。

## <a name="cwndunsubclasswindow"></a><a name="unsubclasswindow"></a>CWnd：：取消子类窗口

调用此成员函数以将其`WndProc`设置回其原始值，并将 HWND 标识的窗口从`CWnd`对象中分离出来。

```
HWND UnsubclassWindow();
```

### <a name="return-value"></a>返回值

未下分类窗口的句柄。

### <a name="example"></a>示例

  请参阅[CWnd：：子类窗口](#subclasswindow)的示例。

## <a name="cwndupdatedata"></a><a name="updatedata"></a>CWnd：：更新数据

调用此成员函数以在对话框中初始化数据，或检索和验证对话框数据。

```
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```

### <a name="parameters"></a>参数

*b 保存和验证*<br/>
指示正在初始化对话框 （FALSE） 还是正在检索数据 （TRUE） 的标志。

### <a name="return-value"></a>返回值

如果操作成功，则非零;否则 0。 如果*bSaveAndValidat*e 为 TRUE，则非零的返回值表示已成功验证数据。

### <a name="remarks"></a>备注

当在`UpdateData`[CDialog：：OnitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)的默认实现中创建模式对话框时，框架会自动调用*bSaveAndValidate*设置为 FALSE。 调用在对话框可见之前进行。 [CDialog：onOK](../../mfc/reference/cdialog-class.md#onok)的默认实现调用此成员函数 *，bSaveAndValidate*设置为 TRUE 以检索数据，如果成功，将关闭该对话框。 （如果在对话框中单击"取消"按钮，则对话框将关闭，而不会检索数据。

## <a name="cwndupdatedialogcontrols"></a><a name="updatedialogcontrols"></a>CWnd：：更新对话控制

调用此成员函数以更新对话框或窗口中使用[ON_UPDATE_COMMAND_UI](message-map-macros-mfc.md#on_update_command_ui)回调机制的对话框或窗口中的对话框或其他控件的状态。

```
void UpdateDialogControls(
    CCmdTarget* pTarget,
    BOOL bDisableIfNoHndler);
```

### <a name="parameters"></a>参数

*p目标*<br/>
指向应用程序的主框架窗口，用于路由更新消息。

*b 禁用IfNoHndler*<br/>
指示是否应自动显示为禁用的控件的标志。

### <a name="remarks"></a>备注

如果子控件没有处理程序，并且*bDisableIfNohndler*为 TRUE，则子控件将被禁用。

框架调用此成员函数用于对话框栏或工具栏中的控件，作为应用程序空闲处理的一部分。

## <a name="cwndupdatelayeredwindow"></a><a name="updatelayeredwindow"></a>CWnd：：更新分层窗口

更新分层窗口的位置、大小、形状、内容和透明度。

```
BOOL UpdateLayeredWindow(
    CDC* pDCDst,
    POINT* pptDst,
    SIZE* psize,
    CDC* pDCSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
```

### <a name="parameters"></a>参数

*pDCDst*<br/>
指向屏幕的设备上下文的指针。 它用于更新窗口内容时的调色板颜色匹配。 如果*pDCDst*为 NULL，将使用默认调色板。

如果*pDCSrc*为 NULL，*则 pDCDst*必须为 NULL。

*普特德斯特*<br/>
指向指定分层窗口`POINT`的新屏幕位置的结构的指针。 如果当前位置未更改，则*pptDst*可以是 NULL。

*psize*<br/>
指向指定分层`SIZE`窗口的新大小的结构的指针。 如果窗口的大小没有变化，*则大小*可以为 NULL。

如果*pDCSrc*为 NULL，*则大小*必须为 NULL。

*pDCSrc*<br/>
指向定义分层窗口的曲面的 DC 的指针。 如果窗口的形状和可视上下文未更改 *，pDCSrc*可以为 NULL。

*pptSrc*<br/>
指向`POINT`指定图层在设备上下文中位置的结构的指针。

如果*pDCSrc*为 NULL，则*pptSrc*应为 NULL。

*crKey*<br/>
指向 COLORREF 值的指针，该值指定在组合分层窗口时要使用的透明度颜色键。 此颜色的窗口绘制的所有像素都将是透明的。 要生成 COLORREF，请使用 RGB 宏。

*pblend*<br/>
指向[BLEND工作](/windows/win32/api/wingdi/ns-wingdi-blendfunction)结构的指针，该结构指定在组合分层窗口时要使用的透明度值。

dwFlags**<br/>
指定要执行的操作。 此参数可以是以下一个或多个值。 有关可能值的列表，请参阅[更新分层窗口](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值；否则为

### <a name="remarks"></a>备注

此成员函数模拟函数[UpdateLayeredWindow](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)的功能，如 Windows SDK 中所述。

## <a name="cwndupdatewindow"></a><a name="updatewindow"></a>CWnd：：更新窗口

如果更新区域不为空，则通过发送[WM_PAINT](/windows/win32/gdi/wm-paint)消息更新工作区。

```
void UpdateWindow();
```

### <a name="remarks"></a>备注

成员`UpdateWindow`函数绕过应用程序队列直接发送WM_PAINT消息。 如果更新区域为空，则不发送WM_PAINT。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCWindowing#124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]

## <a name="cwndvalidaterect"></a><a name="validaterect"></a>CWnd：：验证雷ct

通过从窗口的更新区域中删除矩形，验证给定矩形中的工作区。

```
void ValidateRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含要从更新区域中删除的矩形的客户端坐标的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象或[RECT 结构](/windows/win32/api/windef/ns-windef-rect)。 如果*lpRect*为 NULL，则验证整个窗口。

### <a name="remarks"></a>备注

[BeginPaint](#beginpaint)成员函数会自动验证整个工作区。 `ValidateRect`如果在下次生成[WM_PAINT](/windows/win32/gdi/wm-paint)之前需要验证更新区域的一部分，则不应调用[验证和验证 Rgn](#validatergn)成员函数。

Windows 将继续生成WM_PAINT消息，直到验证当前更新区域。

## <a name="cwndvalidatergn"></a><a name="validatergn"></a>CWnd：验证Rgn

通过从窗口的当前更新区域中删除区域来验证给定区域内的工作区。

```
void ValidateRgn(CRgn* pRgn);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向[CRgn](../../mfc/reference/crgn-class.md)对象的指针，用于标识定义要从更新区域中删除的区域的区域。 如果此参数为 NULL，则删除整个工作区。

### <a name="remarks"></a>备注

给定区域以前必须由区域函数创建。 区域坐标假定为客户端坐标。

[BeginPaint](#beginpaint)成员函数会自动验证整个工作区。 如果在生成下一[WM_PAINT](/windows/win32/gdi/wm-paint)消息之前`ValidateRgn`必须验证更新区域的一部分，则不应调用[验证雷Ct](#validaterect)或成员函数。

## <a name="cwndwindowfrompoint"></a><a name="windowfrompoint"></a>Cwnd：：窗口从点

检索包含指定点的窗口;*点*必须指定屏幕上点的屏幕坐标。

```
static CWnd* PASCAL WindowFromPoint(POINT point);
```

### <a name="parameters"></a>参数

*点*<br/>
指定定义要检查的点的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象或[POINT](/windows/win32/api/windef/ns-windef-point)数据结构。

### <a name="return-value"></a>返回值

指向点所在的窗口对象的指针。 如果给定点上不存在窗口，则为 NULL。 返回的指针可能是临时的，不应存储以供以后使用。

### <a name="remarks"></a>备注

`WindowFromPoint`不会检索隐藏或禁用的窗口，即使该点位于窗口中也是如此。 应用程序应使用[子窗口从点](#childwindowfrompoint)成员函数进行非限制性搜索。

## <a name="cwndwindowproc"></a><a name="windowproc"></a>CWnd：：窗口Proc

为`CWnd`对象提供 Windows`WindowProc`过程 （ ） 。

```
virtual LRESULT WindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*消息*<br/>
指定要处理的 Windows 消息。

*wParam*<br/>
提供用于处理消息的其他信息。 参数值取决于消息。

*lParam*<br/>
提供用于处理消息的其他信息。 参数值取决于消息。

### <a name="return-value"></a>返回值

返回值取决于消息。

### <a name="remarks"></a>备注

它通过窗口的消息映射调度消息。

## <a name="cwndwinhelp"></a><a name="winhelp"></a>CWnd：：赢帮助

调用以启动 WinHelp 应用程序。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>参数

*dwData*<br/>
指定其他数据。 使用的值取决于*nCmd*参数的值。

*nCmd*<br/>
指定请求的帮助的类型。 有关可能值的列表及其如何影响*dwData*参数，请参阅 Windows SDK 中的[WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 功能。

### <a name="remarks"></a>备注

有关详细信息[，请参阅 CWinApp：WinHelp。](../../mfc/reference/cwinapp-class.md#winhelp)

## <a name="cwndregistertouchwindow"></a><a name="registertouchwindow"></a>CWnd：：注册触摸窗口

注册或取消注册 Windows 触摸支持。

```
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,
    ULONG ulFlags = 0);
```

### <a name="parameters"></a>参数

*b 注册*<br/>
TRUE 表示注册 Windows 触摸支持;否则。

*ulFlags*<br/>
指定可选修改的一组位标志。 此字段可能包含 0 或以下值之一：TWF_FINETOUCH，TWF_WANTPALM。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

## <a name="cwndresizedynamiclayout"></a><a name="resizedynamiclayout"></a>CWnd：：调整动态布局

如果对窗口启用了动态布局，则窗口大小更改以调整子窗口布局时会通过框架调用。

```
virtual void ResizeDynamicLayout();
```

### <a name="remarks"></a>备注

## <a name="see-also"></a>另请参阅

[CCmdTarget 类](../../mfc/reference/ccmdtarget-class.md)<br/>
[层次结构图表](../../mfc/hierarchy-chart.md)<br/>
[CFrameWnd 类](../../mfc/reference/cframewnd-class.md)<br/>
[CView 类](../../mfc/reference/cview-class.md)
