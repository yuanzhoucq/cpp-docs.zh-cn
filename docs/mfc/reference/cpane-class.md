---
title: CPane Class
ms.date: 11/04/2016
f1_keywords:
- CPane
- AFXPANE/CPane
- AFXPANE/CPane::AdjustSizeImmediate
- AFXPANE/CPane::AllocElements
- AFXPANE/CPane::AllowShowOnPaneMenu
- AFXPANE/CPane::CalcAvailableSize
- AFXPANE/CPane::CalcInsideRect
- AFXPANE/CPane::CalcRecentDockedRect
- AFXPANE/CPane::CalcSize
- AFXPANE/CPane::CanBeDocked
- AFXPANE/CPane::CanBeTabbedDocument
- AFXPANE/CPane::ConvertToTabbedDocument
- AFXPANE/CPane::CopyState
- AFXPANE/CPane::Create
- AFXPANE/CPane::CreateDefaultMiniframe
- AFXPANE/CPane::CreateEx
- AFXPANE/CPane::DockByMouse
- AFXPANE/CPane::DockPane
- AFXPANE/CPane::DockPaneStandard
- AFXPANE/CPane::DockToFrameWindow
- AFXPANE/CPane::DoesAllowSiblingBars
- AFXPANE/CPane::FloatPane
- AFXPANE/CPane::GetAvailableExpandSize
- AFXPANE/CPane::GetAvailableStretchSize
- AFXPANE/CPane::GetBorders
- AFXPANE/CPane::GetClientHotSpot
- AFXPANE/CPane::GetDockSiteRow
- AFXPANE/CPane::GetExclusiveRowMode
- AFXPANE/CPane::GetHotSpot
- AFXPANE/CPane::GetMinSize
- AFXPANE/CPane::GetPaneName
- AFXPANE/CPane::GetVirtualRect
- AFXPANE/CPane::IsChangeState
- AFXPANE/CPane::IsDragMode
- AFXPANE/CPane::IsInFloatingMultiPaneFrameWnd
- AFXPANE/CPane::IsLeftOf
- AFXPANE/CPane::IsResizable
- AFXPANE/CPane::IsTabbed
- AFXPANE/CPane::LoadState
- AFXPANE/CPane::MoveByAlignment
- AFXPANE/CPane::MovePane
- AFXPANE/CPane::OnAfterChangeParent
- AFXPANE/CPane::OnBeforeChangeParent
- AFXPANE/CPane::OnPressCloseButton
- AFXPANE/CPane::OnShowControlBarMenu
- AFXPANE/CPane::RecalcLayout
- AFXPANE/CPane::SaveState
- AFXPANE/CPane::SetActiveInGroup
- AFXPANE/CPane::SetBorders
- AFXPANE/CPane::SetClientHotSpot
- AFXPANE/CPane::SetDockState
- AFXPANE/CPane::SetExclusiveRowMode
- AFXPANE/CPane::SetMiniFrameRTC
- AFXPANE/CPane::SetMinSize
- AFXPANE/CPane::SetVirtualRect
- AFXPANE/CPane::StretchPaneDeferWndPos
- AFXPANE/CPane::ToggleAutoHide
- AFXPANE/CPane::UndockPane
- AFXPANE/CPane::UpdateVirtualRect
- AFXPANE/CPane::OnAfterDock
- AFXPANE/CPane::OnAfterFloat
- AFXPANE/CPane::OnBeforeDock
- AFXPANE/CPane::OnBeforeFloat
- AFXPANE/CPane::m_bHandleMinSize
- AFXPANE/CPane::m_recentDockInfo
helpviewer_keywords:
- CPane [MFC], AdjustSizeImmediate
- CPane [MFC], AllocElements
- CPane [MFC], AllowShowOnPaneMenu
- CPane [MFC], CalcAvailableSize
- CPane [MFC], CalcInsideRect
- CPane [MFC], CalcRecentDockedRect
- CPane [MFC], CalcSize
- CPane [MFC], CanBeDocked
- CPane [MFC], CanBeTabbedDocument
- CPane [MFC], ConvertToTabbedDocument
- CPane [MFC], CopyState
- CPane [MFC], Create
- CPane [MFC], CreateDefaultMiniframe
- CPane [MFC], CreateEx
- CPane [MFC], DockByMouse
- CPane [MFC], DockPane
- CPane [MFC], DockPaneStandard
- CPane [MFC], DockToFrameWindow
- CPane [MFC], DoesAllowSiblingBars
- CPane [MFC], FloatPane
- CPane [MFC], GetAvailableExpandSize
- CPane [MFC], GetAvailableStretchSize
- CPane [MFC], GetBorders
- CPane [MFC], GetClientHotSpot
- CPane [MFC], GetDockSiteRow
- CPane [MFC], GetExclusiveRowMode
- CPane [MFC], GetHotSpot
- CPane [MFC], GetMinSize
- CPane [MFC], GetPaneName
- CPane [MFC], GetVirtualRect
- CPane [MFC], IsChangeState
- CPane [MFC], IsDragMode
- CPane [MFC], IsInFloatingMultiPaneFrameWnd
- CPane [MFC], IsLeftOf
- CPane [MFC], IsResizable
- CPane [MFC], IsTabbed
- CPane [MFC], LoadState
- CPane [MFC], MoveByAlignment
- CPane [MFC], MovePane
- CPane [MFC], OnAfterChangeParent
- CPane [MFC], OnBeforeChangeParent
- CPane [MFC], OnPressCloseButton
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], RecalcLayout
- CPane [MFC], SaveState
- CPane [MFC], SetActiveInGroup
- CPane [MFC], SetBorders
- CPane [MFC], SetClientHotSpot
- CPane [MFC], SetDockState
- CPane [MFC], SetExclusiveRowMode
- CPane [MFC], SetMiniFrameRTC
- CPane [MFC], SetMinSize
- CPane [MFC], SetVirtualRect
- CPane [MFC], StretchPaneDeferWndPos
- CPane [MFC], ToggleAutoHide
- CPane [MFC], UndockPane
- CPane [MFC], UpdateVirtualRect
- CPane [MFC], OnAfterDock
- CPane [MFC], OnAfterFloat
- CPane [MFC], OnBeforeDock
- CPane [MFC], OnBeforeFloat
- CPane [MFC], m_bHandleMinSize
- CPane [MFC], m_recentDockInfo
ms.assetid: 5c651a64-3c79-4d94-9676-45f6402a6bc5
ms.openlocfilehash: 4609a56c7a7bf6909c687e371b67eeb6e42ae9d9
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/27/2020
ms.locfileid: "87219633"
---
# <a name="cpane-class"></a>CPane Class

`CPane`类是[CControlBar 类](../../mfc/reference/ccontrolbar-class.md)的增强功能。 如果要升级现有 MFC 项目，请将的所有匹配项替换 `CControlBar` 为 `CPane` 。

## <a name="syntax"></a>语法

```
class CPane : public CBasePane
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|`CPane::~CPane`|析构函数。|

### <a name="public-methods"></a>公共方法

|“属性”|描述|
|----------|-----------------|
|[CPane：： AdjustSizeImmediate](#adjustsizeimmediate)|立即重新计算窗格的布局。|
|[CPane：： AllocElements](#allocelements)|分配供内部使用的存储。|
|[CPane：： AllowShowOnPaneMenu](#allowshowonpanemenu)|指定窗格是否在应用程序的运行时生成的窗格列表中列出。|
|[CPane：： CalcAvailableSize](#calcavailablesize)|计算指定矩形与当前窗口矩形之间的大小差异。|
|[CPane：： CalcInsideRect](#calcinsiderect)|计算窗格的内矩形，并考虑边界和控制手柄。|
|[CPane：： CalcRecentDockedRect](#calcrecentdockedrect)|计算最近停靠的矩形。|
|[CPane：： CalcSize](#calcsize)|计算窗格的大小。|
|[CPane：： CanBeDocked](#canbedocked)|确定窗格是否可停靠在指定的基本窗格。|
|[CPane：： CanBeTabbedDocument](#canbetabbeddocument)|确定窗格是否可以转换为选项卡式文档。|
|[CPane：： ConvertToTabbedDocument](#converttotabbeddocument)|将可停靠的窗格转换为选项卡式文档。|
|[CPane：： CopyState](#copystate)|复制窗格的状态。 （重写[CBasePane：： CopyState](../../mfc/reference/cbasepane-class.md#copystate)。）|
|[CPane：： Create](#create)|创建一个控件栏并将其附加到 `CPane` 对象。|
|[CPane：： CreateDefaultMiniframe](#createdefaultminiframe)|为浮动窗格创建微型框架窗口。|
|[CPane：： CreateEx](#createex)|创建一个控件栏并将其附加到 `CPane` 对象。|
|`CPane::CreateObject`|由框架用于创建此类类型的动态实例。|
|[CPane：:D ockByMouse](#dockbymouse)|使用鼠标停靠方法停靠窗格。|
|[CPane：:D ockPane](#dockpane)|将浮动窗格停靠到基本窗格。|
|[CPane：:D ockPaneStandard](#dockpanestandard)|使用轮廓（标准）停靠停靠一个窗格。|
|[CPane：:D ockToFrameWindow](#docktoframewindow)|将可停靠的窗格停靠到帧。 （重写 `CBasePane::DockToFrameWindow`。）|
|[CPane：:D oesAllowSiblingBars](#doesallowsiblingbars)|指示是否可以在当前窗格停靠的同一行上停靠另一个窗格。|
|[CPane：： FloatPane](#floatpane)|在窗格中浮动。|
|[CPane：： GetAvailableExpandSize](#getavailableexpandsize)|返回窗格可以扩展的量（以像素为单位）。|
|[CPane：： GetAvailableStretchSize](#getavailablestretchsize)|返回窗格可以收缩的量（以像素为单位）。|
|[CPane：： GetBorders](#getborders)|返回窗格边框的宽度。|
|[CPane：： GetClientHotSpot](#getclienthotspot)|返回窗格的*热点*。|
|[CPane：： GetDockSiteRow](#getdocksiterow)|返回窗格停靠的停靠行。|
|[CPane：： GetExclusiveRowMode](#getexclusiverowmode)|确定窗格是否处于独占行模式。|
|[CPane：： GetHotSpot](#gethotspot)|返回存储在基础对象中的作用点 `CMFCDragFrameImpl` 。|
|[CPane：： GetMinSize](#getminsize)|检索窗格允许的最小大小。|
|[CPane：： GetPaneName](#getpanename)|检索窗格的标题。|
|`CPane::GetResizeStep`|内部使用。|
|`CPane::GetThisClass`|由框架用于获取指向与此类类型相关联的[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)对象的指针。|
|[CPane：： GetVirtualRect](#getvirtualrect)|检索窗格的*虚拟矩形*。|
|[CPane：： IsChangeState](#ischangestate)|在移动窗格时，此方法会分析窗格相对于其他窗格、停靠行和袖珍框架窗口的位置，并返回相应的 AFX_CS_STATUS 值。|
|[CPane：： IsDragMode](#isdragmode)|指定是否正在拖动窗格。|
|[CPane：： IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定窗格是否位于多窗格框架窗口中。 （重写 `CBasePane::IsInFloatingMultiPaneFrameWnd`。）|
|[CPane：： IsLeftOf](#isleftof)|确定窗格是否为指定矩形的左侧（或更高）。|
|[CPane：： IsResizable](#isresizable)|确定窗格是否可以调整大小。 （重写[CBasePane：： IsResizable](../../mfc/reference/cbasepane-class.md#isresizable)。）|
|[CPane：： IsTabbed](#istabbed)|确定是否已将窗格插入到选项卡式窗口的选项卡控件中。 （重写[CBasePane：： IsTabbed](../../mfc/reference/cbasepane-class.md#istabbed)。）|
|[CPane：： LoadState](#loadstate)|从注册表加载窗格的状态。 （重写[CBasePane：： LoadState](../../mfc/reference/cbasepane-class.md#loadstate)。）|
|[CPane：： MoveByAlignment](#movebyalignment)|将窗格和虚拟矩形移动指定的量。|
|[CPane：： MovePane](#movepane)|将窗格移动到指定矩形。|
|[CPane：： OnAfterChangeParent](#onafterchangeparent)|当窗格的父项已更改时由框架调用。|
|[CPane：： OnBeforeChangeParent](#onbeforechangeparent)|当窗格的父级将要更改时由框架调用。|
|[CPane：： OnPressCloseButton](#onpressclosebutton)|当用户选择窗格标题上的 "关闭" 按钮时，由框架调用。|
|`CPane::OnProcessDblClk`|内部使用。|
|[CPane：： OnShowControlBarMenu](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|[CPane：： OnShowControlBarMenu](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|`CPane::PrepareToDock`|内部使用。|
|[CPane：： RecalcLayout](#recalclayout)|重新计算窗格的布局信息。 （重写[CBasePane：： RecalcLayout](../../mfc/reference/cbasepane-class.md#recalclayout)。）|
|[CPane：： SaveState](#savestate)|将窗格状态保存到注册表。 （重写[CBasePane：： SaveState](../../mfc/reference/cbasepane-class.md#savestate)。）|
|[CPane：： SetActiveInGroup](#setactiveingroup)|将窗格标记为活动窗格。|
|[CPane：： SetBorders](#setborders)|设置窗格的边框值。|
|[CPane：： SetClientHotSpot](#setclienthotspot)|设置窗格的作用点。|
|[CPane：： SetDockState](#setdockstate)|还原窗格的停靠状态信息。|
|[CPane：： SetExclusiveRowMode](#setexclusiverowmode)|启用或禁用独占行模式。|
|[CPane：： SetMiniFrameRTC](#setminiframertc)|设置默认袖珍框架窗口的运行时类信息。|
|[CPane：： SetMinSize](#setminsize)|设置窗格允许的最小大小。|
|[CPane：： SetVirtualRect](#setvirtualrect)|设置窗格的*虚拟矩形*。|
|[CPane：： StretchPaneDeferWndPos](#stretchpanedeferwndpos)|基于停靠样式，垂直或水平拉伸窗格。|
|[CPane：： ToggleAutoHide](#toggleautohide)|切换自动隐藏模式。|
|[CPane：： UndockPane](#undockpane)|从停靠站点、默认滑块或微型框架窗口中删除当前停靠的窗格。 （重写[CBasePane：： UndockPane](../../mfc/reference/cbasepane-class.md#undockpane)。）|
|[CPane：： UpdateVirtualRect](#updatevirtualrect)|更新虚拟矩形。|

### <a name="protected-methods"></a>受保护的方法

|名称|描述|
|----------|-----------------|
|[CPane：： OnAfterDock](#onafterdock)|停靠窗格时由框架调用。|
|[CPane：： OnAfterFloat](#onafterfloat)|当某个窗格已浮动时由框架调用。|
|[CPane：： OnBeforeDock](#onbeforedock)|当要停靠窗格时由框架调用。|
|[CPane：： OnBeforeFloat](#onbeforefloat)|当窗格即将浮动时由框架调用。|

### <a name="data-members"></a>数据成员

|名称|描述|
|----------|-----------------|
|[CPane：： m_bHandleMinSize](#m_bhandleminsize)|支持对窗格的最小大小的一致性处理。|
|[CPane：： m_recentDockInfo](#m_recentdockinfo)|包含最近的停靠信息。|

## <a name="remarks"></a>备注

通常， `CPane` 不会直接实例化对象。 如果需要具有插接功能的窗格，请从[CDockablePane](../../mfc/reference/cdockablepane-class.md)派生对象。 如果需要 toolbar 功能，请从[CMFCToolBar](../../mfc/reference/cmfctoolbar-class.md)派生对象。

从派生类时 `CPane` ，可以将其停靠在[CDockSite](../../mfc/reference/cdocksite-class.md)中，并且它可以在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)中浮动。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

[CPane](../../mfc/reference/cpane-class.md)

## <a name="requirements"></a>要求

**标头：** afxPane

## <a name="cpaneadjustsizeimmediate"></a><a name="adjustsizeimmediate"></a>CPane：： AdjustSizeImmediate

立即重新计算窗格的布局。

```
virtual void AdjustSizeImmediate(BOOL bRecalcLayout = TRUE);
```

### <a name="parameters"></a>参数

*bRecalcLayout*<br/>
中如果为 TRUE，则自动重新计算窗格的布局;否则为 FALSE。

### <a name="remarks"></a>备注

动态更改窗格的布局时，请调用此方法。 例如，您可能希望在隐藏或显示工具栏按钮时调用此方法。

## <a name="cpaneallocelements"></a><a name="allocelements"></a>CPane：： AllocElements

分配供内部使用的存储。

```
BOOL AllocElements(
    int nElements,
    int cbElement);
```

### <a name="parameters"></a>参数

*nElements*<br/>
中要为其分配存储的元素的数目。

*cbElement*<br/>
中元素的大小（以字节为单位）。

### <a name="return-value"></a>返回值

如果内存分配失败，则为 FALSE;否则为 TRUE。

## <a name="cpaneallowshowonpanemenu"></a><a name="allowshowonpanemenu"></a>CPane：： AllowShowOnPaneMenu

指定窗格是否在应用程序的运行时生成的窗格列表中列出。

```
virtual BOOL AllowShowOnPaneMenu() const;
```

### <a name="return-value"></a>返回值

如果窗格显示在列表中，则为 TRUE;否则为 FALSE。 基实现始终返回 TRUE。

### <a name="remarks"></a>备注

应用程序生成的应用程序包含一个菜单选项，其中列出了它包含的窗格。 此方法确定窗格是否显示在列表中。

## <a name="cpanecalcavailablesize"></a><a name="calcavailablesize"></a>CPane：： CalcAvailableSize

计算指定矩形与当前窗口矩形之间的大小差异。

```
virtual CSize CalcAvailableSize(CRect rectRequired);
```

### <a name="parameters"></a>参数

*rectRequired*<br/>
中所需的矩形。

### <a name="return-value"></a>返回值

*RectRequired*与当前窗口矩形之间的宽度和高度之差。

## <a name="cpanecalcinsiderect"></a><a name="calcinsiderect"></a>CPane：： CalcInsideRect

计算窗格的内矩形，包括边框和控制手柄。

```cpp
void CalcInsideRect(
    CRect& rect,
    BOOL bHorz) const;
```

### <a name="parameters"></a>参数

*rect*<br/>
弄包含窗格的工作区的大小和偏移量。

*bHorz*<br/>
中如果窗格是水平方向，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

当它必须重新计算窗格的布局时，框架会调用此方法。 用窗格的工作区的大小和偏移量填充*rect*参数。 这包括其边框和控制手柄。

## <a name="cpanecalcrecentdockedrect"></a><a name="calcrecentdockedrect"></a>CPane：： CalcRecentDockedRect

计算最近停靠的矩形。

```cpp
void CalcRecentDockedRect();
```

### <a name="remarks"></a>备注

此方法更新[CPane：： m_recentDockInfo](#m_recentdockinfo)。

## <a name="cpanecalcsize"></a><a name="calcsize"></a>CPane：： CalcSize

计算窗格的大小。

```
virtual CSize CalcSize(BOOL bVertDock);
```

### <a name="parameters"></a>参数

*bVertDock*<br/>
中如果垂直停靠该窗格，则为 TRUE; 否则为 FALSE。

### <a name="return-value"></a>返回值

此方法的默认实现返回大小（0，0）。

### <a name="remarks"></a>备注

派生类应重写此方法。

## <a name="cpanecanbedocked"></a><a name="canbedocked"></a>CPane：： CanBeDocked

确定窗格是否可停靠在指定的基本窗格。

```
virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
中指定要停靠此窗格的窗格。

### <a name="return-value"></a>返回值

如果此窗格可停靠在指定的停靠窗格上，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法通常由框架调用，以确定窗格是否可停靠在指定的停靠窗格中。 若要确定窗格是否可以停靠，方法会计算窗格的当前启用的停靠对齐方式。

可以通过调用[CBasePane：： EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)启用停靠到框架窗口的各个边。

## <a name="cpanecanbetabbeddocument"></a><a name="canbetabbeddocument"></a>CPane：： CanBeTabbedDocument

确定窗格能否转换为选项卡式文档。

```
virtual BOOL CanBeTabbedDocument() const;
```

### <a name="return-value"></a>返回值

如果窗格可以转换为选项卡式文档，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

在派生类中重写此方法，如果想要阻止将窗格转换为选项卡式文档，则返回 FALSE。 选项卡式文档将不会在窗口位置菜单中列出。

## <a name="cpaneconverttotabbeddocument"></a><a name="converttotabbeddocument"></a>CPane：： ConvertToTabbedDocument

将可停靠的窗格转换为选项卡式文档。

```
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```

### <a name="parameters"></a>参数

*bActiveTabOnly*<br/>
中未在中使用 `CPane::ConvertToTabbedDocument` 。

### <a name="remarks"></a>备注

只有可停靠的窗格才能转换为选项卡式文档。 有关信息，请参阅[CDockablePane：： ConvertToTabbedDocument](../../mfc/reference/cdockablepane-class.md#converttotabbeddocument)。

## <a name="cpanecopystate"></a><a name="copystate"></a>CPane：： CopyState

复制窗格的状态。

```
virtual void CopyState(CPane* pOrgBar);
```

### <a name="parameters"></a>参数

*pOrgBar*<br/>
中指向窗格的指针。

### <a name="remarks"></a>备注

此方法将*pOrgBar*的状态复制到当前窗格。

## <a name="cpanecreate"></a><a name="create"></a>CPane：： Create

创建一个控件栏并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*lpszClassName*<br/>
中指定 Windows 类的名称。

*dwStyle*<br/>
中指定窗口样式特性。 有关详细信息，请参阅[窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*rect*<br/>
中指定*pParentWnd*窗口的初始大小和位置（以工作区坐标表示）。

*pParentWnd*<br/>
[in，out]指定此窗格的父窗口。

*nID*<br/>
中指定窗格的 ID。

*dwControlBarStyle*<br/>
中指定窗格的样式。 有关详细信息，请参阅[CBasePane：： CreateEx](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in，out]指定窗格的创建上下文。

### <a name="return-value"></a>返回值

如果成功创建了窗格，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法创建一个 Windows 窗格，并将其附加到 `CPane` 对象。

如果在调用之前未显式初始化[CPane：： m_recentDockInfo](#m_recentdockinfo) `Create` ，则在浮动或停靠此窗格时，将使用参数*rect*作为矩形。

## <a name="cpanecreatedefaultminiframe"></a><a name="createdefaultminiframe"></a>CPane：： CreateDefaultMiniframe

为浮动窗格创建微型框架窗口。

```
virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);
```

### <a name="parameters"></a>参数

*rectInitial*<br/>
中指定要创建的袖珍框架窗口的初始大小和位置（以屏幕坐标表示）。

### <a name="return-value"></a>返回值

新创建的微型框架窗口。

### <a name="remarks"></a>备注

此方法由框架调用，以在一个窗格浮动时创建一个微型框架窗口。 袖珍框架窗口可以是[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)类型，也可以是[CMultiPaneFrameWnd](../../mfc/reference/cmultipaneframewnd-class.md)类型。 如果窗格具有 AFX_CBRS_FLOAT_MULTI 样式，则会创建多个微型框架窗口。

袖珍框架窗口的运行时类信息存储在 `CPane::m_pMiniFrameRTC` 成员中。 如果你决定创建自定义的小型框架窗口，则可以使用派生类来设置此成员。

## <a name="cpanecreateex"></a><a name="createex"></a>CPane：： CreateEx

创建一个控件栏并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*dwStyleEx*<br/>
中指定扩展的窗口样式特性。 有关详细信息，请参阅[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

*lpszClassName*<br/>
中指定 Windows 类的名称。

*dwStyle*<br/>
中指定窗口样式特性。 有关详细信息，请参阅[窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*rect*<br/>
中指定*pParentWnd*窗口的初始大小和位置（以工作区坐标表示）。

*pParentWnd*<br/>
[in，out]指定此窗格的父窗口。

*nID*<br/>
中指定窗格的 ID。

*dwControlBarStyle*<br/>
中指定窗格的样式。 有关详细信息，请参阅[CBasePane：： CreateEx](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in，out]指定窗格的 "创建上下文"。

### <a name="return-value"></a>返回值

如果成功创建了窗格，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法创建一个 Windows 窗格，并将其附加到 `CPane` 对象。

如果在调用之前未显式初始化[CPane：： m_recentDockInfo](#m_recentdockinfo) `CreateEx` ，则在浮动或停靠此窗格时，将使用参数*rect*作为矩形。

## <a name="cpanedockbymouse"></a><a name="dockbymouse"></a>CPane：:D ockByMouse

使用鼠标停靠窗格。

```
virtual BOOL DockByMouse(CBasePane* pDockBar);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
中指定此窗格要停靠到的基本窗格。

### <a name="return-value"></a>返回值

如果窗格已成功停靠，则为 TRUE;否则为 FALSE。

## <a name="cpanedockpane"></a><a name="dockpane"></a>CPane：:D ockPane

将浮动窗格停靠到基本窗格。

```
virtual BOOL DockPane(
    CBasePane* pDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[in，out]指定要将此窗格停靠到的基本窗格。

*lpRect*<br/>
中指定基窗格上要停靠此窗格的矩形。

*dockMethod*<br/>
中指定要使用的停靠方法。 可用选项如下所示：

|选项|描述|
|------------|-----------------|
|DM_UNKNOWN|当停靠方法未知时，框架会使用此选项。 窗格不存储其最新的浮动位置。 你还可以使用此选项在无需存储最近的浮动位置时以编程方式停靠窗格。|
|DM_MOUSE|内部使用。|
|DM_DBL_CLICK|双击手柄时，将使用此选项。 窗格重新定位在其最近的停靠位置。 如果通过双击取消停靠该窗格，则该窗格将被重新定位到最新的浮动位置。|
|DM_SHOW|此选项可用于以编程方式停靠窗格。 窗格存储其最新的浮动位置。|
|DM_RECT|窗格停靠在由*lpRect*指定的区域。|
|DM_STANDARD|使用此选项时，框架会在移动时将窗格绘制为大纲框架。|

### <a name="return-value"></a>返回值

如果窗格已成功停靠，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法将窗格停靠到由*pDockBar*参数指定的基本窗格。 首先，必须通过调用[CBasePane：： EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)启用插接。

## <a name="cpanedockpanestandard"></a><a name="dockpanestandard"></a>CPane：:D ockPaneStandard

使用轮廓（标准）停靠停靠一个窗格。

```
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```

### <a name="parameters"></a>参数

*bWasDocked*<br/>
中如果成功停靠窗格，则为 TRUE;否则为 FALSE。

### <a name="return-value"></a>返回值

此方法始终返回 **`this`** 指针。

### <a name="remarks"></a>备注

此方法仅用于派生自[CDockablePane 类](../../mfc/reference/cdockablepane-class.md)的窗格。 有关详细信息，请参阅[CDockablePane：:D ockpanestandard](../../mfc/reference/cdockablepane-class.md#dockpanestandard)。

## <a name="cpanedocktoframewindow"></a><a name="docktoframewindow"></a>CPane：:D ockToFrameWindow

将可停靠的窗格停靠到帧。

```
virtual BOOL DockToFrameWindow(
    DWORD dwAlignment,
    LPCRECT lpRect = NULL,
    DWORD dwDockFlags = DT_DOCK_LAST,
    CBasePane* pRelativeBar = NULL,
    int nRelativeIndex = -1,
    BOOL bOuterEdge = FALSE);
```

### <a name="parameters"></a>参数

*dwAlignment*<br/>
中要将窗格停靠到的父框架侧。

*lpRect*<br/>
中指定的大小。

*dwDockFlags*<br/>
中掉.

*pRelativeBar*<br/>
中掉.

*nRelativeIndex*<br/>
中掉.

*bOuterEdge*<br/>
中如果为 TRUE，并且在*dwAlignment*指定的位置有其他可停靠的窗格，则该窗格将停靠在其他窗格外，靠近父框架的边缘。 如果为 FALSE，则窗格停靠在离工作区中心更近的地方。

### <a name="return-value"></a>返回值

如果无法创建窗格分隔符（ [CPaneDivider 类](../../mfc/reference/cpanedivider-class.md)），则为 FALSE; 否则为 FALSE。否则为 TRUE。

### <a name="remarks"></a>备注

## <a name="cpanedoesallowsiblingbars"></a><a name="doesallowsiblingbars"></a>CPane：:D oesAllowSiblingBars

指示是否可以在当前窗格停靠的同一行上停靠另一个窗格。

```
virtual BOOL DoesAllowSiblingBars() const;
```

### <a name="return-value"></a>返回值

如果此窗格可以停靠到其自身所在行的另一个窗格，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

可以通过调用[CPane：： SetExclusiveRowMode](#setexclusiverowmode)启用或禁用此行为。

默认情况下，工具栏禁用了独占行模式，菜单栏启用了独占行模式。

## <a name="cpanefloatpane"></a><a name="floatpane"></a>CPane：： FloatPane

在窗格中浮动。

```
virtual BOOL FloatPane(
    CRect rectFloat,
    AFX_DOCK_METHOD dockMethod = DM_UNKNOWN,
    bool bShow = true);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
中指定屏幕坐标中的位置，以便在窗格浮动时对其进行定位。

*dockMethod*<br/>
中指定要在窗格浮动时使用的停靠方法。 有关可能值的列表，请参阅[CPane：:D ockpane](#dockpane)。

*bShow*<br/>
中若要在浮动时显示窗格，则为 TRUE;否则为 FALSE。

### <a name="return-value"></a>返回值

如果窗格成功浮动或因为[CBasePane：： CanFloat](../../mfc/reference/cbasepane-class.md#canfloat)返回 FALSE，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法可将窗格置于由*rectFloat*参数指定的位置。 此方法自动创建窗格的父微型框架窗口。

## <a name="cpanegetavailableexpandsize"></a><a name="getavailableexpandsize"></a>CPane：： GetAvailableExpandSize

返回窗格可以扩展的量（以像素为单位）。

```
virtual int GetAvailableExpandSize() const;
```

### <a name="return-value"></a>返回值

如果窗格是水平停靠的，则返回值为可用宽度;否则，返回值为可用高度。

### <a name="remarks"></a>备注

## <a name="cpanegetavailablestretchsize"></a><a name="getavailablestretchsize"></a>CPane：： GetAvailableStretchSize

返回窗格可以收缩的量（以像素为单位）。

```
virtual int GetAvailableStretchSize() const;
```

### <a name="return-value"></a>返回值

窗格可以收缩的量（以像素为单位）。 如果窗格是水平停靠的，则此量为可用宽度;否则为可用高度。

### <a name="remarks"></a>备注

可用拉伸大小是通过从当前大小减去最小允许大小（ [CPane：： GetMinSize](#getminsize)）来计算的（ [CWnd：： GetWindowRect](../../mfc/reference/cwnd-class.md#getwindowrect)）。

## <a name="cpanegetborders"></a><a name="getborders"></a>CPane：： GetBorders

返回窗格边框的宽度。

```
CRect GetBorders() const;
```

### <a name="return-value"></a>返回值

一个[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象包含窗格每一侧的当前宽度（以像素为单位）。 例如，对象的成员的值 `left` `CRect` 是左边框的宽度。

### <a name="remarks"></a>备注

若要设置边框的大小，请调用[CPane：： SetBorders](#setborders)。

## <a name="cpanegetclienthotspot"></a><a name="getclienthotspot"></a>CPane：： GetClientHotSpot

返回窗格的*热点*。

```
CPoint GetClientHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*热点*是用户选择并保存的窗格上的点，用于移动窗格。 当窗格从停靠位置移动时，作用点用于平滑动画。

## <a name="cpanegetdocksiterow"></a><a name="getdocksiterow"></a>CPane：： GetDockSiteRow

返回停靠了窗格的停靠行（ [CDockingPanesRow 类](../../mfc/reference/cdockingpanesrow-class.md)）。

```
CDockingPanesRow* GetDockSiteRow() const;
```

### <a name="return-value"></a>返回值

一个 `CDockingPanesRow` 指向停靠窗格的停靠行的 *，如果窗格未停靠，则为 NULL。

## <a name="cpanegetexclusiverowmode"></a><a name="getexclusiverowmode"></a>CPane：： GetExclusiveRowMode

确定窗格是否处于独占行模式。

```
virtual BOOL GetExclusiveRowMode() const;
```

### <a name="return-value"></a>返回值

如果窗格处于独占行模式，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

有关独占行模式的详细信息，请参阅[CPane：： SetExclusiveRowMode](#setexclusiverowmode)。

## <a name="cpanegethotspot"></a><a name="gethotspot"></a>CPane：： GetHotSpot

返回存储在基础对象中的作用点 `CMFCDragFrameImpl` 。

```
CPoint GetHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

`CPane`类包含一个 `CMFCDragFrameImpl` 对象，该对象 `m_dragFrameImpl` 负责绘制当用户在标准停靠模式下移动窗格时显示的矩形。 当用户移动窗格时，作用点用于相对于当前鼠标位置绘制矩形。

## <a name="cpanegetminsize"></a><a name="getminsize"></a>CPane：： GetMinSize

检索窗格允许的最小大小。

```
virtual void GetMinSize(CSize& size) const;
```

### <a name="parameters"></a>参数

*大小*<br/>
弄`CSize`使用最小允许大小填充的对象。

### <a name="remarks"></a>备注

## <a name="cpanegetpanename"></a><a name="getpanename"></a>CPane：： GetPaneName

检索窗格的标题。

```
virtual void GetPaneName(CString& strName) const;
```

### <a name="parameters"></a>参数

*strName*<br/>
弄`CString`用标题名称填充的对象。

### <a name="remarks"></a>备注

当窗格停靠或浮动时，窗格标题将显示在标题区域中。 如果窗格是选项卡式组的一部分，则标题将显示在选项卡区域中。 如果该窗格处于自动隐藏模式，则标题显示在上 `CMFCAutoHideButton` 。

## <a name="cpanegetvirtualrect"></a><a name="getvirtualrect"></a>CPane：： GetVirtualRect

检索窗格的*虚拟矩形*。

```cpp
void GetVirtualRect(CRect& rectVirtual) const;
```

### <a name="parameters"></a>参数

*rectVirtual*<br/>
弄`CRect`用虚矩形填充的对象。

### <a name="remarks"></a>备注

移动窗格时，框架会将窗格的原始位置存储在虚拟矩形中。 框架可以使用虚拟矩形来还原窗格的原始位置。

除非以编程方式移动窗格，否则不要调用与虚拟矩形相关的方法。

## <a name="cpaneischangestate"></a><a name="ischangestate"></a>CPane：： IsChangeState

在移动窗格时，此方法会分析其相对于其他窗格、停靠行和袖珍框架窗口的位置，并返回相应的 AFX_CS_STATUS 值。

```
virtual AFX_CS_STATUS IsChangeState(
    int nOffset,
    CBasePane** ppTargetBar) const;
```

### <a name="parameters"></a>参数

*nOffset*<br/>
中指定停靠敏感度。 例如，在停靠行的*nOffset*像素内移动的窗格将被停靠。

*ppTargetBar*<br/>
中当该方法返回时， *ppTargetBar*包含指向当前窗格应停靠到的对象的指针; 如果不应进行停靠，则为 NULL。

### <a name="return-value"></a>返回值

以下 AFX_CS_STATUS 值之一：

|值|描述|
|-----------|-----------------|
|CS_NOTHING|此窗格不在停靠站点附近。 框架不停靠窗格。|
|CS_DOCK_IMMEDIATELY|此窗格位于停靠站点上，并且 DT_IMMEDIATE 样式已启用。 框架会立即停靠窗格。|
|CS_DELAY_DOCK|此窗格位于停靠站点上，后者可以是另一个停靠窗格或主框架的边缘。 当用户释放移动时，框架停靠窗格。|
|CS_DELAY_DOCK_TO_TAB|此窗格位于停靠站点上，使窗格停靠在选项卡式窗口中。 当窗格位于另一个停靠窗格的标题上或选项卡式窗格的选项卡区域上方时，会发生这种情况。 当用户释放移动时，框架停靠窗格。|

## <a name="cpaneisdragmode"></a><a name="isdragmode"></a>CPane：： IsDragMode

指定是否正在移动窗格。

```
virtual BOOL IsDragMode() const;
```

### <a name="return-value"></a>返回值

如果正在移动窗格，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

## <a name="cpaneisinfloatingmultipaneframewnd"></a><a name="isinfloatingmultipaneframewnd"></a>CPane：： IsInFloatingMultiPaneFrameWnd

指定窗格是否位于多窗格框架窗口（ [CMultiPaneFrameWnd 类](../../mfc/reference/cmultipaneframewnd-class.md)）中。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>返回值

如果窗格位于多窗格框架窗口中，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

只有可停靠的窗格可以在多窗格框架窗口中浮动。 因此， `CPane::IsInFloatingMultiPaneFrameWnd` 始终返回 FALSE。

## <a name="cpaneisleftof"></a><a name="isleftof"></a>CPane：： IsLeftOf

确定窗格是否为指定矩形的左侧（或更高）。

```
bool IsLeftOf(
    CRect rect,
    bool bWindowRect = true) const;
```

### <a name="parameters"></a>参数

*rect*<br/>
中`CRect`用于比较的对象。

*bWindowRect*<br/>
中如果为 TRUE，则假定*矩形*包含屏幕坐标;如果为 FALSE，则假定*矩形*包含客户端坐标。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

如果窗格是水平停靠的，则此方法检查其位置是否为*rect*的左侧。 否则，此方法将检查位置是否在*rect*上方。

## <a name="cpaneisresizable"></a><a name="isresizable"></a>CPane：： IsResizable

指定窗格是否可调整大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>返回值

如果窗格可调整大小，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

基 `CPane` 对象的大小不可调整。

停靠管理器使用可调整大小的标志来确定窗格布局。 不可调整大小的窗格始终位于父框架的外边缘。

不可调整大小的窗格不能驻留在停靠容器内。

## <a name="cpaneistabbed"></a><a name="istabbed"></a>CPane：： IsTabbed

确定是否已将窗格插入到选项卡式窗口的选项卡控件中。

```
virtual BOOL IsTabbed() const;
```

### <a name="return-value"></a>返回值

如果窗格是选项卡，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

选项卡式状态与浮动、停靠和自动隐藏状态分开处理。

## <a name="cpaneloadstate"></a><a name="loadstate"></a>CPane：： LoadState

从注册表加载窗格的状态。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpszProfileName*<br/>
中配置文件名称。

*nIndex*<br/>
中配置文件索引。

*uiID*<br/>
中窗格 ID。

### <a name="return-value"></a>返回值

如果成功加载了窗格状态，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

框架调用此方法从注册表加载窗格状态。 在派生类中重写它以加载[CPane：： SaveState](#savestate)保存的附加信息。

重写此方法时，还应调用基方法，如果基方法返回 FALSE，则返回 FALSE。

## <a name="cpanem_bhandleminsize"></a><a name="m_bhandleminsize"></a>CPane：： m_bHandleMinSize

启用最小窗格大小的一致性处理。

```
AFX_IMPORT_DATA static BOOL m_bHandleMinSize;
```

### <a name="remarks"></a>备注

如果你的应用程序中的一个或多个停靠窗格已重写 `GetMinSize` ，或如果你的应用程序调用 `SetMinSize` ，则你可能希望将此静态成员设置为 TRUE，以便使框架能够一致地处理窗格的大小。

如果将此值设置为 TRUE，则将剪裁大小低于最小大小的所有窗格，而不是拉伸。 由于框架使用窗口区域调整大小，因此，如果此值设置为 TRUE，请不要更改停靠窗格的窗口区域大小。

## <a name="cpanem_recentdockinfo"></a><a name="m_recentdockinfo"></a>CPane：： m_recentDockInfo

包含最近的停靠信息。

```
CRecentDockSiteInfo m_recentDockInfo;
```

### <a name="remarks"></a>备注

框架在此成员中存储窗格的最新停靠状态信息。

## <a name="cpanemovebyalignment"></a><a name="movebyalignment"></a>CPane：： MoveByAlignment

将窗格和虚拟矩形移动指定的量。

```
BOOL MoveByAlignment(
    DWORD dwAlignment,
    int nOffset);
```

### <a name="parameters"></a>参数

*dwAlignment*<br/>
中指定窗格对齐方式。

*nOffset*<br/>
中用于移动窗格和虚拟矩形的量（以像素为单位）。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*dwAlignment*可以是下列值之一：

|值|描述|
|-----------|-----------------|
|CBRS_ALIGN_TOP|使窗格停靠在框架窗口的工作区的顶部。|
|CBRS_ALIGN_BOTTOM|使窗格停靠在框架窗口的工作区的底部。|
|CBRS_ALIGN_LEFT|使窗格停靠在框架窗口的工作区的左侧。|
|CBRS_ALIGN_RIGHT|使窗格停靠在框架窗口的工作区的右侧。|
|CBRS_ALIGN_ANY|允许将窗格停靠到框架窗口的工作区的任何一侧。|

如果*dwAlignment*包含 CBRS_ALIGN_LEFT 或 CBRS_ALIGN_RIGHT 标志，则将水平移动窗格和虚拟矩形;否则，如果*dwAlignment*包含 CBRS_ALIGN_TOP 或 CBRS_ALIGN_BOTTOM 标志，则会垂直移动窗格和虚拟矩形。

## <a name="cpanemovepane"></a><a name="movepane"></a>CPane：： MovePane

将窗格移动到指定矩形。

```
virtual CSize MovePane(
    CRect rectNew,
    BOOL bForceMove,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*rectNew*<br/>
中为窗格指定新矩形。

*bForceMove*<br/>
中如果为 TRUE，则此方法将忽略允许的最小窗格大小（ [CPane：： GetMinSize](#getminsize)）;否则，窗格会根据需要进行调整，以确保它至少达到允许的最小大小。

*hdwp*<br/>
中不使用。

### <a name="return-value"></a>返回值

一个 `CSize` 对象，该对象包含新矩形和旧矩形（旧矩形- *rectNew*）之间的宽度和高度差异。

### <a name="remarks"></a>备注

此方法仅用于可停靠的窗格。

## <a name="cpaneonafterchangeparent"></a><a name="onafterchangeparent"></a>CPane：： OnAfterChangeParent

当窗格的父项已更改时由框架调用。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>参数

*pWndOldParent*<br/>
[in，out]窗格的上一个父窗口。

### <a name="remarks"></a>备注

当面板的父项由于停靠或浮动操作而发生更改时，框架会调用此方法。

## <a name="cpaneonafterdock"></a><a name="onafterdock"></a>CPane：： OnAfterDock

停靠窗格时由框架调用。

```
virtual void OnAfterDock(
    CBasePane* pBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pBar*<br/>
中未使用此参数。

*lpRect*<br/>
中未使用此参数。

*dockMethod*<br/>
中未使用此参数。

## <a name="cpaneonafterfloat"></a><a name="onafterfloat"></a>CPane：： OnAfterFloat

在窗格浮动后由框架调用。

```
virtual void OnAfterFloat();
```

### <a name="remarks"></a>备注

如果要在一个窗格浮动后执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonbeforechangeparent"></a><a name="onbeforechangeparent"></a>CPane：： OnBeforeChangeParent

当窗格的父级将要更改时由框架调用。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*pWndNewParent*<br/>
[in，out]指定新的父窗口。

*bDelay*<br/>
中如果延迟全局停靠布局调整，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法在窗格的父项要更改时由框架调用，因为该窗格正在停靠或浮动。

默认情况下，通过调用，使用停靠窗格取消注册窗格 `CDockSite::RemovePane` 。

## <a name="cpaneonbeforedock"></a><a name="onbeforedock"></a>CPane：： OnBeforeDock

当窗格即将停靠时由框架调用。

```
virtual BOOL OnBeforeDock(
    CBasePane** ppDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*ppDockBar*<br/>
[in，out]指定此窗格停靠到的窗格。

*lpRect*<br/>
中指定停靠矩形。

*dockMethod*<br/>
中指定停靠方法。

### <a name="return-value"></a>返回值

如果窗格可以停靠，则为 TRUE。 如果此函数返回 FALSE，将中止停靠操作。

### <a name="remarks"></a>备注

当窗格要停靠时，框架会调用此方法。 如果要在窗格最终停靠之前执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonbeforefloat"></a><a name="onbeforefloat"></a>CPane：： OnBeforeFloat

当窗格要浮动时由框架调用。

```
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
中指定窗格处于浮动状态时的位置和大小。

*dockMethod*<br/>
中指定窗格的停靠方法。

### <a name="return-value"></a>返回值

如果可以浮动窗格，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

当窗格将要浮动时，框架会调用此方法。 如果要在该窗格最终浮动之前执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonpressclosebutton"></a><a name="onpressclosebutton"></a>CPane：： OnPressCloseButton

当用户按下窗格标题上的 "关闭" 按钮时，由框架调用。

```
virtual void OnPressCloseButton();
```

### <a name="remarks"></a>备注

当用户按下窗格标题上的 "**关闭**" 按钮时，框架会调用此方法。 若要接收有关**Close**事件的通知，可以在派生类中重写此方法。

## <a name="cpaneonshowcontrolbarmenu"></a><a name="onshowcontrolbarmenu"></a>CPane：： OnShowControlBarMenu

当即将显示特殊窗格菜单时由框架调用。

```
virtual BOOL OnShowControlBarMenu(CPoint point);
```

### <a name="parameters"></a>参数

*情况*<br/>
中指定菜单位置。

### <a name="return-value"></a>返回值

如果可显示菜单，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

菜单包含多个项，使你可以指定窗格的行为，即：**浮动**、**停靠** **、自动隐藏和****隐藏**。 可以通过调用[CDockingManager：： EnableDockSiteMenu](../../mfc/reference/cdockingmanager-class.md#enabledocksitemenu)为所有窗格启用此菜单。

## <a name="cpanerecalclayout"></a><a name="recalclayout"></a>CPane：： RecalcLayout

重新计算窗格的布局信息。

```
virtual void RecalcLayout();
```

### <a name="remarks"></a>备注

如果停靠了窗格，此方法会通过将窗格的大小设置为当前窗格的大小来更新窗格的虚拟矩形。

如果该窗格是浮动窗格，则此方法会通知父袖珍框架，以将窗格大小调整到微型框架的大小。 此框架确保最小框架至少为窗格的最小允许大小（ [CPane：： GetMinSize](#getminsize)），并根据需要调整微型框架的大小。

## <a name="cpanesavestate"></a><a name="savestate"></a>CPane：： SaveState

将窗格状态保存到注册表。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpszProfileName*<br/>
中配置文件名称。

*nIndex*<br/>
中配置文件索引。

*uiID*<br/>
中窗格 ID。

### <a name="return-value"></a>返回值

如果成功保存状态，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

框架在将窗格状态保存到注册表时调用此方法。 `SaveState`在派生类中重写以存储附加信息。

重写此方法时，还应调用基方法，如果基方法返回 FALSE，则返回 FALSE。

## <a name="cpanesetactiveingroup"></a><a name="setactiveingroup"></a>CPane：： SetActiveInGroup

将窗格标记为活动窗格。

```
virtual void SetActiveInGroup(BOOL bActive);
```

### <a name="parameters"></a>参数

*bActive*<br/>
中指定是否将窗格标记为活动的布尔值。

### <a name="remarks"></a>备注

当显示可停靠的窗格或选择 "自动隐藏" 按钮时，相应的自动隐藏窗格将标记为 "活动"。

与窗格关联的自动隐藏按钮的外观基于两个因素。 如果窗格处于活动状态且 `static BOOL CMFCAutoHideButton::m_bOverlappingTabs` 为 TRUE，则框架会将 "自动隐藏" 按钮显示为图标和标签。 对于非活动窗格，框架只显示 "自动隐藏" 图标。

如果 `CMFCAutoHideButton::m_bOverlappingTabs` 为 FALSE，或者如果窗格不位于某个组中，则该框架会将关联的自动隐藏按钮显示为图标和标签。

## <a name="cpanesetborders"></a><a name="setborders"></a>CPane：： SetBorders

设置窗格的边框值。

```cpp
void SetBorders(
    int cxLeft = 0,
    int cyTop = 0,
    int cxRight = 0,
    int cyBottom = 0);

void SetBorders(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*cxLeft*<br/>
中指定窗格左边框的宽度（以像素为单位）。

*cyTop*<br/>
中指定窗格上边框的宽度（以像素为单位）。

*cxRight*<br/>
中指定窗格右边框的宽度（以像素为单位）。

*cyBottom*<br/>
中指定窗格下边框的宽度（以像素为单位）。

*lpRect*<br/>
中一个包含窗格的每个边框宽度（以像素为单位）的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="remarks"></a>备注

调用此函数可设置窗格边框的大小。

## <a name="cpanesetclienthotspot"></a><a name="setclienthotspot"></a>CPane：： SetClientHotSpot

设置窗格的*作用点*。

```cpp
void SetClientHotSpot(const CPoint& ptNew);
```

### <a name="parameters"></a>参数

*ptNew*<br/>
中一个 `CPoint` 对象，该对象指定新的作用点。

### <a name="remarks"></a>备注

*热点*是用户选择并保存的窗格上的点，用于移动窗格。 当窗格从停靠位置拖动时，作用点用于平滑动画。

## <a name="cpanesetdockstate"></a><a name="setdockstate"></a>CPane：： SetDockState

还原窗格的停靠状态信息。

```
virtual void SetDockState(CDockingManager* pDockManager);
```

### <a name="parameters"></a>参数

*pDockManager*<br/>
中指向主框架窗口的停靠管理器的指针。

### <a name="remarks"></a>备注

框架调用此方法来还原窗格的最近停靠状态信息。 窗格将最近的停靠状态信息存储在[CPane：： m_recentDockInfo](#m_recentdockinfo)中。 有关详细信息，请参阅[CRecentDockSiteInfo 类](../../mfc/reference/crecentdocksiteinfo-class.md)。

你还可以调用此方法来设置从外部源加载窗格信息时的停靠状态。

## <a name="cpanesetexclusiverowmode"></a><a name="setexclusiverowmode"></a>CPane：： SetExclusiveRowMode

启用或禁用独占行模式。

```
virtual void SetExclusiveRowMode(BOOL bExclusive = TRUE);
```

### <a name="parameters"></a>参数

*bExclusive*<br/>
中若要启用独占行模式，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法以启用或禁用独占行模式。 当窗格处于独占行模式时，它不能与任何其他工具栏共享同一行。

默认情况下，所有工具栏都禁用了独占行模式，并且菜单栏启用了独占行模式。

## <a name="cpanesetminsize"></a><a name="setminsize"></a>CPane：： SetMinSize

设置窗格允许的最小大小。

```cpp
void SetMinSize(const CSize& size);
```

### <a name="parameters"></a>参数

*大小*<br/>
中一个 `CSize` 对象，该对象包含窗格允许的最小大小。

### <a name="remarks"></a>备注

## <a name="cpanesetvirtualrect"></a><a name="setvirtualrect"></a>CPane：： SetVirtualRect

设置窗格的*虚拟矩形*。

```cpp
void SetVirtualRect(
    const CRect& rect,
    BOOL bMapToParent = TRUE);
```

### <a name="parameters"></a>参数

*rect*<br/>
中一个 `CRect` 对象，该对象指定要设置的虚拟矩形。

*bMapToParent*<br/>
中如果*rect*包含相对于父窗口的点，则指定 TRUE。

### <a name="remarks"></a>备注

移动一个*虚拟矩形*时，它存储窗格的原始位置。 框架可以使用虚拟矩形来还原原始位置。

除非以编程方式移动窗格，否则不要调用与虚拟矩形相关的方法。

## <a name="cpanesetminiframertc"></a><a name="setminiframertc"></a>CPane：： SetMiniFrameRTC

设置默认袖珍框架窗口的运行时类信息。

```cpp
void SetMiniFrameRTC(CRuntimeClass* pClass);
```

### <a name="parameters"></a>参数

*pClass*<br/>
[in，out]指定袖珍框架窗口的运行时类信息。

### <a name="remarks"></a>备注

如果某个窗格处于浮动窗格，则将其放在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md) （袖珍框架）窗口上。 在 `CPaneFrameWnd` 调用[CPane：： CreateDefaultMiniframe](#createdefaultminiframe)时，可以提供将使用的自定义派生类。

## <a name="cpanestretchpanedeferwndpos"></a><a name="stretchpanedeferwndpos"></a>CPane：： StretchPaneDeferWndPos

基于停靠样式，垂直或水平拉伸窗格。

```
virtual int StretchPaneDeferWndPos(
    int nStretchSize,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*nStretchSize*<br/>
中用于延伸窗格的量（以像素为单位）。 使用负值来收缩窗格。

*hdwp*<br/>
中不使用。

### <a name="return-value"></a>返回值

窗格拉伸的实际量（以像素为单位）。

### <a name="remarks"></a>备注

如有必要，此方法修改*nStretchSize*以确保窗格不超过大小限制。 这些限制是通过调用[CPane：： GetAvailableStretchSize](#getavailablestretchsize)和[CPane：： GetAvailableExpandSize](#getavailableexpandsize)获取的。

## <a name="cpanetoggleautohide"></a><a name="toggleautohide"></a>CPane：： ToggleAutoHide

切换自动隐藏模式。

```
virtual void ToggleAutoHide();
```

### <a name="remarks"></a>备注

调用此方法以切换自动隐藏模式。 若要切换到自动隐藏模式，窗格必须停靠在主框架窗口中。

## <a name="cpaneundockpane"></a><a name="undockpane"></a>CPane：： UndockPane

从停靠站点、默认滑块或微型框架窗口中删除当前停靠的窗格。

```
virtual void UndockPane(BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*bDelay*<br/>
中如果为 FALSE，则框架将调用[CBasePane：： AdjustDockingLayout](../../mfc/reference/cbasepane-class.md#adjustdockinglayout)来调整停靠布局。

### <a name="remarks"></a>备注

使用此方法以编程方式移除窗格。

## <a name="cpaneupdatevirtualrect"></a><a name="updatevirtualrect"></a>CPane：： UpdateVirtualRect

更新虚拟矩形。

```cpp
void UpdateVirtualRect();
void UpdateVirtualRect(CPoint ptOffset);
void UpdateVirtualRect(CSize sizeNew);
```

### <a name="parameters"></a>参数

*ptOffset*<br/>
中一个 `CPoint` 对象，该对象指定切换窗格的偏移量。

*sizeNew*<br/>
中一个 `CSize` 对象，该对象指定窗格的新大小。

### <a name="remarks"></a>备注

第一个重载使用窗格的当前位置和大小设置虚拟矩形。

第二个重载按*ptOffset*指定的量移动虚拟矩形。

第三个重载使用窗格的当前位置和*sizeNew*指定的大小来设置虚拟矩形。

## <a name="see-also"></a>另请参阅

[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CBasePane 类](../../mfc/reference/cbasepane-class.md)
