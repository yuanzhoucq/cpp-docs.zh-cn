---
title: CDC 类
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 0c8944846e249e4f752183b057bf8d2857022ab5
ms.sourcegitcommit: 975098222db3e8b297607cecaa1f504570a11799
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/10/2018
ms.locfileid: "53179053"
---
# <a name="cdc-class"></a>CDC 类

定义设备上下文对象的类。

## <a name="syntax"></a>语法

```
class CDC : public CObject
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|[CDC::CDC](#cdc)|构造 `CDC` 对象。|

### <a name="public-methods"></a>公共方法

|名称|描述|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|终止当前的打印作业，并擦除所有内容自上次调用的应用程序已写入到设备`StartDoc`成员函数。|
|[CDC::AbortPath](#abortpath)|关闭并放弃在设备上下文中的任何路径。|
|[CDC::AddMetaFileComment](#addmetafilecomment)|将注释从缓冲区复制到指定的增强格式图元文件。|
|[CDC::AlphaBlend](#alphablend)|显示透明或半透明的像素的位图。|
|[CDC::AngleArc](#anglearc)|绘制一条线段和一段弧线，并将当前位置移动到弧线的结束点。|
|[CDC::Arc](#arc)|绘制椭圆弧。|
|[CDC::ArcTo](#arcto)|绘制椭圆弧。此函数是类似于`Arc`，只不过更新当前的位置。|
|[CDC::Attach](#attach)|将 Windows 设备上下文附加到此`CDC`对象。|
|[CDC::BeginPath](#beginpath)|在设备上下文中打开路径括号。|
|[CDC::BitBlt](#bitblt)|从指定的设备上下文中复制位图。|
|[CDC::Chord](#chord)|绘制同时按下 （受限于一个椭圆和一条线段的交集的闭合图形）。|
|[CDC::CloseFigure](#closefigure)|关闭开放图形路径中。|
|[CDC::CreateCompatibleDC](#createcompatibledc)|创建与另一个设备上下文兼容的内存设备上下文。 可用于准备在内存中的映像。|
|[CDC::CreateDC](#createdc)|创建特定设备的设备上下文。|
|[CDC::CreateIC](#createic)|创建特定设备的信息上下文。 这提供了一种以获取有关设备的信息，而无需创建设备上下文的快速方法。|
|[CDC::DeleteDC](#deletedc)|删除与此关联的 Windows 设备上下文`CDC`对象。|
|[CDC::DeleteTempMap](#deletetempmap)|调用`CWinApp`空闲时间处理程序以删除任何临时`CDC`对象创建的`FromHandle`。 此外将分离的设备上下文。|
|[CDC::Detach](#detach)|分离 Windows 设备上下文中的从这`CDC`对象。|
|[CDC::DPtoHIMETRIC](#dptohimetric)|将设备单位转换成 HIMETRIC 为单位。|
|[CDC::DPtoLP](#dptolp)|将设备单位转换为的逻辑单元。|
|[CDC::Draw3dRect](#draw3drect)|绘制三维矩形。|
|[CDC::DrawDragRect](#drawdragrect)|清除并重新绘制一个矩形，如拖动它。|
|[CDC::DrawEdge](#drawedge)|绘制一个矩形的边缘。|
|[CDC::DrawEscape](#drawescape)|绘制无法通过图形设备接口 (GDI) 直接提供视频显示功能的访问。|
|[CDC::DrawFocusRect](#drawfocusrect)|在用来指示焦点的样式绘制一个矩形。|
|[CDC::DrawFrameControl](#drawframecontrol)|绘制一个框架控件。|
|[CDC::DrawIcon](#drawicon)|绘制一个图标。|
|[CDC::DrawState](#drawstate)|显示图像，并将应用视觉效果来指示状态。|
|[CDC::DrawText](#drawtext)|绘制格式化文本中指定的矩形。|
|[CDC::DrawTextEx](#drawtextex)|绘制格式化文本中使用其他格式的指定矩形。|
|[CDC::Ellipse](#ellipse)|绘制椭圆形。|
|[CDC::EndDoc](#enddoc)|结束通过启动打印作业`StartDoc`成员函数。|
|[CDC::EndPage](#endpage)|通知页正在结束的设备驱动程序。|
|[CDC::EndPath](#endpath)|关闭路径括号，并选择在设备上下文由方括号定义的路径。|
|[CDC::EnumObjects](#enumobjects)|枚举钢笔和画笔设备上下文中可用。|
|[CDC::Escape](#escape)|允许应用程序访问未直接提供的特定设备通过 GDI 的设施。 此外允许对 Windows 转义函数的访问。 转义的应用程序调用会转换，然后发送到设备驱动程序。|
|[CDC::ExcludeClipRect](#excludecliprect)|创建新的剪辑区域组成减去指定的矩形的现有剪辑区域。|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|通过从剪辑区域排除在窗口中的已更新的区域，可防止无效窗口区域内的绘制。|
|[CDC::ExtFloodFill](#extfloodfill)|使用当前画笔填充一块区域。 提供了更大的灵活性比[CDC::FloodFill](#floodfill)成员函数。|
|[CDC::ExtTextOut](#exttextout)|将使用当前所选的字体的矩形区域内的字符字符串。|
|[CDC::FillPath](#fillpath)|关闭任何打开图形中的当前路径，并使用当前画笔和多边形填充模式填充的路径的内部。|
|[CDC::FillRect](#fillrect)|通过使用特定画笔填充给定的矩形。|
|[CDC::FillRgn](#fillrgn)|用指定画笔填充特定区域。|
|[CDC::FillSolidRect](#fillsolidrect)|使用纯色填充的矩形。|
|[CDC::FlattenPath](#flattenpath)|转换到当前设备上下文中，选择的路径中的任何曲线并将各段曲线转换成一系列行。|
|[CDC::FloodFill](#floodfill)|使用当前画笔填充一块区域。|
|[CDC::FrameRect](#framerect)|绘制矩形周围的边框。|
|[CDC::FrameRgn](#framergn)|使用画笔的特定区域周围绘制边框。|
|[CDC::FromHandle](#fromhandle)|返回一个指向`CDC`对象时提供给设备上下文的句柄。 如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。|
|[CDC::GetArcDirection](#getarcdirection)|返回设备上下文的当前反方向。|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|检索当前的纵横比筛选器的设置。|
|[CDC::GetBkColor](#getbkcolor)|检索当前的背景色。|
|[CDC::GetBkMode](#getbkmode)|检索后台模式。|
|[CDC::GetBoundsRect](#getboundsrect)|返回指定的设备上下文的当前累计边界矩形。|
|[CDC::GetBrushOrg](#getbrushorg)|检索当前画笔的原点。|
|[CDC::GetCharABCWidths](#getcharabcwidths)|检索的宽度，以逻辑单元的当前字体从给定范围中的连续字符。|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|检索的宽度，以从当前的 TrueType 字体在指定范围中的连续字形索引的逻辑单元。|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|检索各种类型的字符字符串的信息。|
|[CDC::GetCharWidth](#getcharwidth)|从当前字体中检索在给定范围内的连续字符的小数部分的宽度。|
|[CDC::GetCharWidthI](#getcharwidthi)|检索的宽度，以逻辑坐标，从当前的字体在指定范围中的连续标志符号索引。|
|[CDC::GetClipBox](#getclipbox)|检索当前的剪辑边界周围 tightest 边界矩形的尺寸。|
|[CDC::GetColorAdjustment](#getcoloradjustment)|检索设备上下文的颜色调整值。|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|返回一个指向当前所选`CBitmap`对象。|
|[CDC::GetCurrentBrush](#getcurrentbrush)|返回一个指向当前所选`CBrush`对象。|
|[CDC::GetCurrentFont](#getcurrentfont)|返回一个指向当前所选`CFont`对象。|
|[CDC::GetCurrentPalette](#getcurrentpalette)|返回一个指向当前所选`CPalette`对象。|
|[CDC::GetCurrentPen](#getcurrentpen)|返回一个指向当前所选`CPen`对象。|
|[CDC::GetCurrentPosition](#getcurrentposition)|检索笔当前位置 （以逻辑坐标表示）。|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|检索当前画笔的颜色。|
|[CDC::GetDCPenColor](#getdcpencolor)|检索当前的钢笔颜色。|
|[CDC::GetDeviceCaps](#getdevicecaps)|检索指定的类型的给定的显示设备的功能特定于设备的信息。|
|[CDC::GetFontData](#getfontdata)|从可缩放字体文件中检索字体指标信息。 由指定偏移量到字体文件和要返回的信息的长度标识要检索的信息。|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|返回有关指定的显示上下文的当前所选字体的信息。|
|[CDC::GetGlyphOutline](#getglyphoutline)|检索大纲曲线或位图中的当前字体的大纲字符。|
|[CDC::GetGraphicsMode](#getgraphicsmode)|检索指定的设备上下文的当前图形模式。|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|检索一个画笔，半色调。|
|[CDC::GetKerningPairs](#getkerningpairs)|检索字距调整对指定的设备上下文中当前选定字体的字符。|
|[CDC::GetLayout](#getlayout)|检索设备上下文 (DC) 的布局。 布局可以或者左到右 （默认值） 或从右到左 （镜像）。|
|[CDC::GetMapMode](#getmapmode)|检索当前的映射模式。|
|[CDC::GetMiterLimit](#getmiterlimit)|返回设备上下文的斜联接限制。|
|[CDC::GetNearestColor](#getnearestcolor)|检索为指定的逻辑颜色可以表示给定的设备的最近逻辑颜色。|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|检索字体为 TrueType 字体的指标信息。|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|从当前字体使用输出的设备上下文中检索一组连续的字符中的单个字符的宽度。|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|计算的宽度和高度的输出设备上下文的字符串。|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|计算的宽度和高度的线上使用的当前字体以确定维度的输出设备上下文的文本。|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|从输出设备上下文中检索当前字体的度量值。|
|[CDC::GetPath](#getpath)|检索定义的终结点的直线和曲线选入设备上下文在路径中找到的控点的坐标。|
|[CDC::GetPixel](#getpixel)|检索位于指定点的像素的 RGB 颜色值。|
|[CDC::GetPolyFillMode](#getpolyfillmode)|检索当前的多边形填充模式。|
|[CDC::GetROP2](#getrop2)|检索当前的绘制模式。|
|[CDC::GetSafeHdc](#getsafehdc)|返回[CDC::m_hDC](#m_hdc)，输出设备上下文。|
|[CDC::GetStretchBltMode](#getstretchbltmode)|检索当前的位图拉伸模式。|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|计算的宽度和高度属性设备上下文的字符串。|
|[CDC::GetTextAlign](#gettextalign)|检索的文本对齐方式的标志。|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|检索 intercharacter 间距量的当前设置。|
|[CDC::GetTextColor](#gettextcolor)|检索当前的文本颜色。|
|[CDC::GetTextExtent](#gettextextent)|计算的宽度和高度属性设备上下文使用的当前字体以确定维度上的文本行。|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|检索中将不超出指定的空间和为每个这些字符的文本范围内与填充数组的指定字符串的字符数。|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|检索的宽度和高度指定的标志符号索引数组。|
|[CDC::GetTextFace](#gettextface)|作为以 null 结尾的字符串复制到缓冲区的当前字体的字体名称。|
|[CDC::GetTextMetrics](#gettextmetrics)|从属性的设备上下文中检索当前字体的度量值。|
|[CDC::GetViewportExt](#getviewportext)|检索 x-和 y 的盘区的视区。|
|[CDC::GetViewportOrg](#getviewportorg)|检索视区原点 x 和 y 坐标。|
|[CDC::GetWindow](#getwindow)|返回与显示设备上下文关联的窗口。|
|[CDC::GetWindowExt](#getwindowext)|检索 x-和 y 的盘区关联的窗口。|
|[CDC::GetWindowOrg](#getwindoworg)|检索关联的窗口原点 x 和 y 坐标。|
|[CDC::GetWorldTransform](#getworldtransform)|检索当前的世界空间到页面空间转换。|
|[CDC::GradientFill](#gradientfill)|用 gradating 颜色填充矩形和三角形的结构。|
|[CDC::GrayString](#graystring)|绘制灰显 （灰显） 中的给定位置的文本。|
|[CDC::HIMETRICtoDP](#himetrictodp)|将设备单位转换为 HIMETRIC 为单位。|
|[CDC::HIMETRICtoLP](#himetrictolp)|将逻辑单元转换为 HIMETRIC 为单位。|
|[CDC::IntersectClipRect](#intersectcliprect)|通过当前区域和一个矩形的交集创建新的剪辑区域。|
|[CDC::InvertRect](#invertrect)|反转一个矩形的内容。|
|[CDC::InvertRgn](#invertrgn)|反转颜色区域中。|
|[CDC::IsPrinting](#isprinting)|确定是否正在使用的设备上下文进行打印。|
|[CDC::LineTo](#lineto)|从当前位置到，但不是包括，一个点绘制一条线。|
|[CDC::LPtoDP](#lptodp)|将设备单位转换为逻辑单元。|
|[CDC::LPtoHIMETRIC](#lptohimetric)|将 HIMETRIC 单位转换为逻辑单元。|
|[CDC::MaskBlt](#maskblt)|将组合使用给定的掩码和光栅操作的源和目标位图的颜色数据。|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|更改为使用指定的模式的设备上下文的世界转换。|
|[CDC::MoveTo](#moveto)|将当前的位置移动。|
|[CDC::OffsetClipRgn](#offsetcliprgn)|将移动给定设备的剪辑区域。|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|修改视区原点相对于当前视区原点的坐标。|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|修改窗口原点相对于当前窗口原点的坐标。|
|[CDC::PaintRgn](#paintrgn)|用所选定画笔填充区域。|
|[CDC::PatBlt](#patblt)|创建一个位模式。|
|[CDC::Pie](#pie)|绘制扇形楔形。|
|[CDC::PlayMetaFile](#playmetafile)|在给定设备上播放指定图元文件的内容。 增强的版本`PlayMetaFile`显示存储在给定的增强格式图元文件图片。 图元文件可以播放任意次数。|
|[CDC::PlgBlt](#plgblt)|通过在源设备上下文将指定矩形执行颜色数据的位的位块传输到给定的设备上下文中指定的平行四边形。|
|[CDC::PolyBezier](#polybezier)|绘制一个或多个 Bzier 样条。 当前的位置都不使用也不更新。|
|[CDC::PolyBezierTo](#polybezierto)|绘制一个或多个 Bzier 样条，并将当前位置移动到最后一个 Bzier 自由绘制曲线的结束点。|
|[CDC::PolyDraw](#polydraw)|绘制一系列直线段和 Bzier 样条。 此函数会更新当前的位置。|
|[CDC::Polygon](#polygon)|绘制多边形包含两个或多个点 （顶点） 由直线连接。|
|[CDC::Polyline](#polyline)|绘制一系列连接的指定的点的直线线段。|
|[CDC::PolylineTo](#polylineto)|绘制一个或多个直线，并将当前位置移动到最后一行的结束点。|
|[CDC::PolyPolygon](#polypolygon)|创建两个或多个使用当前的多边形填充模式填充的多边形。 多边形可能是不连续或者它们可能重叠。|
|[CDC::PolyPolyline](#polypolyline)|绘制多个相连的线段序列。 当前的位置都不使用也不更新此函数。|
|[CDC::PtVisible](#ptvisible)|指定的剪辑区域内是否为给定的点。|
|[CDC::RealizePalette](#realizepalette)|将当前的逻辑调色板中的调色板条目映射到系统调色板。|
|[CDC::Rectangle](#rectangle)|使用当前笔绘制一个矩形，并使用当前画笔进行填充。|
|[CDC::RectVisible](#rectvisible)|确定给定任何的矩形部分是否位于剪辑区域内。|
|[CDC::ReleaseAttribDC](#releaseattribdc)|版本`m_hAttribDC`，属性的设备上下文。|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|版本`m_hDC`，输出设备上下文。|
|[CDC::ResetDC](#resetdc)|更新`m_hAttribDC`设备上下文。|
|[CDC::RestoreDC](#restoredc)|还原到以前的状态与保存的设备上下文`SaveDC`。|
|[CDC::RoundRect](#roundrect)|带有圆使用当前笔和填充使用当前画笔绘制矩形。|
|[CDC::SaveDC](#savedc)|保存设备上下文的当前状态。|
|[CDC::ScaleViewportExt](#scaleviewportext)|修改相对于当前值的视区范围。|
|[CDC::ScaleWindowExt](#scalewindowext)|修改窗口范围相对于当前值。|
|[CDC::ScrollDC](#scrolldc)|水平和垂直滚动的位的矩形。|
|[CDC::SelectClipPath](#selectclippath)|选择作为设备上下文中，使用指定的模式来组合在新区域中使用任何现有的剪辑区域的剪辑区域的当前路径。|
|[CDC::SelectClipRgn](#selectcliprgn)|通过使用指定的模式来组合在给定的区域中使用的当前剪辑区域。|
|[CDC::SelectObject](#selectobject)|选择一个 GDI 绘图对象，如钢笔。|
|[CDC::SelectPalette](#selectpalette)|选择逻辑调色板。|
|[CDC::SelectStockObject](#selectstockobject)|选择其中一个的预定义的股票钢笔、 画笔或由 Windows 提供的字体。|
|[CDC::SetAbortProc](#setabortproc)|设置 Windows 调用如果必须中止打印作业的程序员提供的回调函数。|
|[CDC::SetArcDirection](#setarcdirection)|设置要用于弧线和矩形函数的绘制方向。|
|[CDC::SetAttribDC](#setattribdc)|集`m_hAttribDC`，属性的设备上下文。|
|[CDC::SetBkColor](#setbkcolor)|设置当前的背景色。|
|[CDC::SetBkMode](#setbkmode)|设置背景模式。|
|[CDC::SetBoundsRect](#setboundsrect)|控制累积的边界矩形指定的设备上下文的信息。|
|[CDC::SetBrushOrg](#setbrushorg)|指定所选入设备上下文的下一步画笔的原点。|
|[CDC::SetColorAdjustment](#setcoloradjustment)|设置使用指定的值的设备上下文的颜色调整值。|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|设置当前画笔的颜色。|
|[CDC::SetDCPenColor](#setdcpencolor)|设置当前的钢笔颜色。|
|[CDC::SetGraphicsMode](#setgraphicsmode)|设置指定的设备上下文的当前图形模式。|
|[CDC::SetLayout](#setlayout)|设备上下文 (DC) 的布局更改。|
|[CDC::SetMapMode](#setmapmode)|设置当前的映射模式。|
|[CDC::SetMapperFlags](#setmapperflags)|更改时它映射到物理字体的逻辑字体的字体映射器使用的算法。|
|[CDC::SetMiterLimit](#setmiterlimit)|设置设备上下文的斜接联接的长度的限制。|
|[CDC::SetOutputDC](#setoutputdc)|集`m_hDC`，输出设备上下文。|
|[CDC::SetPixel](#setpixel)|在指定的点接近指定的颜色设置像素。|
|[CDC::SetPixelV](#setpixelv)|将像素设置为接近的指定颜色的指定坐标处。 `SetPixelV` 快于`SetPixel`因为它不需要返回实际绘制的点的颜色值。|
|[CDC::SetPolyFillMode](#setpolyfillmode)|设置多边形填充模式。|
|[CDC::SetROP2](#setrop2)|设置当前的绘制模式。|
|[CDC::SetStretchBltMode](#setstretchbltmode)|设置位图拉伸模式。|
|[CDC::SetTextAlign](#settextalign)|设置文本对齐方式的标志。|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|设置 intercharacter 间距量。|
|[CDC::SetTextColor](#settextcolor)|设置文本颜色。|
|[CDC::SetTextJustification](#settextjustification)|将空间添加到字符串中的中断字符。|
|[CDC::SetViewportExt](#setviewportext)|设置 x-和 y 的盘区的视区。|
|[CDC::SetViewportOrg](#setviewportorg)|设置视区原点。|
|[CDC::SetWindowExt](#setwindowext)|设置 x-和 y 的盘区关联的窗口。|
|[CDC::SetWindowOrg](#setwindoworg)|设置设备上下文窗口的原点。|
|[CDC::SetWorldTransform](#setworldtransform)|将当前的世界空间设置为页面空间转换。|
|[CDC::StartDoc](#startdoc)|通知的新打印作业正在启动的设备驱动程序。|
|[CDC::StartPage](#startpage)|通知正在启动一个新页面的设备驱动程序。|
|[CDC::StretchBlt](#stretchblt)|将位图从的源矩形和设备移动到目标矩形，拉伸或压缩位图，如有必要以适合目标矩形的尺寸。|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|关闭任何打开的图形路径中、 通过使用当前笔发生路径的轮廓和填充其内部使用的当前画笔。|
|[CDC::StrokePath](#strokepath)|通过使用当前笔呈现指定的路径。|
|[CDC::TabbedTextOut](#tabbedtextout)|写入扩展到指定的制表位位置数组中的值的选项卡的指定位置处字符的字符串。|
|[CDC::TextOut](#textout)|将使用当前所选的字体的指定位置处的字符字符串。|
|[CDC::TransparentBlt](#transparentblt)|将从指定的源设备上下文的颜色数据位块传输到目标设备上下文，呈现指定的颜色在传输中透明。|
|[CDC::UpdateColors](#updatecolors)|在系统调色板在逐像素的基础上的客户端区域中更新的设备上下文的匹配当前工作区的颜色。|
|[CDC::WidenPath](#widenpath)|将当前路径重新定义为将如果路径已描边，使用当前所选入设备上下文的笔绘制的区域。|

### <a name="public-operators"></a>公共运算符

|名称|描述|
|----------|-----------------|
|[CDC::operator HDC](#operator_hdc)|检索设备上下文的句柄。|

### <a name="public-data-members"></a>公共数据成员

|名称|描述|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|使用此属性设备上下文`CDC`对象。|
|[CDC::m_hDC](#m_hdc)|使用此的输出设备上下文`CDC`对象。|

## <a name="remarks"></a>备注

`CDC`对象提供用于处理与窗口的工作区相关联的显示上下文使用设备上下文 （例如显示器或打印机） 和成员的成员函数。

执行的功能的所有成员通过绘制`CDC`对象。 此类提供成员函数对于设备上下文的操作，使用绘图工具，类型安全的图形设备接口 (GDI) 对象选择，然后使用颜色和调色板。 它还提供了用于获取和设置绘制属性映射，并使用视区，使用的窗口范围内，转换坐标、 区域、 剪辑、 绘制线条和绘制简单形状椭圆，使用成员函数和多边形。 此外提供用于绘制文本、 字体的使用、 使用打印机转义符、 滚动和播放的图元文件的成员函数。

若要使用`CDC`对象和构造它，然后调用其成员的并行使用设备上下文的 Windows 函数的函数。

> [!NOTE]
>  在 Windows 95/98，所有的屏幕坐标被限制为 16 位。 因此， **int**传递给`CDC`成员函数必须介于-32768 到 32767 之间的范围。

对于特定用途，Microsoft 基础类库提供了几个类派生自`CDC`。 `CPaintDC` 封装对调用`BeginPaint`和`EndPaint`。 `CClientDC` 管理与窗口的工作区相关联的显示上下文。 `CWindowDC` 管理与整个窗口，包括其帧和控件关联的显示上下文。 `CMetaFileDC` 将设备上下文与图元文件相关联。

`CDC` 提供了两个成员函数， [GetLayout](#getlayout)并[SetLayout](#setlayout)，机制，可以还原设备上下文，不会继承其布局从窗口的布局。 对于区域性，例如阿拉伯语或希伯来语字符布局不是欧洲的标准编写的应用程序必须进行此类从右到左方向。

`CDC` 包含两个设备上下文， [m_hDC](#m_hdc)并[m_hAttribDC](#m_hattribdc)，而后者在创建`CDC`对象，请参阅在同一设备。 `CDC` 所有输出 GDI 将调用都定向到`m_hDC`以及对大多数属性 GDI 调用`m_hAttribDC`。 (属性调用的一个示例是`GetTextColor`，而`SetTextColor`是一个输出调用。)

例如，框架将使用以下两个设备上下文实现`CMetaFileDC`会将输出发送到图元文件从物理设备读取特性时的对象。 打印预览是以类似的方式在 framework 中实现的。 在特定于应用程序代码中，还可以使用两个设备上下文中以类似的方式。

有，您可能的需要从这两个度量值的文本信息`m_hDC`和`m_hAttribDC`设备上下文。 以下对函数提供此功能：

|使用 m_hAttribDC|使用 m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

有关详细信息`CDC`，请参阅[设备上下文](../../mfc/device-contexts.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>要求

**标头:** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

终止当前打印作业，并清除所有内容应用程序已写入到设备上，自上次调用[StartDoc](#startdoc)成员函数。

```
int AbortDoc();
```

### <a name="return-value"></a>返回值

值大于或等于如果成功，则为 0 或负值如果出现错误。 以下列表显示常见的错误值和及其含义：

- SP_ERROR 常规错误。

- SP_OUTOFDISK 不足够的磁盘空间是目前适用于后台处理，并没有更多的空间将变为可用。

- SP_OUTOFMEMORY 不足够的内存是适用于后台处理。

- SP_USERABORT 用户终止通过打印管理器作业。

### <a name="remarks"></a>备注

此成员函数将替换 ABORTDOC 打印机转义。

`AbortDoc` 应该用于终止以下：

- 未指定中止函数使用的打印操作[SetAbortProc](#setabortproc)。

- 尚未达到其第一个 NEWFRAME 或 NEXTBAND 的打印操作对调用进行转义。

如果应用程序会遭遇打印错误或已取消的打印操作，它必须尝试通过使用终止操作[EndDoc](#enddoc)或`AbortDoc`类的成员函数`CDC`。 GDI 自动终止了操作后的，再返回错误值。

如果应用程序将显示一个对话框，允许用户取消打印操作，它必须调用`AbortDoc`之前销毁对话框。

如果使用打印管理器已启动打印作业，则调用`AbortDoc`清除整个后台处理作业 — 打印机接收执行任何操作。 如果不使用打印管理器已启动打印作业，数据可能已发送到打印机之前`AbortDoc`调用。 在这种情况下，打印机驱动程序将具有重置打印机 （如果可能） 并关闭该打印作业。

### <a name="example"></a>示例

  有关示例，请参阅[CDC::StartDoc](#startdoc)。

##  <a name="abortpath"></a>  CDC::AbortPath

关闭并放弃在设备上下文中的任何路径。

```
BOOL AbortPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果在设备上下文中打开路径括号，关闭路径括号和路径将被丢弃。 如果在设备上下文中没有封闭的路径，路径将被丢弃。

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

将注释从缓冲区复制到指定的增强格式图元文件。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>参数

*nDataSize*<br/>
以字节为单位指定注释缓冲区的长度。

*pCommentData*<br/>
指向包含注释的缓冲区。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

注释可能包含任何隐私信息 — 例如，图片和日期的源创建。 注释应以开头的应用程序签名，其后的数据。 注释不应包含特定于位置的数据。 特定于位置的数据指定位置的一个记录，并且它不应该包含因为一个图元文件可能会嵌入到另一个图元文件中。 此函数仅可用于增强型图元文件。

##  <a name="alphablend"></a>  CDC::AlphaBlend

调用此成员函数以显示透明或半透明的像素的位图。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>参数

*xDest*<br/>
指定以逻辑单位，目标矩形左上角的 x 坐标。

*yDest*<br/>
指定以逻辑单位，目标矩形左上角的 y 轴坐标。

*nDestWidth*<br/>
指定的宽度，以逻辑单元，目标矩形。

*nDestHeight*<br/>
指定以逻辑单位，目标矩形的高度。

*pSrcDC*<br/>
指向源设备上下文的指针。

*xSrc*<br/>
指定以逻辑单位，源矩形左上角的 x 坐标。

*ySrc*<br/>
指定以逻辑单位，源矩形左上角的 y 轴坐标。

*nSrcWidth*<br/>
指定的宽度，以逻辑单元，源矩形。

*nSrcHeight*<br/>
指定以逻辑单位，源矩形的高度。

*blend*<br/>
指定[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction)结构。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

请参阅[AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend) Windows SDK for 的详细信息中。

##  <a name="anglearc"></a>  CDC::AngleArc

绘制一条线段和一段弧线。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>参数

*x*<br/>
指定圆的中心的逻辑 x 坐标。

*y*<br/>
指定圆的中心的逻辑 y 坐标。

*nRadius*<br/>
使用逻辑单位指定圆的半径。 此值必须为正数。

*fStartAngle*<br/>
指定以度为单位相对于 x 轴的起始角度。

*fSweepAngle*<br/>
指定以度为单位的起始角度相对的扫描角度。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

直线段从当前位置到弧线的起始绘制。与给定的半径和中心圆的外围沿绘制弧线。 由给定的开始和扫描角度定义弧的长度。

`AngleArc` 将当前位置移动到弧线的结束点。此函数绘制弧线可能看起来是椭圆，具体取决于当前的转换和映射模式。 绘制圆弧之前, 此函数绘制当前位置到弧线的起始直线线段。通过构造具有指定的中心点附近指定半径假想圆绘制弧线。 通过从圆的 x 轴逆时针测量中的开始角度度数确定弧线的起始点。 通过从起点逆时针测量中的扫描角度度数位于同样到结束点。

如果扫描角度大于 360 度弧线是扫频多次。 此函数使用当前笔绘制线条。 该图不填充。

##  <a name="arc"></a>  CDC::Arc

绘制椭圆弧。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 x 坐标。

*y1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 y 坐标。

*x2*<br/>
指定 （以逻辑单位） 的边框右下角的 x 坐标。

*y2*<br/>
指定 （以逻辑单位） 的边框右下角的 y 坐标。

*x3*<br/>
指定的点定义圆弧的 x 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。

*y3*<br/>
指定定义弧的点的 y 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。

*x4*<br/>
指定定义弧的终结点 （以逻辑单位） 的点的 x 坐标。 此时没有要将其完全置于圆弧。

*y4*<br/>
指定定义弧的终结点 （以逻辑单位） 的点的 y 坐标。 此时没有要将其完全置于圆弧。

*lpRect*<br/>
指定的边框 （以逻辑单位）。 可以将传递任一 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*ptStart*<br/>
指定的点定义圆弧的 x 和 y 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。您可以传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

*ptEnd*<br/>
指定定义 （以逻辑单位） 的弧线的结束点的点 x 和 y 坐标。 此时没有要将其完全置于圆弧。您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

通过使用函数绘制弧线是由指定的边界矩形来定义椭圆的段。

圆弧的实际起始点是在其中从通过指定的起始点的边界矩形的中心绘制的射线相交椭圆的点。 圆弧的实际结束点是在其中从通过指定的结束点的边界矩形的中心绘制的射线相交椭圆的点。 以逆时针方向绘制弧线。 一段弧线，不是闭合的图，因为未填充。 宽度和矩形的高度必须大于 2 个单位和小于 32,767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

绘制椭圆弧。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 x 坐标。

*y1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 y 坐标。

*x2*<br/>
指定 （以逻辑单位） 的边框右下角的 x 坐标。

*y2*<br/>
指定 （以逻辑单位） 的边框右下角的 y 坐标。

*x3*<br/>
指定的点定义圆弧的 x 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。

*y3*<br/>
指定定义弧的点的 y 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。

*x4*<br/>
指定定义弧的终结点 （以逻辑单位） 的点的 x 坐标。 此时没有要将其完全置于圆弧。

*y4*<br/>
指定定义弧的终结点 （以逻辑单位） 的点的 y 坐标。 此时没有要将其完全置于圆弧。

*lpRect*<br/>
指定的边框 （以逻辑单位）。 可以将传递到指针[RECT](/windows/desktop/api/windef/ns-windef-tagrect)数据结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*ptStart*<br/>
指定的点定义圆弧的 x 和 y 坐标的起始位置 （以逻辑单位）。 此时没有要将其完全置于圆弧。您可以传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

*ptEnd*<br/>
指定定义 （以逻辑单位） 的弧线的结束点的点 x 和 y 坐标。 此时没有要将其完全置于圆弧。您可以传递`POINT`数据结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数是类似于`CDC::Arc`，只不过更新当前的位置。 点 ( *x1*， *y1*) 和 ( *x2*， *y2*) 指定的边框。 通过给定的边界矩形形成一个椭圆定义弧的曲线。圆弧逆时针 （默认反方向） 从扩展到的边界矩形的中心中的径向行与相交的位置的点 ( *x3*， *y3*)。 到的边界矩形的中心中的径向行与相交的位置的弧线端点 ( *x4*， *y4*)。 如果起始点和结束点是相同的绘制整个椭圆。

从当前位置到弧线的起始点绘制线条。如果未发生错误，当前的位置设置为弧线的结束点。使用当前笔; 绘制弧线未填充。

##  <a name="attach"></a>  CDC::Attach

使用此成员函数将附加*hDC*到`CDC`对象。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*HDC*存储在这种`m_hDC`，输出设备上下文，然后在`m_hAttribDC`，属性的设备上下文。

##  <a name="beginpath"></a>  CDC::BeginPath

在设备上下文中打开路径括号。

```
BOOL BeginPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

打开路径括号后，应用程序可以开始调用 GDI 绘图函数来定义包含同时位于点的路径中。 应用程序可以通过调用关闭一个开放路径方括号`EndPath`成员函数。 当应用程序调用`BeginPath`，任何以前的路径将被丢弃。

请参阅[BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) Windows SDK for 定义路径中的点绘制函数的列表中。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

将位图从源设备上下文复制到此当前设备上下文。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*nWidth*<br/>
指定目标矩形和源位图的宽度 （以逻辑单位）。

*nHeight*<br/>
指定目标矩形和源位图的高度 （以逻辑单位）。

*pSrcDC*<br/>
指向`CDC`标识将从中复制位图的设备上下文的对象。 它必须为 NULL，如果*dwRop*指定不包含源的光栅操作。

*xSrc*<br/>
指定的源位图左上角的逻辑 x 坐标。

*ySrc*<br/>
指定的源位图左上角的逻辑 y 坐标。

*dwRop*<br/>
指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、 可能的源位图和目标位图的输出操作中的颜色。 请参阅[BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt) Windows SDK for 的光栅操作代码的列表中*dwRop*及其说明

光栅操作代码的完整列表，请参阅[有关光栅操作代码](/windows/desktop/gdi/raster-operation-codes)Windows SDK 中。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

应用程序可以将 windows 或在字节边界上，确保客户端区域对齐`BitBlt`字节对齐的矩形上发生操作。 （设置 CS_BYTEALIGNWINDOW 或 CS_BYTEALIGNCLIENT 标志时注册窗口类。）

`BitBlt` 字节对齐的矩形上的操作是远远快于`BitBlt`上不是字节对齐的矩形的操作。 如果你想要指定类样式，如你自己的设备上下文的字节对齐方式，您必须注册窗口类而不是依赖于要为你的 Microsoft 基础类。 使用全局函数[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

GDI 转换*nWidth*并*nHeight*、 一次使用目标设备上下文，以及一次使用的源设备上下文。 如果不匹配的生成扩展盘区，GDI 将使用 Windows`StretchBlt`函数进行压缩或拉伸根据需要将源位图。

如果目标、 源和模式位图没有相同的颜色格式，`BitBlt`函数将转换源和模式位图，以与目标匹配的。 在转换中使用的目标位图的前景色和背景颜色。

当`BitBlt`函数将单色位图转换为颜色，它将白色位 (1) 设置为背景色，黑色位 (0) 到的前景色。 使用目标设备上下文的前景色和背景颜色。 若要将颜色转换为单色，`BitBlt`设置匹配的背景色为白色的像素为单位，并将其他所有像素都设置为黑色。 `BitBlt` 使用颜色的设备上下文的前景色和背景颜色的颜色转换为单色。

请注意，并非所有的设备上下文支持`BitBlt`。 若要检查是否支持给定的设备上下文`BitBlt`，使用`GetDeviceCaps`成员函数，并指定 RASTERCAPS 索引。

### <a name="example"></a>示例

  有关示例，请参阅[CDC::CreateCompatibleDC](#createcompatibledc)。

##  <a name="cdc"></a>  CDC::CDC

构造 `CDC` 对象。

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

绘制同时按下 （受限于一个椭圆和一条线段的交集的闭合图形）。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定的同时按下的左上角的 x 坐标的边框 （以逻辑单位）。

*y1*<br/>
指定的同时按下的左上角的 y 坐标的边框 （以逻辑单位）。

*x2*<br/>
指定的同时按下的右下角的 x 坐标的边框 （以逻辑单位）。

*y2*<br/>
指定的同时按下的右下角的 y 坐标的边框 （以逻辑单位）。

*x3*<br/>
指定的定义的同时按下的点的 x 坐标的起始位置 （以逻辑单位）。

*y3*<br/>
指定的定义的同时按下的点的 y 坐标的起始位置 （以逻辑单位）。

*x4*<br/>
指定定义 （以逻辑单位） 的同时按下的终结点的点的 x 坐标。

*y4*<br/>
指定定义 （以逻辑单位） 的同时按下的终结点的点的 y 坐标。

*lpRect*<br/>
指定的边框 （以逻辑单位）。 可以将传递任一 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*ptStart*<br/>
指定定义的同时按下点 x 和 y 坐标的起始位置 （以逻辑单位）。 此时没有要将其置于正好的同时按。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

*ptEnd*<br/>
指定定义 （以逻辑单位） 的同时按下的结束点的点 x 和 y 坐标。 此时没有要将其置于正好的同时按。 您可以传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

( *X1*， *y1*) 和 ( *x2*， *y2*) 参数的左上角和右下角，分别指定一个矩形范围是同时按下的一部分的椭圆。 ( *X3*， *y3*) 和 ( *x4*， *y4*) 参数指定的椭圆的直线终结点。 同时按下是由使用所选的笔绘制，并且通过使用所选的画笔来填充。

通过绘制图`Chord`函数最多个扩展，但不包括右侧和底部坐标。 这意味着图的高度*y2* - *y1*图的宽度为*x2* - *x1*。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

关闭开放图形路径中。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该函数通过从当前位置到图中的第一个点绘制一条线闭合图形 (通常情况下，指定要对最新的调用点`MoveTo`成员函数) 并将这些行连接使用线段联接样式。 如果使用闭合图形`LineTo`成员函数而不是`CloseFigure`，端帽用于创建而不是联接的角。 `CloseFigure` 只应调用设备上下文中打开路径括号是否。

图的路径中处于打开状态，除非显式将其关闭使用此函数。 （图可以打开即使当前点和图的起始点是相同的。）任何直线或曲线添加到的路径后`CloseFigure`开始一个新图形。

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

创建与指定的设备兼容的内存设备上下文*pDC*。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
一个指向设备上下文的指针。 如果*pDC*为 NULL，该函数将创建与系统显示兼容的内存设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

内存设备上下文是内存的表示显示图面块。 它可以用于在内存中的映像准备然后将其复制到兼容的设备的实际设备图面。

创建内存设备上下文，GDI 将自动为其选择 1-1 的单色股票位图。 可以使用内存设备上下文使用 GDI 输出函数，仅当已创建并选择该上下文到位图。

此函数仅可用于创建适用于支持光栅操作的设备兼容的设备上下文。 请参阅[cdc:: bitblt](#bitblt)设备上下文之间的位块传输有关的信息的成员函数。 若要确定设备上下文是否支持光栅操作，请参阅成员函数中的 RC_BITBLT 光栅功能`CDC::GetDeviceCaps`。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

创建指定的设备的设备上下文。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>参数

*lpszDriverName*<br/>
指向一个以 null 结尾的字符串，指定设备驱动程序 (例如，"EPSON") 的文件名 （不带扩展名）。 你还可以传递`CString`为此参数的对象。

*lpszDeviceName*<br/>
指向一个以 null 结尾的字符串，指定的特定设备的支持 （例如，"EPSON FX-80"） 的名称。 *LpszDeviceName*如果模块支持多个设备，则使用参数。 你还可以传递`CString`为此参数的对象。

*lpszOutput*<br/>
指向一个以 null 结尾的字符串，指定物理输出媒体 （文件或输出端口） 的文件或设备名称。 你还可以传递`CString`为此参数的对象。

*lpInitData*<br/>
指向`DEVMODE`包含设备驱动程序的特定于设备的初始化数据结构。 Windows`DocumentProperties`函数检索在给定设备为填充此结构。 *LpInitData*参数必须为 NULL，如果设备驱动程序会使用指定用户通过控制面板的默认初始化 （如果有）。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

打印。H 标头文件是必需的如果[DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea)使用结构。

设备名称遵循以下约定： 结束冒号 （:） 是推荐，但为可选。 Windows 中去除终止冒号，以便以冒号结尾的设备名称映射到与不带冒号相同的名称相同的端口。 驱动程序和端口名称不得包含前导或尾随空格。 具有信息的上下文不能使用 GDI 输出函数。

##  <a name="createic"></a>  CDC::CreateIC

创建指定的设备的信息上下文。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>参数

*lpszDriverName*<br/>
指向一个以 null 结尾的字符串，指定设备驱动程序 (例如，"EPSON") 的文件名 （不带扩展名）。 可以将传递`CString`为此参数的对象。

*lpszDeviceName*<br/>
指向一个以 null 结尾的字符串，指定的特定设备的支持 （例如，"EPSON FX-80"） 的名称。 *LpszDeviceName*如果模块支持多个设备，则使用参数。 可以将传递`CString`为此参数的对象。

*lpszOutput*<br/>
指向一个以 null 结尾的字符串，指定物理输出媒体 （文件或端口） 的文件或设备名称。 可以将传递`CString`为此参数的对象。

*lpInitData*<br/>
指向特定于设备的初始化数据的设备驱动程序。 *LpInitData*参数必须为 NULL，如果设备驱动程序会使用指定用户通过控制面板的默认初始化 （如果有）。 请参阅`CreateDC`为特定于设备的初始化的数据格式。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

信息上下文提供了一种以获取有关设备的信息，而无需创建设备上下文的快速方法。

设备名称遵循以下约定： 结束冒号 （:） 是推荐，但为可选。 Windows 中去除终止冒号，以便以冒号结尾的设备名称映射到与不带冒号相同的名称相同的端口。 驱动程序和端口名称不得包含前导或尾随空格。 具有信息的上下文不能使用 GDI 输出函数。

##  <a name="deletedc"></a>  CDC::DeleteDC

一般情况下，不能调用此函数;析构函数将为您完成它。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>返回值

如果成功，则完成此函数，非零值否则为 0。

### <a name="remarks"></a>备注

`DeleteDC`成员函数将删除与之关联的 Windows 设备上下文`m_hDC`在当前`CDC`对象。 如果此`CDC`对象是为给定设备的最后一个活动设备上下文、 通知设备和释放设备所使用的所有存储和系统资源。

应用程序不应调用`DeleteDC`如果设备上下文中选中了对象。 在被删除之前，首先必须从设备上下文选择对象。

应用程序必须删除设备上下文的句柄已获取通过调用[cwnd:: Getdc](../../mfc/reference/cwnd-class.md#getdc)。 相反，它必须调用[cwnd:: Releasedc](../../mfc/reference/cwnd-class.md#releasedc)以释放设备上下文。 [CClientDC](../../mfc/reference/cclientdc-class.md)并[CWindowDC](../../mfc/reference/cwindowdc-class.md)提供了类来封装此功能。

`DeleteDC`函数通常用于删除使用创建的设备上下文[CreateDC](#createdc)， [CreateIC](#createic)，或[CreateCompatibleDC](#createcompatibledc)。

### <a name="example"></a>示例

  有关示例，请参阅[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

自动调用`CWinApp`空闲时间处理程序`DeleteTempMap`删除临时`CDC`创建的对象`FromHandle`，但不会销毁设备上下文句柄 ( `hDC`s) 与暂时关联`CDC`对象。

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

调用此函数可分离`m_hDC`（输出设备上下文） 从`CDC`对象，并同时设置`m_hDC`和`m_hAttribDC`为 NULL。

```
HDC Detach();
```

### <a name="return-value"></a>返回值

Windows 设备上下文。

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

使用此函数时，将像素转换为 HIMETRIC 给 OLE，显示 HIMETRIC 大小。

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式，MM_LOENGLISH、 MM_HIENGLISH、 MM_LOMETRIC 或 MM_HIMETRIC 转换取决于在物理英寸像素数。 如果其他非约束模式之一 (例如，MM_TEXT) 的映射模式，则转换取决于在逻辑英寸像素数。

##  <a name="dptolp"></a>  CDC::DPtoLP

将设备单位转换为的逻辑单元。

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*nCount*<br/>
数组中的点的数目。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于将一个矩形从设备点转换为逻辑点的简单情况。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

函数将映射的每个点的坐标或大小，从设备坐标系统到 GDI 的逻辑坐标系统的维度。 转换取决于当前的映射模式和来源和设备的窗口和视区的扩展盘区的设置。

##  <a name="draw3drect"></a>  CDC::Draw3dRect

调用此成员函数以绘制三维矩形。

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指定的边框 （以逻辑单位）。 可以将传递到指针[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*clrTopLeft*<br/>
指定三维矩形的顶部和左侧边的颜色。

*clrBottomRight*<br/>
指定的颜色的底部和右侧的三维矩形。

*x*<br/>
指定三维矩形的左上角的逻辑 x 坐标。

*y*<br/>
指定三维矩形的左上角的逻辑 y 坐标。

*cx*<br/>
指定三维矩形的宽度。

*cy*<br/>
指定三维矩形的高度。

### <a name="remarks"></a>备注

将使用顶部和左侧边中指定的颜色绘制矩形*clrTopLeft*底部和中所指定的颜色的左右两侧*clrBottomRight*。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

调用此成员函数重复重绘拖动矩形。

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，指定矩形的逻辑坐标，在此情况下，重绘的矩形的结束位置。

*size*<br/>
指定外边框的矩形的内部边框 （即，边框的粗细） 的左上角，从左上角的位移。

*lpRectLast*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，指定矩形的位置的逻辑坐标，在此情况下，重绘的矩形的原始位置。

*sizeLast*<br/>
指定的外边框的内部边框 （即，边框的粗细） 重绘的原始矩形的左上角到左上角的位移。

*pBrush*<br/>
指向画笔对象的指针。 设置为 NULL 以使用默认半色调画笔。

*pBrushLast*<br/>
为使用的最后一个画笔对象的指针。 设置为 NULL 以使用默认半色调画笔。

### <a name="remarks"></a>备注

若要为提供视觉反馈示例鼠标位置，请调用其循环。 当您调用`DrawDragRect`、 清除上一个矩形和一个新绘制。 例如，为用户在屏幕上拖动矩形`DrawDragRect`将擦除原始矩形和重绘其新位置中的新建一个。 默认情况下，`DrawDragRect`消除闪烁并创建平稳移动矩形的外观使用半色调画笔绘制矩形。

第一次调用`DrawDragRect`，则*lpRectLast*参数应为 NULL。

##  <a name="drawedge"></a>  CDC::DrawEdge

调用此成员函数以绘制指定的类型和样式的矩形的边缘。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
一个指向`RECT`结构，其中包含矩形的逻辑坐标。

*nEdge*<br/>
指定要绘制的内部和外部边缘的类型。 此参数必须是一个内部边框标志和一个外部边框标志的组合。 请参阅[DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) Windows SDK for 参数的类型的表中。

*nFlags*<br/>
指定要绘制的边框类型的标志。 请参阅`DrawEdge`Windows SDK for 参数的值的表中。 对于对角线，BF_RECT 标志指定向量由矩形参数绑定的终结点。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

##  <a name="drawescape"></a>  CDC::DrawEscape

绘制无法通过图形设备接口 (GDI) 直接提供视频显示功能的访问。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>参数

*nEscape*<br/>
指定要执行的转义函数。

*nInputSize*<br/>
指定指向的数据的字节数*lpszInputData*参数。

*lpszInputData*<br/>
指向输入结构所需的指定转义符。

### <a name="return-value"></a>返回值

指定函数的结果。 大于零，如果成功，除了 QUERYESCSUPPORT 绘图转义符，实现; 仅检查如果未实现转义;，则为 0或小于零，如果错误发生。

### <a name="remarks"></a>备注

当应用程序调用`DrawEscape`，数据由标识*nInputSize*并*lpszInputData*直接传递到指定的显示驱动程序。

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

中用于指示该矩形具有焦点的样式绘制一个矩形。

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，它指定要绘制矩形的逻辑坐标。

### <a name="remarks"></a>备注

由于这是布尔 XOR 函数，调用此函数在第二个时间内使用相同的矩形从显示中移除该矩形。 不能滚动此函数绘制的矩形。 若要滚动包含此函数绘制的矩形区域，首先调用`DrawFocusRect`要从显示中删除该矩形，然后向下滚动区域，然后调用`DrawFocusRect`再次以在新位置中绘制矩形。

> [!CAUTION]
> `DrawFocusRect` 只能在 MM_TEXT 模式中运行。 在其他模式下，此函数不正确，绘制聚焦框，但它不返回错误值。

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

调用此成员函数来绘制框架控件的指定的类型和样式。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
一个指向`RECT`结构，其中包含矩形的逻辑坐标。

*n 类型*<br/>
指定要绘制的帧控件的类型。 请参阅*uType*中的参数[DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) Windows SDK for 此参数的可能值的列表中。

*nState*<br/>
指定框架控件的初始状态。 可以是一个或多个值的所述*uState*中的参数`DrawFrameControl`Windows SDK 中。 使用*nState*值 DFCS_ADJUSTRECT 调整要排除的推送按钮周围的边缘的边框。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

在几个情况下， *nState*取决于*n 类型*参数。 以下列表显示了四个之间的关系*n 类型*值和*nState*:

- DFC_BUTTON

    - DFCS_BUTTON3STATE 三态按钮

    - DFCS_BUTTONCHECK 复选框

    - DFCS_BUTTONPUSH 推送按钮

    - DFCS_BUTTONRADIO 单选按钮

    - DFCS_BUTTONRADIOIMAGE 单选按钮的图像 （非方形需要图像）

    - 单选按钮的 DFCS_BUTTONRADIOMASK 掩码 （非方形需要掩码）

- DFC_CAPTION

    - DFCS_CAPTIONCLOSE 关闭按钮

    - DFCS_CAPTIONHELP 帮助按钮

    - DFCS_CAPTIONMAX 最大化按钮

    - DFCS_CAPTIONMIN 最小化按钮

    - DFCS_CAPTIONRESTORE 还原按钮

- DFC_MENU

    - DFCS_MENUARROW 子菜单箭头

    - DFCS_MENUBULLET 项目符号

    - DFCS_MENUCHECK 选中标记

- DFC_SCROLL

    - DFCS_SCROLLCOMBOBOX 组合框滚动条

    - DFCS_SCROLLDOWN 向下箭头的滚动条

    - 滚动条 DFCS_SCROLLLEFT 向左键

    - 滚动条 DFCS_SCROLLRIGHT 向右键

    - 在窗口的右下角的 DFCS_SCROLLSIZEGRIP 大小手柄

    - 滚动条 DFCS_SCROLLUP 向上键

### <a name="example"></a>示例

此代码在窗口的右下角绘制大小手柄。 适用于`OnPaint`处理程序的对话框，其中具有没有样式，并且通常不包含可能会为其提供大小手柄的其他控件 （如状态栏）。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

当前所表示的设备上绘制图标`CDC`对象。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>参数

*x*<br/>
指定在左上角的图标的逻辑 x 坐标。

*y*<br/>
指定在左上角的图标的逻辑 y 坐标。

*hIcon*<br/>
标识要绘制的图标的句柄。

*点*<br/>
指定逻辑 x 坐标和 y 坐标的左上角的图标。 可以将传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

### <a name="return-value"></a>返回值

如果成功，则完成此函数，非零值否则为 0。

### <a name="remarks"></a>备注

该函数将在指定的位置的位置图标的左上角*x*并*y*。 位置受到的设备上下文的当前映射模式。

图标资源必须先前已加载，使用的功能`CWinApp::LoadIcon`， `CWinApp::LoadStandardIcon`，或`CWinApp::LoadOEMIcon`。 `MM_TEXT`在使用此函数之前，必须选择映射模式。

### <a name="example"></a>示例

  有关示例，请参阅[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。

##  <a name="drawstate"></a>  CDC::DrawState

调用此成员函数可显示的图像并将应用视觉效果来指示状态，例如，已禁用或默认状态。

> [!NOTE]
>  为所有*nFlag*状态除外 DSS_NORMAL，图像转换为单色之前应用视觉效果。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>参数

*pt*<br/>
指定的映像的位置。

*size*<br/>
指定图像的大小。

*hBitmap*<br/>
位图的句柄。

*nFlags*<br/>
指定图像类型和状态的标志。 请参阅[DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea)可能的 Windows SDK 中*nFlags*类型和状态。

*hBrush*<br/>
为画笔句柄。

*pBitmap*<br/>
指向 CBitmap 对象的指针。

*pBrush*<br/>
指向 CBrush 对象的指针。

*hIcon*<br/>
图标的图柄。

*lpszText*<br/>
指向文本指针。

*bPrefixText*<br/>
可能包含 accelerator 助记键的文本。 *LData*参数指定的地址的字符串，并*nTextLen*参数指定的长度。 如果*nTextLen*为 0，则假定该字符串以 null 结尾。

*nTextLen*<br/>
指向的文本字符串的长度*lpszText*。 如果*nTextLen*为 0，则假定该字符串以 null 结尾。

*lpDrawProc*<br/>
指向用于呈现的图像的回调函数的指针。 此参数是必需的如果映像中键入*nFlags*是 DST_COMPLEX。 它是可选的如果图像类型为 DST_TEXT，可以为 NULL。 对于所有其他图像类型，则忽略此参数。 回调函数的详细信息，请参阅[DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) Windows SDK 中的函数。

*lData*<br/>
指定映像的信息。 此参数的含义取决于图像类型。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

##  <a name="drawtext"></a>  CDC::DrawText

调用此成员函数以给定矩形中的文本格式。 若要指定其他格式设置选项，请使用[CDC::DrawTextEx](#drawtextex)。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为-1，该字符串必须以 null 结尾。

*nCount*<br/>
在字符串中指定字符的数。 如果*nCount*为-1，则*lpszString*被假定为指向以 null 结尾的字符串的长指针和`DrawText`自动计算的字符数。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含 （以逻辑坐标表示） 是用要设置格式文本的矩形。

*str*<br/>
一个[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定的字符。

*nFormat*<br/>
指定的设置文本格式的方法。 它可以是所述的值的任意组合*uFormat*中的参数[DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK 中。 （结合使用按位 OR 运算符）：

> [!NOTE]
>  某些*uFormat*标志组合可能会导致要修改所传递的字符串。 使用 DT_MODIFYSTRING DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 可能会导致要修改的字符串会导致在断言`CString`重写。 DT_CALCRECT、 DT_EXTERNALLEADING、 DT_INTERNAL、 DT_NOCLIP 和 DT_NOPREFIX 这些值不能用于 DT_TABSTOP 值。

### <a name="return-value"></a>返回值

如果函数运行成功的文本的高度。

### <a name="remarks"></a>备注

它的站点扩展到适当的空格，对齐到左、 右、 文本或给定矩形的中心选项卡，并将文本分解成适合给定矩形内的行设置格式的文本。 通过指定的格式设置类型*nFormat*。

此成员函数使用设备上下文的所选的字体、 文本颜色和背景色绘制文本。 除非使用 DT_NOCLIP 格式，否则`DrawText`剪辑文本，以便文本不显示给定矩形外。 假定所有格式设置具有多个行，除非给定 DT_SINGLELINE 格式。

如果所选的字体太大，指定矩形`DrawText`成员函数不会尝试替换为较小的字体。

如果指定 DT_CALCRECT 标志，则指定的矩形*lpRect*将更新以反映的宽度和高度所需用于绘制文本。

如果已设置 TA_UPDATECP 文本对齐标志 (请参阅[CDC::SetTextAlign](#settextalign))，`DrawText`将显示在当前的位置，而不在给定矩形的左侧开始的文本。 `DrawText` 将文本不换行时设置了 TA_UPDATECP 标志 （即，DT_WORDBREAK 标志不会影响）。

可以设置文本颜色[CDC::SetTextColor](#settextcolor)。

##  <a name="drawtextex"></a>  CDC::DrawTextEx

设置给定矩形中的文本的格式。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为-1，该字符串必须是 null 结束。

*nCount*<br/>
在字符串中指定字符的数。 如果*nCount*为-1，则*lpszString*被假定为指向以 null 结尾的字符串的长指针和`DrawText`自动计算的字符数。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含 （以逻辑坐标表示） 是用要设置格式文本的矩形。

*str*<br/>
一个[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定的字符。

*nFormat*<br/>
指定的设置文本格式的方法。 它可以是所述的值的任意组合*uFormat*中的参数[DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK 中。 (使用按位组合**或**运算符):

> [!NOTE]
>  某些*uFormat*标志组合可能会导致要修改所传递的字符串。 使用 DT_MODIFYSTRING DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 可能会导致要修改的字符串会导致在断言`CString`重写。 DT_CALCRECT、 DT_EXTERNALLEADING、 DT_INTERNAL、 DT_NOCLIP 和 DT_NOPREFIX 这些值不能用于 DT_TABSTOP 值。

*lpDTParams*<br/>
指向[DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams)结构，它指定其他格式设置选项。 此参数可以为 NULL。

### <a name="remarks"></a>备注

它的站点扩展到适当的空格，对齐到左、 右、 文本或给定矩形的中心选项卡，并将文本分解成适合给定矩形内的行设置格式的文本。 通过指定的格式设置类型*nFormat*并*lpDTParams*。 有关详细信息，请参阅[CDC::DrawText](#drawtext)并[DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) Windows SDK 中。

可以设置文本颜色[CDC::SetTextColor](#settextcolor)。

##  <a name="ellipse"></a>  CDC::Ellipse

绘制椭圆形。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定的椭圆的边框左上角的逻辑 x 坐标。

*y1*<br/>
指定的椭圆的边框左上角的逻辑 y 坐标。

*x2*<br/>
指定的椭圆的边框右下角的逻辑 x 坐标。

*y2*<br/>
指定的椭圆的边框右下角的逻辑 y 坐标。

*lpRect*<br/>
指定角的椭圆的边框。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

椭圆的中心是由指定的边界矩形的中心*x1*， *y1*， *x2*，以及*y2*，或*lpRect*。 使用当前笔绘制椭圆，并使用当前画笔填充其内部。

此函数绘制图最多个扩展，但不包括右侧和底部坐标。 这意味着图的高度*y2* - *y1*图的宽度为*x2* - *x1*。

如果边界矩形的高度或宽度为 0，绘制没有椭圆。

##  <a name="enddoc"></a>  CDC::EndDoc

结束通过调用启动打印作业[StartDoc](#startdoc)成员函数。

```
int EndDoc();
```

### <a name="return-value"></a>返回值

大于或等于如果函数运行成功，则为 0 或负值是否发生错误。

### <a name="remarks"></a>备注

此成员函数将替换 ENDDOC 打印机转义，并应完成打印作业的顺利完成后立即调用。

如果应用程序会遭遇打印错误或已取消的打印操作，它必须尝试通过使用终止操作`EndDoc`或[AbortDoc](#abortdoc)。 GDI 自动终止了操作后的，再返回错误值。

此函数不应在图元文件内。

### <a name="example"></a>示例

  有关示例，请参阅[CDC::StartDoc](#startdoc)。

##  <a name="endpage"></a>  CDC::EndPage

通知设备应用程序已完成对页的写。

```
int EndPage();
```

### <a name="return-value"></a>返回值

大于或等于如果函数运行成功，则为 0 或负值是否发生错误。

### <a name="remarks"></a>备注

此成员函数通常用于直接转到新页面的设备驱动程序。

此成员函数将替换 NEWFRAME 打印机转义。 与不同 NEWFRAME，打印的页后始终调用此函数。

### <a name="example"></a>示例

  有关示例，请参阅[CDC::StartDoc](#startdoc)。

##  <a name="endpath"></a>  CDC::EndPath

关闭路径括号，并选择在设备上下文由方括号定义的路径。

```
BOOL EndPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  有关示例，请参阅[cdc:: beginpath](#beginpath)。

##  <a name="enumobjects"></a>  CDC::EnumObjects

枚举钢笔和画笔设备上下文中可用。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>参数

*nObjectType*<br/>
指定的对象类型。 它可以具有值 OBJ_BRUSH 或 OBJ_PEN。

*lpfn*<br/>
是应用程序提供的回调函数的过程实例地址。 请参阅下面的"备注"部分。

*lpData*<br/>
指向应用程序提供的数据。 数据传递给回调函数和对象信息。

### <a name="return-value"></a>返回值

指定返回的最后一个值[回调函数](callback-functions-used-by-mfc.md#enum_objects)。 它的含义是用户定义的。

### <a name="remarks"></a>备注

对于给定类型的每个对象，您传递的回调函数调用替换为该对象的信息。 系统调用的回调函数，直到没有更多对象或回调函数将返回 0。

请注意 Microsoft Visual c + + 的新功能，可以使用普通函数，因为该函数传递给`EnumObjects`。 地址传递给`EnumObjects`指向与导出的函数的指针**导出**和使用 Pascal 调用约定。 在保护模式的应用程序，无需使用 Windows MakeProcInstance 函数创建此函数或使用 FreeProcInstance Windows 函数的使用后释放该函数。

也不需要导出中的函数名称**导出**应用程序的模块定义文件中的语句。 你可以改用**导出**函数修饰符，如

**int 回调导出**AFunction **(LPSTR**， **LPSTR);**

若要使编译器将发出导出的正确导出记录，方法是不带别名名称。 这适用于大多数需求。 对于某些特殊情况下，例如导出函数的序号比较还是别名导出，你仍需要使用**导出**模块定义文件中的语句。

有关 Microsoft Foundation 编译程序，你通常将使用 /GA 和 /GEs 编译器选项。 Microsoft 基础类中未使用 /Gw 编译器选项。 (如果使用 Windows 函数`MakeProcInstance`，您将需要显式转换到此 API 中所需的类型返回的函数指针从 FARPROC。)回调注册接口现在是类型安全 （必须传递一个指向正确类型的特定的回调函数的函数指针）。

另请注意，所有的回调函数必须返回到 Windows，因为不能跨回调边界引发异常之前捕获 Microsoft Foundation 异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

此成员函数是几乎已过时的 Win32 编程。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>参数

*nEscape*<br/>
指定要执行的转义函数。

转义函数的完整列表，请参阅[转义](/windows/desktop/api/wingdi/nf-wingdi-escape)Windows SDK 中。

*nCount*<br/>
指定指向的数据的字节数*lpszInData*。

*lpszInData*<br/>
指向此转义所需的输入的数据结构。

*lpOutData*<br/>
指向此转义从接收输出的结构。 *LpOutData*参数为 NULL，如果不返回任何数据。

*nInputSize*<br/>
指定指向的数据的字节数*lpszInputData*参数。

*lpszInputData*<br/>
指向输入结构所需的指定转义符。

*nOutputSize*<br/>
指定指向的数据的字节数*lpszOutputData*参数。

*lpszOutputData*<br/>
指向以接收来自此转义输出的结构。 如果不返回任何数据，此参数应为 NULL。

### <a name="return-value"></a>返回值

如果函数运行成功，除了 QUERYESCSUPPORT 转义符，它们只检查实现，则返回正值。 如果未实现转义符，则返回零。 如果出现错误，则返回负值。 以下是常见的错误值：

- SP_ERROR 常规错误。

- SP_OUTOFDISK 不足够的磁盘空间是目前适用于后台处理，并没有更多的空间将变为可用。

- SP_OUTOFMEMORY 不足够的内存是适用于后台处理。

- SP_USERABORT 用户结束通过打印管理器作业。

### <a name="remarks"></a>备注

原始打印机转义符，仅 QUERYESCSUPPORT 支持为 Win32 应用程序。 所有其他打印机转义符已过时，并且仅支持与 16 位应用程序兼容性。

对于 Win32 编程，`CDC`现在提供了取代其相应的打印机转义符的六个成员函数：

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

此外， [CDC::GetDeviceCaps](#getdevicecaps)支持取代其他打印机转义符的 Win32 索引。 请参阅[GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) Windows SDK for 的详细信息中。

此成员函数允许应用程序访问特定设备的设备，则无法直接通过 GDI。

使用第一个版本，如果应用程序使用预定义的转义值。 使用第二个版本，如果你的应用程序定义专用的转义值。 请参阅[ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape)适用于第二个版本的详细信息的 Windows SDK 中。

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

创建新的剪辑区域组成减去指定的矩形的现有剪辑区域。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形的左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形的左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形的右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形的右下角的逻辑 y 坐标。

*lpRect*<br/>
指定的矩形。 也可以是`CRect`对象。

### <a name="return-value"></a>返回值

指定新剪辑区域的类型。 它可以是以下值之一：

- COMPLEXREGION 区域有重叠的边框。

- 不创建错误任何区域。

- NULLREGION 区域为空。

- SIMPLEREGION 区域具有不重叠的边框。

### <a name="remarks"></a>备注

所指定的值的绝对值的矩形的宽度*x2* - *x1*，不能超过 32,767 单位。 此限制适用于还的矩形的高度。

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

可以从与关联的剪辑区域排除在窗口中的已更新的区域，从而防止无效窗口区域内的绘制`CDC`对象。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>参数

*pWnd*<br/>
指向要更新其窗口的窗口对象。

### <a name="return-value"></a>返回值

排除区域的类型。 它可以是以下值之一：

- COMPLEXREGION 区域有重叠的边框。

- 不创建错误任何区域。

- NULLREGION 区域为空。

- SIMPLEREGION 区域具有不重叠的边框。

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

用当前画笔填充显示图面的区域。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>参数

*x*<br/>
指定用于填充的开始处的点的逻辑 x 坐标。

*y*<br/>
指定用于填充的开始处的点的逻辑 y 坐标。

*crColor*<br/>
指定的边界或要填充的区域的颜色。 解释*crColor*上的值取决于*nFillType*。

*nFillType*<br/>
指定要执行填充的类型。 它必须是以下值之一：

- 填充区域的边界是通过指定的颜色的 FLOODFILLBORDER *crColor*。 此样式等同于由执行填充`FloodFill`。

- 通过指定的颜色由定义的填充区域的 FLOODFILLSURFACE *crColor*。 填充将继续进行向外所有方向，只要遇到颜色。 此样式可用于使用彩色边界填充区域。

### <a name="return-value"></a>返回值

如果函数成功，则非零值否则为 0，如果填充无法完成，如果给定的点的边界由指定的颜色*crColor* （如果 FLOODFILLBORDER 已请求），如果给定的点不具有指定的颜色*crColor*（如果 FLOODFILLSURFACE 已请求），或如果该点以外的剪辑区域。

### <a name="remarks"></a>备注

此成员函数提供比更大灵活性`FloodFill`因为您可以指定中的填充类型*nFillType*。

如果*nFillType*设置为 FLOODFILLBORDER，区域被认为完全受指定的颜色*crColor*。 该函数在指定的点开始*x*并*y*并填充到颜色边界的所有方向。

如果*nFillType*设置到 FLOODFILLSURFACE，该函数的点开始指定*x*并*y*和在填充所有相关领域的所有方向上继续包含由指定的颜色*crColor*。

只有内存设备上下文和支持光栅显示技术支持的设备`ExtFloodFill`。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数。

##  <a name="exttextout"></a>  CDC::ExtTextOut

调用此成员函数将使用当前所选的字体的矩形区域中的一个字符串。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>参数

*x*<br/>
指定字符串中指定的第一个字符的字符单元格的逻辑 x 坐标。

*y*<br/>
指定字符串中指定的第一个字符的字符单元格的顶部中的逻辑 y 坐标。

*nOptions*<br/>
指定的矩形类型。 此参数可以是一个，和 / 或任一以下值：

- ETO_CLIPPED 指定文本被截断至该矩形。

- ETO_OPAQUE 指定的当前背景色来填充矩形。 (您可以设置和查询与当前的背景色[SetBkColor](#setbkcolor)并[GetBkColor](#getbkcolor)成员函数。)

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构，它确定矩形的尺寸。 此参数可以为 NULL。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*lpszString*<br/>
指向要绘制的指定的字符字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。

*lpDxWidths*<br/>
指向指示相邻字符单元格的源服务器之间的距离值的数组。 例如， *lpDxWidths*[*我*] 逻辑单元将单独的字符单元格的来源*我*和字符单元格*我*+ 1。 如果*lpDxWidths*为 NULL，`ExtTextOut`使用字符之间的默认间距。

*str*<br/>
一个`CString`对象，其中包含要绘制的指定的字符。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

矩形区域可以是不透明的 （用当前的背景色填充），并且它可以是剪辑区域。

如果*nOptions*为 0 并*lpRect*为 NULL，该函数将文本写入到的设备上下文，而无需使用矩形区域。 默认情况下，函数不使用或更新当前位置。 如果应用程序需要时它将调用更新当前位置`ExtTextOut`，应用程序可以调用`CDC`成员函数[SetTextAlign](#settextalign)与*nFlags*设置为 TA_UPDATECP。 在设置此标志，Windows 将忽略*x*并*y*到后续调用`ExtTextOut`，并改为使用当前的位置。 当应用程序以更新当前的位置，而使用 TA_UPDATECP`ExtTextOut`当前位置到文本的前一行的末尾或指定指向数组的最后一个元素的位置设置*lpDxWidths*，两者中较大。

##  <a name="fillpath"></a>  CDC::FillPath

关闭任何打开图形中的当前路径，并使用当前画笔和多边形填充模式填充的路径的内部。

```
BOOL FillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

填充其内部后，路径将从设备上下文被丢弃。

##  <a name="fillrect"></a>  CDC::FillRect

调用此成员函数以填充给定的矩形使用指定的画笔。

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构，其中包含要填充的矩形的逻辑坐标。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。

*pBrush*<br/>
标识用于填充矩形的画笔。

### <a name="remarks"></a>备注

函数填充完成矩形，其中包括左侧和顶部边框，但它未填充右侧和底部边框。

画笔需要为创建使用[CBrush](../../mfc/reference/cbrush-class.md)成员函数[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)， [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)，和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)，或检索`GetStockObject`Windows 函数。

当填充指定的矩形，`FillRect`不包括矩形的右侧和底部边。 GDI 达，填充矩形，但不包括右侧列和底部行，而不考虑当前映射模式。 `FillRect` 比较的值`top`， `bottom`， `left`，和`right`指定矩形的成员。 如果`bottom`小于或等于`top`，或者如果`right`小于或等于`left`，不绘制矩形。

`FillRect` 类似于[CDC::FillSolidRect](#fillsolidrect); 但是，`FillRect`采用画笔并因此可用于使用纯色、 抖的色、 阴影的画笔或图案填充矩形。 `FillSolidRect` 使用仅纯色 （由 COLORREF 参数指示）。 `FillRect` 通常低于`FillSolidRect`。

##  <a name="fillrgn"></a>  CDC::FillRgn

填充指定的区域*pRgn*与由指定的画笔*pBrush*。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向要填充的区域的指针。 给定区域的坐标指定逻辑单元中。

*pBrush*<br/>
标识要用于填充区域的画笔。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

或者必须使用创建画笔`CBrush`成员函数`CreateHatchBrush`， `CreatePatternBrush`， `CreateSolidBrush`，或检索`GetStockObject`。

### <a name="example"></a>示例

  有关示例，请参阅[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

调用此成员函数以使用指定的纯色填充给定的矩形。

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指定的边框 （以逻辑单位）。 可以将传递到指针[RECT](/windows/desktop/api/windef/ns-windef-tagrect)数据结构或`CRect`为此参数的对象。

*clr*指定要用于填充矩形的颜色。

*x*<br/>
指定矩形的左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*cx*<br/>
指定的矩形的宽度。

*cy*<br/>
指定的矩形的高度。

### <a name="remarks"></a>备注

`FillSolidRect` 非常类似于[CDC::FillRect](#fillrect); 但是，`FillSolidRect`使用仅纯色 （由 COLORREF 参数指示），同时`FillRect`采用画笔并因此可以用于填充矩形用一种颜色，抖色颜色、 阴影的画笔或模式。 `FillSolidRect` 通常的速度快于`FillRect`。

> [!NOTE]
>  当您调用`FillSolidRect`，以前使用设置背景色[SetBkColor](#setbkcolor)，设置为所指示的颜色*clr*。

##  <a name="flattenpath"></a>  CDC::FlattenPath

转换到当前设备上下文中，选择的路径中的任何曲线并将各段曲线转换成一系列行。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="floodfill"></a>  CDC::FloodFill

用当前画笔填充显示图面的区域。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定用于填充的开始处的点的逻辑 x 坐标。

*y*<br/>
指定用于填充的开始处的点的逻辑 y 坐标。

*crColor*<br/>
指定的边界的颜色。

### <a name="return-value"></a>返回值

如果函数成功，则非零值否则给定的点具有指定的边界颜色时无法完成填满，返回 0 *crColor*，或者点之外的剪辑区域。

### <a name="remarks"></a>备注

若要为绑定指定由假定区域*crColor*。 `FloodFill`函数在指定的点开始*x*并*y*和在到颜色边界的所有方向上继续。

只有内存设备上下文和支持光栅显示技术支持的设备`FloodFill`成员函数。 有关 RC_BITBLT 功能的信息，请参阅`GetDeviceCaps`成员函数。

`ExtFloodFill`函数提供了类似的功能，但更大的灵活性。

##  <a name="framerect"></a>  CDC::FrameRect

指定的矩形周围绘制边框*lpRect*。

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含矩形的左上角和右下角中的逻辑坐标。 你还可以传递`CRect`为此参数的对象。

*pBrush*<br/>
标识要用于组帧矩形的画笔。

### <a name="remarks"></a>备注

该函数使用给定的画笔绘制边框。 宽度和边框的高度始终是 1 个逻辑单位。

如果该矩形`bottom`坐标小于或等于`top`，或者如果`right`小于或等于`left`，不绘制矩形。

通过绘制的边框`FrameRect`是在同一位置的边框来绘制`Rectangle`成员函数使用相同的坐标 (如果`Rectangle`使用笔宽 1 个逻辑单位)。 不填充的矩形的内部`FrameRect`。

##  <a name="framergn"></a>  CDC::FrameRgn

在指定的区域周围绘制的边框*pRgn*使用指定的画笔*pBrush*。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向`CRgn`对象，用于标识要括起来，边框的区域。 给定区域的坐标指定逻辑单元中。

*pBrush*<br/>
指向`CBrush`对象，用于标识要用于绘制边框的画笔。

*nWidth*<br/>
在垂直画笔笔画以设备为单位指定边框的宽度。

*nHeight*<br/>
在水平画笔笔画以设备为单位指定边框的高度。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  有关示例，请参阅[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)。

##  <a name="fromhandle"></a>  CDC::FromHandle

返回一个指向`CDC`对象时提供给设备上下文的句柄。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
包含 Windows 设备上下文的句柄。

### <a name="return-value"></a>返回值

指针可能是暂时的不应立即使用超出存储。

### <a name="remarks"></a>备注

如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。

### <a name="example"></a>示例

  有关示例，请参阅[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

返回设备上下文的当前反方向。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>返回值

如果成功，则指定当前反方向。 以下是有效的返回值：

- AD_COUNTERCLOCKWISE 弧线和逆时针绘制的矩形。

- AD_CLOCKWISE 弧线和沿顺时针方向绘制的矩形。

如果发生错误，则返回值为零。

### <a name="remarks"></a>备注

弧线和矩形函数使用的反方向。

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

检索当前的纵横比筛选器的设置。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>返回值

一个`CSize`对象，表示当前的纵横比为筛选器使用的纵横比。

### <a name="remarks"></a>备注

纵横比是格式正确的设备的像素宽度和高度的比率。 有关设备的纵横比的信息用于创建、 选择和显示的字体。 Windows 提供了特殊筛选器，纵横比筛选器，以选择为特定的长宽比从所有可用的字体的字体。 此筛选器使用指定的长宽比`SetMapperFlags`成员函数。

##  <a name="getbkcolor"></a>  CDC::GetBkColor

返回当前的背景色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

RGB 颜色值。

### <a name="remarks"></a>备注

如果后台模式下是不透明，系统将使用的背景色来填充带样式的行中的间隙中字符单元格, 的背景画笔中的阴影的线之间的间隔。 将位图颜色和单色设备上下文之间转换时，系统还使用背景色。

##  <a name="getbkmode"></a>  CDC::GetBkMode

返回后台模式。

```
int GetBkMode() const;
```

### <a name="return-value"></a>返回值

当前后台模式下，它可以是不透明。

### <a name="remarks"></a>备注

后台模式下定义系统是否删除现有的背景色绘图图面上绘制文本、 阴影的画笔或笔样式，不是一条实线之前。

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

返回指定的设备上下文的当前累计边界矩形。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>参数

*lpRectBounds*<br/>
指向将接收的当前边框的缓冲区。 矩形将返回逻辑坐标。

*flags*<br/>
指定是否要清除它返回后的边界矩形。 此参数应为零，或者设置为以下值：

- DCB_RESET 强制它返回后要清除的边框。

### <a name="return-value"></a>返回值

如果函数运行成功，则指定的边框的当前状态。 它可以是以下值的组合：

- 发生 DCB_ACCUMULATE 边界矩形累积。

- DCB_RESET 边界矩形为空。

- DCB_SET 边界矩形不为空。

- 上有 DCB_ENABLE 边界累积。

- DCB_DISABLE 边界累积处于关闭状态。

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

检索当前选定的设备上下文的画笔的原点 （以设备为单位）。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>返回值

当前的来源为 （以设备为单位） 的画笔[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="remarks"></a>备注

初始画笔原点位于 (0，0) 的客户端区域。 返回值以相对于桌面窗口的源设备单位指定此点。

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

检索各种类型的字符字符串的信息。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>参数

*lpString*<br/>
指向要处理的字符字符串的指针。

*nCount*<br/>
指定字符串的长度。 对于 ANSI 版本，它是字节计数，而 Unicode 函数则为字数统计。 有关详细信息，请参阅[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)。

*nMaxExtent*<br/>
该字符串处理到指定最大界限 （以逻辑单位）。 将忽略字符，如果处理，则会超出该范围。 任何所需的排序或字形数组的计算仅适用于包含的字符。 中指定 GCP_MAXEXTENT 值时才使用此参数*dwFlags*参数。 在函数处理输入的字符串，每个字符和其范围被添加到输出、 范围和其他数组仅当在总范围未超出最大值。 达到限制后，将停止处理。

*lpResults*<br/>
指向[GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa)接收函数的结果的结构。

*dwFlags*<br/>
指定如何处理到所需的数组的字符串。 此参数可以是一个或多个值中列出*dwFlags*一部分[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)主题。

*str*<br/>
一个指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象传递给过程。

### <a name="return-value"></a>返回值

如果函数成功，返回值将为的宽度和高度的逻辑单元中的字符串。

如果函数失败，则返回值为零。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)，如 Windows SDK 中所述。

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

从当前的 TrueType 字体中检索指定范围中的连续字符的宽度。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>参数

*nFirstChar*<br/>
指定为其返回的字符宽度的当前字体的字符范围中的第一个字符。

*nLastChar*<br/>
指定为其返回的字符宽度的当前字体的字符范围中最后一个字符。

*lpabc*<br/>
指向数组[ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)时该函数将返回收到的字符宽度的结构。 此数组必须包含至少为许多`ABC`结构指定的范围中有字符的方式*nFirstChar*并*nLastChar*参数。

*lpABCF*<br/>
指向数组的一个应用程序提供的缓冲区[ABCFLOAT](/windows/desktop/api/wingdi/ns-wingdi-_abcfloat)结构时该函数将返回接收的字符宽度。 此函数返回的宽度为 IEEE 浮点格式。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

逻辑单元中返回宽度。 此函数成功仅使用 TrueType 字体。

已选择的特定点大小后，TrueType 光栅器提供了"ABC"字符间距。 "A"间距是放置标志符号之前添加到当前位置的距离。 "B"间距是黑色部件的标志符号的宽度。 "C"间距被添加到当前位置的标志符号右侧的空白区域。 高级宽度的总给定 a + B + c。

当`GetCharABCWidths`成员函数将检索负"A"或"C"宽度的字符，该字符包括空白部分或延伸量。

要转换为字体设计单位 ABC 宽度，应用程序应创建一种字体的高度 (中指定的那样`lfHeight`的成员[LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta)结构) 中存储的值等于`ntmSizeEM`成员[NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica)结构。 (的值`ntmSizeEM`成员可以通过调用来检索[EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) Windows 函数。)

默认字符 ABC 宽度用于将当前所选字体的范围外的字符。

若要检索的非 TrueType 字体中字符的宽度，应用程序应使用[GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) Windows 函数。

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

检索的宽度，以从当前的 TrueType 字体在指定范围中的连续字形索引的逻辑单元。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>参数

*giFirst*<br/>
从当前字体的连续字形索引的组中指定的第一个标志符号索引。 如果仅使用此参数*pgi*参数为 NULL。

*cgi*<br/>
指定标志符号索引的数目。

*pgi*<br/>
指向包含标志符号索引的数组的指针。 如果值为 NULL， *giFirst*改为使用参数。 *Cgi*参数此数组中指定数量的标志符号索引。

*lpabc*<br/>
指向数组的指针[ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)接收的字符宽度的结构。 此数组必须包含至少为许多`ABC`结构的方式有指定的标志符号索引*cgi*参数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi)，如 Windows SDK 中所述。

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

从当前的字体，检索的一组连续的字符中的单个字符宽度使用`m_hAttribDC`，输入的设备上下文。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>参数

*nFirstChar*<br/>
指定在一组连续的当前字体中字符的第一个字符。

*nLastChar*<br/>
指定在一组连续的当前字体中字符的最后一个字符。

*lpBuffer*<br/>
指向将接收的当前字体中的一组连续的字符的宽度值的缓冲区。

*lpFloatBuffer*<br/>
指向用于接收的字符宽度的缓冲区。 返回的宽度是以 32 位 IEEE 浮点格式。 （宽度是沿着测量基准线的字符。）

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识以字母 a 和*nLastChar*标识以字母 z 以及函数检索所有小写字符的宽度。

该函数将值存储在通过指向的缓冲区*lpBuffer*。 此缓冲区必须足够大以保存所有宽度。 也就是说，必须有至少 26 条目中给出的示例。

如果特定字体中字符的连续组中的字符不存在，则将分配默认字符宽度的值。

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

检索的宽度，以逻辑坐标，从当前的字体在指定范围中的连续标志符号索引。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>参数

*giFirst*<br/>
从当前字体的连续字形索引的组中指定的第一个标志符号索引。 如果仅使用此参数*pgi*参数为 NULL。

*cgi*<br/>
指定标志符号索引的数目。

*pgi*<br/>
指向包含标志符号索引的数组的指针。 如果值为 NULL， *giFirst*改为使用参数。 *Cgi*参数此数组中指定数量的标志符号索引。

*lpBuffer*<br/>
指向接收宽度的缓冲区的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi)，如 Windows SDK 中所述。

##  <a name="getclipbox"></a>  CDC::GetClipBox

检索当前的剪辑边界周围 tightest 边界矩形的尺寸。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)要接收的矩形尺寸的对象。

### <a name="return-value"></a>返回值

剪辑区域的类型。 它可以是以下值之一：

- COMPLEXREGION 剪辑区域有重叠的边框。

- 错误的设备上下文不是有效的。

- NULLREGION 剪辑区域为空。

- SIMPLEREGION 剪辑区域的不重叠的边框。

### <a name="remarks"></a>备注

复制到指向缓冲区的维度*lpRect*。

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

检索设备上下文的颜色调整值。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>参数

*lpColorAdjust*<br/>
指向[COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)要接收的颜色调整值的数据结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

返回一个指向当前所选`CBitmap`对象。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>返回值

指向`CBitmap`对象，如果成功; 否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可返回临时对象。

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

返回一个指向当前所选`CBrush`对象。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>返回值

指向`CBrush`对象，如果成功; 否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可返回临时对象。

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

返回一个指向当前所选`CFont`对象。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>返回值

指向`CFont`对象，如果成功; 否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可返回临时对象。

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

返回一个指向当前所选`CPalette`对象。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>返回值

指向`CPalette`对象，如果成功; 否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可返回临时对象。

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

返回一个指向当前所选`CPen`对象。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>返回值

指向`CPen`对象，如果成功; 否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可返回临时对象。

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

检索当前的位置 （以逻辑坐标表示）。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>返回值

作为当前位置`CPoint`对象。

### <a name="remarks"></a>备注

可使用设置当前位置`MoveTo`成员函数。

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

检索当前画笔的颜色。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>返回值

如果函数成功，返回值是[COLORREF](/windows/desktop/gdi/colorref)当前画笔颜色值。

如果函数失败，返回值将为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor)，如 Windows SDK 中所述。

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

检索当前的钢笔颜色。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>返回值

如果函数成功，返回值是[COLORREF](/windows/desktop/gdi/colorref)当前钢笔颜色的值。

如果函数失败，返回值将为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor)，如 Windows SDK 中所述。

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

检索各种显示设备的特定于设备的信息。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>参数

*nIndex*<br/>
指定要返回的信息的类型。 请参阅[GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) Windows SDK for 值的列表中。

### <a name="return-value"></a>返回值

如果函数运行成功请求的功能的值。

### <a name="example"></a>示例

  有关示例，请参阅[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)。

##  <a name="getfontdata"></a>  CDC::GetFontData

从可缩放字体文件检索字体规格的信息。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>参数

*dwTable*<br/>
指定要返回的度量值表的名称。 此参数可以是一个度量值表中发布的 Microsoft Corporation 的 TrueType 字体文件规范所述。 如果此参数为 0，字体文件的开头处开始检索的信息。

*dwOffset*<br/>
指定从其开始检索信息的表开头的偏移量。 如果此参数为 0，从指定的表的开头处开始检索的信息*dwTable*参数。 如果此值是大于或等于的表的大小`GetFontData`返回 0。

*lpData*<br/>
指向将接收的字体信息的缓冲区。 如果此值为 NULL，则函数返回缓冲区中指定的字体数据所需的大小*dwTable*参数。

*cbData*<br/>
指定的长度以字节为单位，要检索的信息。 如果此参数为 0，`GetFontData`返回中指定的数据的大小*dwTable*参数。

### <a name="return-value"></a>返回值

指定指向的缓冲区中返回的字节数*lpData*如果函数运行成功; 否则为-1。

### <a name="remarks"></a>备注

由指定偏移量到字体文件和要返回的信息的长度标识要检索的信息。

应用程序有时可以使用`GetFontData`成员函数以将 TrueType 字体与文档一起保存。 若要执行此操作，该应用程序确定是否字体可嵌入，然后检索整个字体文件中，指定 0 表示*dwTable*， *dwOffset*，并*cbData*参数。

应用程序可以确定是否可以通过检查嵌入字体`otmfsType`的成员[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)结构。 如果位 1`otmfsType`设置的嵌入的字体不允许。 如果清除位 1，则可以嵌入字体。 如果设置位 2，嵌入为只读。

如果应用程序尝试使用此函数来检索非 TrueType 字体的信息`GetFontData`成员函数将返回-1。

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

返回有关指定的显示上下文的当前所选字体的信息。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>返回值

返回的值标识当前所选字体的特征。 有关可能的值的完整列表，请参阅[GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)，如 Windows SDK 中所述。

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

检索大纲曲线或位图中的当前字体的大纲字符。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>参数

*NChar*<br/>
指定为其信息是要返回的字符。

*nFormat*<br/>
指定该函数将返回信息的格式。 它可以是下列值之一或 0:

|值|含义|
|-----------|-------------|
|GGO_BITMAP|返回标志符号位图。 当该函数返回时，通过指向的缓冲区*lpBuffer*包含双字边界启动其中的行的每像素 1 位位图。|
|GGO_NATIVE|返回在光栅化程序的本机格式，使用设备单位中数据点的曲线。 中时指定此值，指定任何转换*lpmat2*将被忽略。|

时的值*nFormat*为 0，则该函数会填写[GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics)结构，但不返回字形轮廓数据。

*lpgm*<br/>
指向描述中的字符单元格的标志符号的位置的 GLYPHMETRICS 结构。

*cbbuffer:*<br/>
指定该函数将大纲字符的信息复制到其中的缓冲区的大小。 如果此值为 0， *nFormat*参数是 GGO_BITMAP 或 GGO_NATIVE 值，该函数将返回所需的缓冲区大小。

*lpBuffer*<br/>
该函数将大纲字符的信息复制到其中的缓冲区的点。 如果*nFormat*指定 GGO_NATIVE 值，在 TTPOLYGONHEADER 和 TTPOLYCURVE 结构的窗体中复制的信息。 如果此值为 NULL 并且*nFormat*是 GGO_BITMAP 或 GGO_NATIVE 值，该函数将返回所需的缓冲区大小。

*lpmat2*<br/>
指向[MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2)结构，其中包含的字符的转换矩阵。 此参数不能为 NULL，即使 GGO_NATIVE 值指定为*nFormat*。

### <a name="return-value"></a>返回值

大小 （字节），如果检索到的信息所需的缓冲区*cbbuffer:* 为 0 或*lpBuffer*为 NULL。 否则，为正值，如果函数运行成功，则为-1 如果出现错误。

### <a name="remarks"></a>备注

应用程序可以旋转位图格式检索通过指定指向的结构中的 2-2 转换矩阵的字符数*lpmat2*。

字形轮廓返回为一系列的轮廓。 通过定义每个 contour [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)结构后跟任意多个`TTPOLYCURVE`结构所需对其进行描述的方式。 作为返回的所有点[POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx)结构并表示绝对位置，而不是相对移动。 起始点的给定`pfxStart`的成员[TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)结构是大纲轮廓线的开始处的点。 [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve)折线记录或样条记录，可以是遵循的结构。 折线记录是一系列点;两个点之间绘制线条描述的字符的轮廓。 样条记录表示二次曲线由 TrueType （即，二次 b 样条）。

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

检索指定的设备上下文的当前图形模式。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>返回值

成功后返回当前图形模式。 此方法可返回的值的列表，请参阅[GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)。

在失败时返回 0。

若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

此方法会包装 Windows GDI 函数[GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)。

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

调用此成员函数以检索半色调画笔。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>返回值

一个指向`CBrush`如果成功，否则该值为 NULL 的对象。

### <a name="remarks"></a>备注

半色调画笔显示或者若要创建的抖动的模式的前景色和背景颜色的像素。 下面是创建的半色调画笔抖色模式的示例。

![抖动的钢笔笔画详细](../../mfc/reference/media/vc318s1.gif "的抖动的钢笔笔画详细信息")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

检索字距调整对指定的设备上下文中当前选定字体的字符。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>参数

*nPairs*<br/>
指定的数量[KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair)指向结构*lpkrnpair*。 该函数将不会复制更多字距调整对指定的*nPairs*。

*lpkrnpair*<br/>
指向数组的`KERNINGPAIR`接收字距调整的结构对该函数返回时。 此数组必须包含至少多少由指定的结构*nPairs*。 如果此参数为 NULL，该函数返回的字距调整对字体的总数。

### <a name="return-value"></a>返回值

如果函数运行成功，则指定字距调整对检索到的数或总数目的字距调整对在字体。 如果函数失败或有任何字距调整对字体，则返回零。

##  <a name="getlayout"></a>  CDC::GetLayout

调用此成员函数可确定文本和图形的设备上下文，如打印机或图元文件的布局。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>返回值

如果成功，布局会标记为当前的设备上下文。 否则为 GDI_ERROR。 对于扩展的错误的信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。 布局标志的列表，请参阅[CDC::SetLayout](#setlayout)。

### <a name="remarks"></a>备注

默认布局是从左到右。

##  <a name="getmapmode"></a>  CDC::GetMapMode

检索当前的映射模式。

```
int GetMapMode() const;
```

### <a name="return-value"></a>返回值

映射模式中。

### <a name="remarks"></a>备注

映射模式的说明，请参阅`SetMapMode`成员函数。

> [!NOTE]
>  如果您调用[SetLayout](#setlayout)若要为从右到左布局，更改 DC`SetLayout`自动更改为 MM_ISOTROPIC 的映射模式。 因此，对任何后续调用`GetMapMode`将返回 MM_ISOTROPIC。

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

返回设备上下文的斜联接限制。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

绘制几何行具有的斜接联接时，使用斜联接限制。

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

返回与指定的逻辑颜色最匹配的纯色。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定要匹配的颜色。

### <a name="return-value"></a>返回值

RGB （红色、 绿色、 蓝色） 颜色值，用于定义实体的颜色最接近*crColor*设备可以表示的值。

### <a name="remarks"></a>备注

给定的设备必须能够表示此颜色。

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

检索 TrueType 字体的指标的信息。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>参数

*lpotm*<br/>
指向数组[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)结构。 如果此参数为 NULL，则该函数返回的检索到的指标数据所需的缓冲区的大小。

*cbData*<br/>
指定的大小，以字节为单位向其返回信息的缓冲区。

*lpotm*<br/>
指向`OUTLINETEXTMETRIC`结构。 如果此参数为 NULL，则该函数返回检索到的指标信息所需的缓冲区的大小。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)结构包含大部分与 TrueType 格式中，提供的字体指标信息包括[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)结构。 最后四个成员`OUTLINETEXTMETRIC`结构都是指向字符串。 应用程序应为其他成员所需的空间除了这些字符串分配空间。 由于没有的字符串的大小没有系统施加限制，分配内存的最简单方法是通过指定为 NULL 来检索所需的大小*lpotm*在首次调用`GetOutlineTextMetrics`函数。

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

使用输出设备上下文， `m_hDC`，并从当前字体中检索一组连续的字符中的单个字符的宽度。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>参数

*nFirstChar*<br/>
指定在一组连续的当前字体中字符的第一个字符。

*nLastChar*<br/>
指定在一组连续的当前字体中字符的最后一个字符。

*lpBuffer*<br/>
指向将接收的当前字体中的一组连续的字符的宽度值的缓冲区。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识以字母 a 和*nLastChar*标识以字母 z 以及函数检索所有小写字符的宽度。

该函数将值存储在通过指向的缓冲区*lpBuffer*。 此缓冲区必须大到足以容纳所有的宽度。也就是说，必须有至少 26 条目中给出的示例。

如果特定字体中字符的连续组中的字符不存在，则将分配默认字符宽度的值。

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

调用此成员函数来计算的宽度和高度的字符字符串使用[m_hDC](#m_hdc)，输出设备上下文。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要测量的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，长度进行计算。

*nTabPositions*<br/>
指定指向数组中的制表位位置数*lpnTabStopPositions*。

*lpnTabStopPositions*<br/>
指向包含逻辑单元中的制表位位置的整数的数组。 必须以递增顺序; 排序的制表位最小 x 值应为数组中的第一项。 不允许向后制表位。

*str*<br/>
一个`CString`对象，其中包含要测量的指定的字符。

### <a name="return-value"></a>返回值

中的字符串 （以逻辑单位） 的维度[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果该字符串包含一个或多个选项卡字符，由指定的制表位基于字符串的宽度*lpnTabStopPositions*。 该函数使用当前所选的字体来计算字符串的尺寸。

为当前剪辑区域的宽度和高度返回不偏移量`GetOutputTabbedTextExtent`函数。

由于某些设备不要放置在正则单元格数组中的字符 （即，它们对大于字距调整字符），字符串中字符的盘区的总和可能不等于字符串的范围。

如果*nTabPositions*为 0 并*lpnTabStopPositions*为 NULL，选项卡扩展到八个的平均字符宽度。 如果*nTabPositions*为 1，制表位将分隔指定数组中的第一个值的距离*lpnTabStopPositions*点。 如果*lpnTabStopPositions*远远超出了单个值的点，一个制表位设置为每个值在数组中，指定的数目可高达*nTabPositions*。

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

调用此成员函数可使用输出设备上下文[m_hDC](#m_hdc)，并计算宽度，并使用当前的字体的文本行高度。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，长度进行计算。

*str*<br/>
一个`CString`对象，其中包含要测量的指定的字符。

### <a name="return-value"></a>返回值

（以逻辑单位） 的字符串中返回的维度[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

宽度和高度由当前剪辑区域不会影响`GetOutputTextExtent`。

由于某些设备不要放置在正则单元格数组中的字符 （即，它们执行字距调整），字符串中字符的盘区的总和可能不等于字符串的范围。

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

检索当前字体使用的度量值`m_hDC`，输出设备上下文。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>参数

*lpMetrics*<br/>
指向[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)接收指标的结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getpath"></a>  CDC::GetPath

检索定义的终结点的直线和曲线选入设备上下文在路径中找到的控点的坐标。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)数据结构或`CPoint`位于其中的行的终结点和曲线控制点的对象。

*lpTypes*<br/>
指向的顶点类型的放置位置的字节数组。 值为以下值之一：

- 指定相应点的 PT_MOVETO *lpPoints*启动非连续图。

- 指定前一个点，并相应中点的 PT_LINETO *lpPoints*是一条线的终结点。

- 指定相应点的 PT_BEZIERTO *lpPoints*控点或 Bzier 曲线的结束点。

PT_BEZIERTO 类型始终发生在的三个组中。 在它们前面紧邻的路径点定义 Bzier 曲线的起始点。 前两个 PT_BEZIERTO 点的控点，并且第三个 PT_BEZIERTO 点，则终结点 (如果硬编码)。

   可能与以下标志结合 PT_LINETO 或 PT_BEZIERTO 类型 (通过使用按位运算符**OR**) 以指示相应点的图中的最后一个点，并且应关闭图：

- PT_CLOSEFIGURE 指定相应的行后自动关闭图或绘制曲线。 绘制一条从直线或曲线终结点到点相对应的最后一个 PT_MOVETO 可关闭该图。

*nCount*<br/>
指定的总数[点](/windows/desktop/api/windef/ns-windef-tagpoint)将会放入的数据结构*lpPoints*数组。 此值必须与将会放入的字节数相同*lpTypes*数组。

### <a name="return-value"></a>返回值

如果*nCount*参数不为零，点枚举数。 如果*nCount*为 0，路径中点的总数 (和`GetPath`向缓冲区写入任何内容)。 如果*nCount*为非零且小于点的数量比在路径中，返回值为-1。

### <a name="remarks"></a>备注

设备上下文必须包含封闭的路径。 在逻辑坐标中返回的路径中的点。 点的存储的路径中设备坐标，因此`GetPath`变为点设备坐标从逻辑坐标表示使用当前转换的反函数。 `FlattenPath`成员函数可能会在调用之前`GetPath`，以在路径中的所有曲线都转换为直线线段。

### <a name="example"></a>示例

  有关示例，请参阅[cdc:: beginpath](#beginpath)。

##  <a name="getpixel"></a>  CDC::GetPixel

检索由指定的点处的像素的 RGB 颜色值*x*并*y*。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>参数

*x*<br/>
指定要检查的点的逻辑 x 坐标。

*y*<br/>
指定要检查的点的逻辑 y 坐标。

*点*<br/>
指定逻辑 x 坐标和 y 坐标要检查的点。

### <a name="return-value"></a>返回值

无论是哪个版本的函数，给定的点的颜色 RGB 颜色值。 如果坐标不在的剪辑区域指定一个点，则为-1。

### <a name="remarks"></a>备注

点必须位于中的剪辑区域。 如果点不在的剪辑区域，该函数将不起作用，并返回-1。

不是所有的设备都支持 `GetPixel` 函数。 有关详细信息，请参阅 RC_BITBLT 光栅功能下的[GetDeviceCaps](#getdevicecaps)成员函数。

`GetPixel`成员函数有两种形式。 第一个采用两个坐标值;第二个选项是[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

检索当前的多边形填充模式。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>返回值

当前填充多边形的模式，备用或绕组，如果函数运行成功。

### <a name="remarks"></a>备注

请参阅`SetPolyFillMode`多边形填充模式的描述的成员函数。

##  <a name="getrop2"></a>  CDC::GetROP2

检索当前的绘制模式。

```
int GetROP2() const;
```

### <a name="return-value"></a>返回值

绘制模式。 绘图模式值的列表，请参阅`SetROP2`成员函数。

### <a name="remarks"></a>备注

绘制模式指定如何与已在显示图面上的颜色组合笔的颜色和填充对象的内部。

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

调用此成员函数可获取[m_hDC](#m_hdc)，输出设备上下文。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>返回值

设备上下文句柄。

### <a name="remarks"></a>备注

此成员函数还可与 null 指针。

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

检索当前的位图拉伸模式。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>返回值

返回的值指定的当前位图拉伸模式 — STRETCH_ANDSCANS、 STRETCH_DELETESCANS 或 STRETCH_ORSCANS — 如果函数运行成功。

### <a name="remarks"></a>备注

位图拉伸模式定义如何从拉伸或压缩来压缩的位图中删除信息`StretchBlt`成员函数。

STRETCH_ANDSCANS 和 STRETCH_ORSCANS 模式通常用于保留前景色中单色位图的像素为单位。 STRETCH_DELETESCANS 模式通常用于保留在色位图中的颜色。

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

调用此成员函数来计算的宽度和高度的字符字符串使用[m_hAttribDC](#m_hattribdc)，属性的设备上下文。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，长度进行计算。

*nTabPositions*<br/>
指定指向数组中的制表位位置数*lpnTabStopPositions*。

*lpnTabStopPositions*<br/>
指向包含逻辑单元中的制表位位置的整数的数组。 必须以递增顺序; 排序的制表位最小 x 值应为数组中的第一项。 不允许向后制表位。

*str*<br/>
一个`CString`对象，其中包含要绘制的指定的字符。

### <a name="return-value"></a>返回值

中的字符串 （以逻辑单位） 的维度[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果该字符串包含一个或多个选项卡字符，由指定的制表位基于字符串的宽度*lpnTabStopPositions*。 该函数使用当前所选的字体来计算字符串的尺寸。

为当前剪辑区域的宽度和高度返回不偏移量`GetTabbedTextExtent`函数。

由于某些设备不要放置在正则单元格数组中的字符 （即，它们对大于字距调整字符），字符串中字符的盘区的总和可能不等于字符串的范围。

如果*nTabPositions*为 0 并*lpnTabStopPositions*为 NULL，选项卡扩展到八次平均字符宽度。 如果*nTabPositions*为 1，制表位将分隔指定数组中的第一个值的距离*lpnTabStopPositions*点。 如果*lpnTabStopPositions*远远超出了单个值的点，一个制表位设置为每个值在数组中，指定的数目可高达*nTabPositions*。

##  <a name="gettextalign"></a>  CDC::GetTextAlign

检索设备上下文的文本对齐方式标志的状态。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>返回值

文本对齐方式标志的状态。 返回值是一个或多个以下值：

- TA_BASELINE 指定对齐方式的 x 轴和边框内的所选字体的基线。

- TA_BOTTOM 指定对齐方式的 x 轴和边界的矩形的底部。

- TA_CENTER 指定对齐方式的 y 轴，边界矩形的中心。

- TA_LEFT 指定对齐方式的 y 轴，左侧和右侧的边界矩形。

- TA_NOUPDATECP 指定不更新当前的位置。

- TA_RIGHT 指定对齐方式的 y 轴，边界矩形右侧。

- TA_TOP 指定对齐方式的 x 轴和边界的矩形的顶部。

- TA_UPDATECP 指定，将更新为当前的位置。

### <a name="remarks"></a>备注

文本对齐方式标志确定如何`TextOut`和`ExtTextOut`成员函数对齐文本相对于字符串的起始点的字符串。 文本对齐方式标志不一定是单一位标志，可能是等于 0。 若要测试是否设置了标志，应用程序应执行以下步骤：

1. 将按位 OR 运算符应用于标志和其相关的标志，分组，如下所示：

    - TA_LEFT、 TA_CENTER 和 TA_RIGHT

    - TA_BASELINE、 TA_BOTTOM 和 TA_TOP

    - TA_NOUPDATECP 和 TA_UPDATECP

1. 将应用按位-和运算符的结果和返回值的`GetTextAlign`。

1. 此结果和标志的相等性测试。

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

检索 intercharacter 间距量的当前设置。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>返回值

Intercharacter 间距量。

### <a name="remarks"></a>备注

GDI 将此间距添加到每个字符，包括中断字符时它将一行文本写入到的设备上下文。

Intercharacter 间距量的默认值为 0。

##  <a name="gettextcolor"></a>  CDC::GetTextColor

检索当前的文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

当前为 RGB 颜色值的文本颜色。

### <a name="remarks"></a>备注

文本颜色是使用 GDI 文本输出成员函数来绘制字符的前景色[TextOut](#textout)， [ExtTextOut](#exttextout)，并[TabbedTextOut](#tabbedtextout)。

##  <a name="gettextextent"></a>  CDC::GetTextExtent

调用此成员函数以计算宽度，并使用当前的字体以确定维度的文本行高度。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。

*str*<br/>
一个`CString`对象，其中包含指定的字符。

### <a name="return-value"></a>返回值

中的字符串 （以逻辑单位） 的维度[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

从检索的信息[m_hAttribDC](#m_hattribdc)，属性的设备上下文。

默认情况下，`GetTextExtent`假定沿水平行设置为其检索维度的文本 （即，escapement 为 0）。 如果您创建指定非零值 escapement 的字体，则必须转换显式要获取字符串的尺寸的文本的角度。

宽度和高度由当前剪辑区域不会影响`GetTextExtent`。

由于某些设备不要放置在正则单元格数组中的字符 （即，它们执行字距调整），字符串中字符的盘区的总和可能不等于字符串的范围。

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

检索中将不超出指定的空间和为每个这些字符的文本范围内与填充数组的指定字符串的字符数。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*pgiIn*<br/>
指向数组的范围为要检索的字形索引的指针。

*cgi*<br/>
指向数组中指定的标志符号数*pgiIn*。

*nMaxExtent*<br/>
逻辑单元，带格式字符串中指定最大允许的宽度。

*lpnFit*<br/>
指向一个整数，它接收的最大可放在指定的空间中的字符数的计数*nMaxExtent*。 当*lpnFit*为 NULL， *nMaxExtent*将被忽略。

*alpDx*<br/>
指向接收部分标志符号扩展盘区的整数数组的指针。 数组中的每个元素提供的距离，以适合由指定的空间中字形的一个标志符号索引数组的开头之间的逻辑单元*nMaxExtent*。 尽管此数组应具有与指定的标志符号索引至少多少元素*cgi*，该函数填充范围仅适用于任意多个标志符号索引为指定的数组*lpnFit*。 如果*lpnDx*为 NULL，该函数不会计算部分字符串宽度。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)接收逻辑单元中的标志符号索引数组的维度的结构。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi)，如 Windows SDK 中所述。

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

检索的宽度和高度指定的标志符号索引数组。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*pgiIn*<br/>
指向数组的范围为要检索的字形索引的指针。

*cgi*<br/>
指向数组中指定的标志符号数*pgiIn*。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)接收逻辑单元中的标志符号索引数组的维度的结构。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数的功能[GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi)，如 Windows SDK 中所述。

##  <a name="gettextface"></a>  CDC::GetTextFace

调用此成员函数将复制到缓冲区的当前字体的字体名称。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>参数

*nCount*<br/>
指定缓冲区的大小 （以字节为单位）。 如果字体名称的长度超过指定此参数的字节数，该名称被截断。

*lpszFacename*<br/>
指向字样名称的缓冲区。

*rString*<br/>
对引用[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

### <a name="return-value"></a>返回值

将复制到缓冲区，不包括终止 null 字符的字节数。 如果发生错误，则为 0。

### <a name="remarks"></a>备注

字样名称被复制为以 null 结尾的字符串。

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

检索当前字体使用属性的设备上下文的度量值。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>参数

*lpMetrics*<br/>
指向[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)接收指标的结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getviewportext"></a>  CDC::GetViewportExt

检索 x-和 y 的盘区的设备上下文的视区。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>返回值

X-和 y 的盘区 （以设备为单位） 为`CSize`对象。

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

检索与设备上下文关联的视区原点 x 和 y 坐标。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>返回值

（在设备区坐标中） 作为的视区原点`CPoint`对象。

##  <a name="getwindow"></a>  CDC::GetWindow

返回与显示设备上下文关联的窗口。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>返回值

指向`CWnd`如果成功，否则该值为 NULL 的对象。

### <a name="remarks"></a>备注

这是高级的函数。 例如，此成员函数可能返回视图窗口，在打印时或在打印预览中。 它始终返回与输出关联的窗口。 使用给定的 DC 的输出函数绘制到此窗口。

##  <a name="getwindowext"></a>  CDC::GetWindowExt

检索 x-和 y 的盘区的设备上下文与关联的窗口。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>返回值

X-和 y 的盘区 （以逻辑单位） 为`CSize`对象。

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

检索与设备上下文关联的窗口原点 x 和 y 坐标。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>返回值

（以逻辑坐标表示） 窗口中，根据源`CPoint`对象。

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

检索当前的世界空间到页面空间转换。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>参数

*rXform*<br/>
引用[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)接收页面空间转换到的当前世界空间的结构。

### <a name="return-value"></a>返回值

成功时返回非零值。

在失败时返回 0。

若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

此方法会包装 Windows GDI 函数[GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform)。

##  <a name="gradientfill"></a>  CDC::GradientFill

调用此成员函数以使用到另一侧顺利淡出的颜色填充矩形和三角形的结构。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>参数

*pVertices*<br/>
指向数组的指针[TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex)结构，因为每个定义三角形顶点。

*nVertices*<br/>
顶点数。

*pMesh*<br/>
数组[GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle)三角形模式或数组中的结构[GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect)矩形模式中的结构。

*nMeshElements*<br/>
中的元素 （三角形或矩形） 数目*pMesh*。

*dwMode*<br/>
指定渐变填充模式。 有关可能的值的列表，请参阅[GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) Windows SDK 中。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅`GradientFill`Windows SDK 中。

##  <a name="graystring"></a>  CDC::GrayString

绘制暗显内存位图中写入文本、 变暗位图，然后将位图复制到显示在给定位置 （灰色） 文本。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*pBrush*<br/>
标识要用于变暗 （灰色） 的画笔。

*lpfnOutput*<br/>
指定将绘制字符串的应用程序提供的回调函数的过程实例地址。 有关详细信息，请参阅 Windows 说明`OutputFunc`[回调函数](callback-functions-used-by-mfc.md#graystring)。 如果此参数为 NULL，系统将使用 Windows`TextOut`函数来绘制字符串，并*lpData*被假定为指向要输出的字符字符串的长指针。

*lpData*<br/>
指定要传递到输出函数的数据的较远指针。 如果*lpfnOutput*为 NULL， *lpData*必须是指向要输出的字符串的长指针。

*nCount*<br/>
指定要输出的字符数。 如果此参数为 0，`GrayString`计算字符串的长度 (假定*lpData*是指向字符串的指针)。 如果*nCount*是-1 和指向函数*lpfnOutput*返回 0 时，图像时显示，但未变暗。

*x*<br/>
指定将此字符串的矩形的起始位置的逻辑 x 坐标。

*y*<br/>
指定将此字符串的矩形的起始位置的逻辑 y 坐标。

*nWidth*<br/>
指定将此字符串的矩形的宽度 （以逻辑单位）。 如果*nWidth*为 0，`GrayString`计算的区域中，宽度假设*lpData*是指向字符串的指针。

*nHeight*<br/>
指定将此字符串的矩形的高度 （以逻辑单位）。 如果*nHeight*为 0，`GrayString`计算的区域，高度假设*lpData*是指向字符串的指针。

### <a name="return-value"></a>返回值

非零，如果绘制的字符串，或者，如果任一 0`TextOut`函数或应用程序提供的输出函数返回 0，或如果没有足够的内存来创建变暗的内存位图。

### <a name="remarks"></a>备注

该函数变暗而不考虑所选定的画笔和背景的文本。 `GrayString`成员函数使用当前所选的字体。 使用此函数之前，必须选择 MM_TEXT 映射模式。

应用程序可以支持纯灰颜色而无需调用设备上绘制灰显 （灰显） 字符串`GrayString`成员函数。 系统颜色 COLOR_GRAYTEXT 是用来绘制无效的文本的实线灰色系统颜色。 应用程序可以调用`GetSysColor`Windows 函数来检索 COLOR_GRAYTEXT 的颜色值。 如果不为 0 （黑色） 颜色，应用程序可以调用`SetTextColor`成员函数来设置文本颜色为颜色值，然后直接绘制字符串。 如果检索到的颜色为黑色，应用程序必须调用`GrayString`来灰显 （灰色） 文本。

如果*lpfnOutput*为 NULL，GDI 使用 Windows [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta)函数，并且*lpData*被假定为要输出的字符的较远指针。 如果要输出的字符不能由`TextOut`成员函数 （例如，字符串存储为位图），该应用程序必须提供其自己的输出函数。

另请注意，所有的回调函数必须返回到 Windows，因为不能跨回调边界引发异常之前捕获 Microsoft Foundation 异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

回调函数传递给`GrayString`必须使用`__stdcall`调用约定，并且必须使用导出`__declspec`。

当框架是在预览模式下，调用`GrayString`成员函数将转换为`TextOut`调用时，并在回调函数不会调用。

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

使用此函数时将 HIMETRIC 大小从 OLE 转换为像素。

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式，MM_LOENGLISH、 MM_HIENGLISH、 MM_LOMETRIC 或 MM_HIMETRIC 转换取决于在物理英寸像素数。 如果其他非约束模式之一 (例如，MM_TEXT) 的映射模式，则转换取决于在逻辑英寸像素数。

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

调用此函数可将 HIMETRIC 单位转换为的逻辑单元。

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

从 OLE 获取 HIMETRIC 大小和想要将它们转换为应用程序的自然映射模式下时，请使用此函数。

转换被通过首先将 HIMETRIC 单位转换成像素，然后将这些单位转换成使用设备上下文的当前映射单位的逻辑单元。 请注意，设备的窗口和视区的扩展盘区会影响结果。

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

创建新的剪辑区域： 建立的当前区域和指定的矩形的交集*x1*， *y1*， *x2*，和*y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形的左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形的左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形的右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形的右下角的逻辑 y 坐标。

*lpRect*<br/>
指定的矩形。 您可以传递`CRect`对象或一个指向`RECT`结构为此参数。

### <a name="return-value"></a>返回值

新的剪辑区域的类型。 它可以是以下值之一：

- COMPLEXREGION 新剪辑区域有重叠的边框。

- 错误的设备上下文不是有效的。

- NULLREGION 新剪辑区域为空。

- SIMPLEREGION 新剪辑区域具有不重叠的边框。

### <a name="remarks"></a>备注

GDI 剪辑以适应新的边界内的所有后续输出。 宽度和高度不能超过 32,767。

##  <a name="invertrect"></a>  CDC::InvertRect

反转给定矩形的内容。

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向`RECT`，其中包含要进行反转矩形的逻辑坐标。 你还可以传递`CRect`为此参数的对象。

### <a name="remarks"></a>备注

反转是一个逻辑不操作和投掷的每个像素的位。 单色显示中，在该函数会白色像素黑色和黑色像素白色。 在颜色显示反转取决于如何显示生成的颜色。 调用`InvertRect`两次使用相同的矩形将显示还原到其以前的颜色。

如果矩形为空，不会绘制。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

反转中指定的区域的颜色*pRgn*。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要会反向时点的区域。 逻辑单元中指定的区域的坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

单色显示中，在该函数会白色像素黑色和黑色像素白色。 在颜色显示反转取决于如何显示生成的颜色。

##  <a name="isprinting"></a>  CDC::IsPrinting

确定是否正在使用的设备上下文进行打印。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>返回值

如果非零`CDC`对象是打印机 DC; 否则为 0。

##  <a name="lineto"></a>  CDC::LineTo

从当前位置到，但不是包括，由指定的点绘制一条线*x*并*y* (或*点*)。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定行的终结点的逻辑 x 坐标。

*y*<br/>
指定行的终结点的逻辑 y 坐标。

*点*<br/>
指定线条的端点。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

非零界限; 如果否则为 0。

### <a name="remarks"></a>备注

使用所选笔绘制线条。 当前的位置设置为*x*， *y*或设置为*点*。

### <a name="example"></a>示例

  有关示例，请参阅[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。

##  <a name="lptodp"></a>  CDC::LPtoDP

将设备单位转换为逻辑单元。

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向的点数组。 数组中的每个点都[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*nCount*<br/>
数组中的点的数目。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于常见的情况下映射到设备单位矩形从逻辑。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

函数将映射的每个点的坐标或大小，从设备坐标系统到 GDI 的逻辑坐标系统的维度。 转换取决于当前的映射模式和来源的设置和设备的窗口和视区的区。

点 x 和 y 坐标是-32,768 到 32,767 的范围中的 2 字节有符号的整数。 在映射模式会导致值大于这些限制的情况下，系统将值设置为-32,768 到 32,767，分别。

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

调用此函数可将逻辑单元转换成 HIMETRIC 为单位。

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向`SIZE`结构或`CSize`对象。

### <a name="remarks"></a>备注

使用此函数时，将从应用程序的自然映射模式转换给 OLE，显示 HIMETRIC 大小。 请注意，设备的窗口和视区的扩展盘区会影响结果。

转换是通过将第一个转换的逻辑单元使用的设备上下文的当前映射单位，然后将这些单位转换为 HIMETRIC 为单位的像素来完成。

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

此属性设备上下文`CDC`对象。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>备注

默认情况下，此设备上下文是否等于`m_hDC`。 一般情况下，`CDC`请求信息从设备上下文的 GDI 调用将定向到`m_hAttribDC`。 请参阅[CDC](../../mfc/reference/cdc-class.md)类上使用的详细信息的以下两个设备上下文的说明。

##  <a name="m_hdc"></a>  CDC::m_hDC

此输出设备上下文`CDC`对象。

```
HDC m_hDC;
```

### <a name="remarks"></a>备注

默认情况下`m_hDC`等同于`m_hAttribDC`，其他设备上下文由包装`CDC`。 一般情况下， `CDC` GDI 调用创建的输出，请转到`m_hDC`设备上下文。 您可以初始化`m_hDC`和`m_hAttribDC`以指向不同的设备。 请参阅[CDC](../../mfc/reference/cdc-class.md)类上使用的详细信息的以下两个设备上下文的说明。

##  <a name="maskblt"></a>  CDC::MaskBlt

将组合使用给定的掩码和光栅操作的源和目标位图的颜色数据。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*nWidth*<br/>
指定的宽度，以目标矩形和源位图的逻辑单元。

*nHeight*<br/>
指定以逻辑单位，目标矩形和源位图的高度。

*pSrcDC*<br/>
标识从其位图将被复制的设备上下文。 它必须为零*dwRop*参数指定的光栅操作中，不包括一个源。

*xSrc*<br/>
指定的源位图左上角的逻辑 x 坐标。

*ySrc*<br/>
指定的源位图左上角的逻辑 y 坐标。

*maskBitmap*<br/>
标识与源设备上下文中的颜色位图结合使用的单色掩码位图。

*xMask*<br/>
指定由指定的掩码位图的水平像素偏移量*maskBitmap*参数。

*yMask*<br/>
指定由指定的掩码位图的垂直像素偏移量*maskBitmap*参数。

*dwRop*<br/>
指定前景色和背景三元光栅操作代码，该函数用于控制数据源和目标数据的组合。 后台光栅操作代码存储在此值的高位字的高位字节前景色光栅操作代码存储在此值的高位字的低位字节此值的低位字将被忽略，并且应为零。 宏 MAKEROP4 创建此类组合的前景色和背景光栅操作代码。 请参阅前景色和背景的此函数的上下文中讨论的备注的部分。 请参阅`BitBlt`常见光栅操作代码的列表的成员函数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果值为 1 中由指定的掩码*maskBitmap*指示在指定前景色光栅操作代码*dwRop*应该应用于该位置。 值为 0 掩码中指示指定背景光栅操作代码*dwRop*应该应用于该位置。 光栅操作需要使用源代码，如果掩码矩形必须包含源矩形。 如果未显示，该函数将失败。 光栅操作不需要一个源，如果掩码矩形必须包含目标矩形。 如果未显示，该函数将失败。

如果旋转或倾斜转换有效的源设备上下文调用此函数时，将会出错。 但是，允许其他类型的转换。

如果不同的源、 模式和目标位图的颜色格式，此函数将转换模式或源格式或两个都与目标格式匹配。 如果掩码位图不是单色位图，就会出错。 当记录增强型图元文件时，出现错误 （和该函数返回 0） 如果源设备上下文标识增强型图元文件设备上下文。 并非所有设备都支持`MaskBlt`。 应用程序应调用`GetDeviceCaps`确定设备是否支持此函数。 如果未不提供任何掩码位图，则此函数的行为完全相同`BitBlt`，使用前景色光栅操作代码。 像素中的偏移量掩码位图映射到点 (0，0) 中的源设备上下文的位图。 这对于在其中掩码位图包含一系列屏蔽; 的情况下很有用应用程序可以轻松地应用其中任何一个掩码平面闪任务通过调整像素偏移量和矩形大小发送到`MaskBlt`。

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

更改为使用指定的模式的设备上下文的世界转换。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>参数

*rXform*<br/>
引用[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)结构用于修改给定的设备上下文的世界转换。

*iMode*<br/>
指定如何转换数据修改的当前世界转换。 此参数可以采用值的列表，请参阅[ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)。

### <a name="return-value"></a>返回值

成功时返回非零值。

在失败时返回 0。

若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

此方法会包装 Windows GDI 函数[ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)。

##  <a name="moveto"></a>  CDC::MoveTo

将当前的位置移动到指定的位*x*并*y* (或由*点*)。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定新位置的逻辑 x 坐标。

*y*<br/>
指定新位置的逻辑 y 坐标。

*点*<br/>
指定新位置。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

以前的位置作为 x 和 y 坐标`CPoint`对象。

### <a name="example"></a>示例

  有关示例，请参阅[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

按指定的偏移量移动设备上下文的剪辑区域。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要向左移动或向右的逻辑单元数。

*y*<br/>
指定要上移或下移的逻辑单元数。

*size*<br/>
指定的偏移量。

### <a name="return-value"></a>返回值

新区域的类型。 它可以是以下值之一：

- COMPLEXREGION 剪辑区域有重叠的边框。

- 错误的设备上下文不是有效的。

- NULLREGION 剪辑区域为空。

- SIMPLEREGION 剪辑区域的不重叠的边框。

### <a name="remarks"></a>备注

该函数将在区域*x*沿 x 轴单位并*y*沿 y 轴的单位。

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

修改视区原点相对于当前视区原点坐标的坐标。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*nWidth*<br/>
指定设备将添加到当前原点的 x 坐标的单位的数。

*nHeight*<br/>
指定设备将添加到当前原点的 y 坐标的单位的数。

### <a name="return-value"></a>返回值

（在设备区坐标中） 作为上一个视区原点`CPoint`对象。

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

修改窗口原点相对于当前窗口原点的坐标的坐标。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*nWidth*<br/>
指定要添加到当前原点的 x 坐标的逻辑单元数。

*nHeight*<br/>
指定要添加到当前原点的 y 坐标的逻辑单元数。

### <a name="return-value"></a>返回值

上一个窗口原点 （以逻辑坐标表示） 为`CPoint`对象。

##  <a name="operator_hdc"></a>  CDC::operator HDC

使用此运算符将检索的设备上下文句柄`CDC`对象。

```
operator HDC() const;
```

### <a name="return-value"></a>返回值

如果成功，设备上下文对象; 的句柄否则，为 NULL。

### <a name="remarks"></a>备注

句柄可用于直接调用 Windows Api。

##  <a name="paintrgn"></a>  CDC::PaintRgn

填充指定的区域*pRgn*使用当前的画笔。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要填充的区域。 给定区域的坐标指定逻辑单元中。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="patblt"></a>  CDC::PatBlt

在设备上创建一个位模式。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定将接收模式的矩形的左上角的逻辑 x 坐标。

*y*<br/>
指定将接收模式的矩形的左上角的逻辑 y 坐标。

*nWidth*<br/>
指定将接收模式的矩形的宽度 （以逻辑单位）。

*nHeight*<br/>
指定将接收模式的矩形的高度 （以逻辑单位）。

*dwRop*<br/>
指定的光栅操作代码。 光栅操作代码 (ROPs) 定义 GDI 如何合并涉及当前画笔、 可能的源位图和目标位图的输出操作中的颜色。 此参数可以是下列值之一：

- PATCOPY 副本模式与目标位图。

- 使用布尔 XOR 运算符的模式与 PATINVERT 合并目标位图。

- DSTINVERT 反转目标位图。

- BLACKNESS 打开黑色，所有输出。

- WHITENESS 打开空白，所有输出。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

模式是所选定的画笔和已在设备上的模式的组合。 指定的光栅操作代码*dwRop*定义模式的组合方式。 列出此函数的光栅操作是完整 256 的三元光栅操作代码; 的受限子网具体而言，不能使用引用的源的光栅操作代码。

并非所有的设备上下文支持`PatBlt`函数。 若要确定是否支持设备上下文`PatBlt`，调用`GetDeviceCaps`成员函数具有 RASTERCAPS 索引，并检查 RC_BITBLT 标志的返回值。

##  <a name="pie"></a>  CDC::Pie

通过绘制椭圆弧的行已加入其中心和两个终结点来绘制扇形楔形。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 x 坐标。

*y1*<br/>
指定 （以逻辑单位） 的边界矩形的左上角的 y 坐标。

*x2*<br/>
指定 （以逻辑单位） 的边框右下角的 x 坐标。

*y2*<br/>
指定 （以逻辑单位） 的边框右下角的 y 坐标。

*x3*<br/>
指定 （以逻辑单位） 的弧线的起始点的 x 坐标。 此时没有要将其完全置于圆弧。

*y3*<br/>
指定 （以逻辑单位） 的弧线的起始点的 y 坐标。 此时没有要将其完全置于圆弧。

*x4*<br/>
指定弧的终结点 （以逻辑单位） 的 x 坐标。 此时没有要将其完全置于圆弧。

*y4*<br/>
指定弧的终结点 （以逻辑单位） 的 y 坐标。 此时没有要将其完全置于圆弧。

*lpRect*<br/>
指定的边框。 您可以传递`CRect`对象或一个指向`RECT`结构为此参数。

*ptStart*<br/>
指定弧线的起始点。此时没有要将其完全置于圆弧。您可以传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

*ptEnd*<br/>
指定弧的终结点。此时没有要将其完全置于圆弧。您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

圆弧的中心是由指定的边界矩形的中心*x1*， *y1*， *x2*，以及*y2* (或由*lpRect*). 通过指定起点和终点的圆弧*x3*， *y3*， *x4*，以及*y4* (或由*ptStart*并*ptEnd*)。

以逆时针方向移动所选笔绘制弧线。 两个其他行到弧线的中心绘制从每个终结点。 使用当前画笔填充饼形区域。 如果*x3*等于*x4*并*y3*等于*y4*，结果是通过从该椭圆的中心点 (一行椭圆*x3*， *y3*) 或 ( *x4*， *y4*)。

此函数绘制图最多扩展，但不包括右侧和底部坐标。 这意味着图的高度*y2* - *y1*图的宽度为*x2* - *x1*。 宽度和边框的高度必须大于 2 个单位和小于 32,767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

设备上下文上播放指定图元文件的内容。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>参数

*hMF*<br/>
标识要播放的图元文件。

*hEnhMetaFile*<br/>
标识增强型图元文件。

*lpBounds*<br/>
指向`RECT`结构或`CRect`对象，其中包含用于显示图片的边界矩形的坐标。 使用逻辑单位来指定坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

图元文件可以播放任意次数。

第二个版本`PlayMetaFile`显示存储在给定的增强格式图元文件图片。 当应用程序调用的第二个版本`PlayMetaFile`，Windows 增强型图元文件标头中使用图片框将映射到由指向该矩形上的图片*lpBounds*参数。 (此图中可能会剪切或之前调用的输出设备中设置世界转换的旋转角度`PlayMetaFile`。)矩形的边缘点包含在该图片。 增强型图元文件图片还可以通过为输出设备中播放增强型图元文件前定义的剪辑区域进行剪裁。

增强型图元文件包含可选的调色板，如果应用程序可以通过调用的第二个版本之前设置输出设备上的颜色调色板实现一致的颜色`PlayMetaFile`。 若要检索的可选调色板，请使用`GetEnhMetaFilePaletteEntries`Windows 函数。 通过调用的第二个版本，可以在新创建的增强型图元文件中嵌入增强型图元文件`PlayMetaFile`和设备上下文中的源增强型图元文件播放的新增强型图元文件。

输出设备上下文的状态将保留此函数。 此函数将删除任何对象创建，但不是在增强型图元文件中删除。 若要停止此函数，应用程序可以调用`CancelDC`Windows 函数从另一个线程终止操作。 在这种情况下，该函数返回零。

##  <a name="plgblt"></a>  CDC::PlgBlt

通过在源设备上下文将指定矩形执行颜色数据的位的位块传输到给定的设备上下文中指定的平行四边形。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
指向标识目标平行四边形的三个角的逻辑空间中的三个点的数组。 源矩形左上角映射到此数组，此数组中的第二个点的右上角和到第三个点的左下角中的第一个点。 源矩形的右下角将映射到的平行四边形中的隐式第四个点。

*pSrcDC*<br/>
标识源设备上下文。

*xSrc*<br/>
指定以逻辑单位，源矩形左上角的 x 坐标。

*ySrc*<br/>
指定以逻辑单位，源矩形左上角的 y 轴坐标。

*nWidth*<br/>
指定的宽度，以逻辑单元，源矩形。

*nHeight*<br/>
指定以逻辑单位，源矩形的高度。

*maskBitmap*<br/>
标识用于屏蔽源矩形的颜色的可选单色位图。

*xMask*<br/>
指定单色位图左上角的 x 坐标。

*yMask*<br/>
指定单色位图左上角的 y 坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果给定的位掩码句柄标识有效的单色位图，该函数将使用此位图来掩码中的源矩形的颜色数据的位。

平行四边形 (D) 的第四个顶点定义方法是将前三个点 （A、 B 和 C） 向量，并计算 D = B + C-a。

如果存在位掩码，值为 1 掩码中指示源像素颜色应复制到目标。 掩码中的 0 值指示目标像素颜色将不进行更改。

如果掩码矩形小于源和目标矩形，该函数将复制的掩码模式。

在源设备上下文; 允许缩放、 平移和反射转换但是，旋转和切变转换不是。 如果掩码位图不是单色位图，就会出错。 目标设备上下文的拉伸模式用于确定如何拉伸或压缩像素，如果这是必需的。 当记录增强型图元文件时，如果源设备上下文标识增强型图元文件设备上下文，就会出错。

目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。 如果源转换具有旋转或倾斜，则返回错误。 如果目标和源矩形不具有相同的颜色格式，`PlgBlt`将转换源矩形以匹配目标矩形。 并非所有设备都支持`PlgBlt`。 有关详细信息，请参阅中的 RC_BITBLT 光栅功能的说明`CDC::GetDeviceCaps`成员函数。

如果源和目标设备上下文表示不兼容的设备，`PlgBlt`返回错误。

##  <a name="polybezier"></a>  CDC::PolyBezier

绘制一个或多个 Bzier 样条。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)包含终结点和控制点 spline(s) 的数据结构。

*nCount*<br/>
指定的中点数目*lpPoints*数组。 此值必须是一个三倍以上的要绘制的样条数，因为每个 Bzier 自由绘制曲线需要两个控点和终结点，以及初始自由绘制曲线需要额外的起始点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数使用的终结点和指定的控制点绘制三次方 Bzier 自由绘制曲线*lpPoints*参数。 第一个自由绘制曲线绘制从第一个点到第四个点作为管理点使用的第二个和第三个点。 序列中的每个后续自由绘制曲线需要完全三个点： 以前的自由绘制曲线终结点用作起始点、 序列中的接下来两个点是控点和第三个是终结点。

当前的位置，既不使用也不由更新`PolyBezier`函数。 该图不填充。 此函数使用当前笔绘制线条。

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

绘制一个或多个 Bzier 样条。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)点包含终结点和控件的数据结构。

*nCount*<br/>
指定的中点数目*lpPoints*数组。 此值必须是三次样条要绘制的数字，因为每个 Bzier 自由绘制曲线需要两个控点和终结点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数使用指定的控制点绘制三次方 Bzier 自由绘制曲线*lpPoints*参数。 第一个自由绘制曲线绘制从当前位置到第三个点作为管理点使用的前两个点。 为每个后续的样条，该函数需要正好三个点，并使用以前的自由绘制曲线终结点的起始点作为下一步。 `PolyBezierTo` 将当前位置移动到最后一个 Bzier 自由绘制曲线的结束点。 该图不填充。 此函数使用当前笔绘制线条。

### <a name="example"></a>示例

  有关示例，请参阅[cdc:: beginpath](#beginpath)。

##  <a name="polydraw"></a>  CDC::PolyDraw

绘制一系列直线段和 Bzier 样条。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)为每个包含的终结点的数据结构行段和终结点和控制每个 Bzier 自由绘制曲线的点。

*lpTypes*<br/>
一个数组，指定每个中的点到点*lpPoints*使用数组。 值可以是以下值之一：

- PT_MOVETO 指定此点启动非连续图。 此点将成为新的当前位置。

- PT_LINETO 指定一条线是绘制从当前位置到目前为止，随后将成为新的当前位置。

- PT_BEZIERTO 指定此点的控点或结束点 Bzier 样条。

PT_BEZIERTO 类型始终发生在的三个组中。 当前的位置定义 Bzier 自由绘制曲线的起始点。 前两个 PT_BEZIERTO 点的控点，而第三个 PT_BEZIERTO 点是结束点。 结束点将成为新的当前位置。 如果有不连续 PT_BEZIERTO 三点，会发生错误。

   PT_LINETO 或 PT_BEZIERTO 类型可以通过使用按位运算符结合使用以下常量或以指示相应点图，图中的最后一个点已关闭：

- PT_CLOSEFIGURE 指定图 PT_LINETO 后自动关闭或完成 PT_BEZIERTO 此点的类型。 到最新 PT_MOVETO 从此点绘制线条或`MoveTo`点。

   与行的 PT_LINETO 类型或结束点 Bzier 样条，通过使用按位 PT_BEZIERTO 类型结合使用此标志**OR**运算符。 当前的位置设置为的结束行的结束点。

*nCount*<br/>
指定的中点总数*lpPoints*数组中的字节数相同*lpTypes*数组。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数可用于绘制代替连续调用到非连续数字`CDC::MoveTo`， `CDC::LineTo`，和`CDC::PolyBezierTo`成员函数。 使用当前笔绘制直线和样条和图未被填充。 如果没有活动路径启动通过调用`CDC::BeginPath`成员函数`PolyDraw`将添加到路径。 中包含的点*lpPoints*数组并在*lpTypes*指示每个点是否属于`CDC::MoveTo`、 一个`CDC::LineTo`，或`CDC::BezierTo`操作。 还有可能要关闭图。 此函数会更新当前的位置。

### <a name="example"></a>示例

  有关示例，请参阅[cdc:: beginpath](#beginpath)。

##  <a name="polygon"></a>  CDC::Polygon

绘制多边形包含两个或多个连接的点 （顶点） 的行，使用当前笔。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向指定的多边形的顶点的点的数组。 数组中的每个点都`POINT`结构或`CPoint`对象。

*nCount*<br/>
指定数组中的顶点数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

系统多边形会自动关闭，如有必要，通过绘制一条从最后一个顶点与第一个。

可以检索或设置通过使用当前的多边形填充模式`GetPolyFillMode`和`SetPolyFillMode`成员函数。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

绘制一组连接指定的点的直线线段*lpPoints*。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组`POINT`结构或`CPoint`要连接的对象。

*nCount*<br/>
指定数组中的点数。 此值必须至少为 2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

从通过使用当前笔的后续点的第一个点绘制线条。 与不同`LineTo`成员函数`Polyline`函数既不使用也不更新当前的位置。

有关详细信息，请参阅[折线](/windows/desktop/api/wingdi/nf-wingdi-polyline)Windows SDK 中。

##  <a name="polylineto"></a>  CDC::PolylineTo

绘制一个或多个直线。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组[点](/windows/desktop/api/windef/ns-windef-tagpoint)包含行的顶点的数据结构。

*nCount*<br/>
指定数组中的点数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

行从当前位置到由指定的第一个点绘制*lpPoints*参数使用当前笔。 为每个其他行，则该函数绘制从上一个行的结束点到由指定的下一步点*lpPoints*。 `PolylineTo` 将当前位置移到最后一行的结束点。 如果此函数绘制的直线线段形成闭合的图形，图中未填充。

##  <a name="polypolygon"></a>  CDC::PolyPolygon

创建两个或多个使用当前的多边形填充模式填充的多边形。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向数组`POINT`结构或`CPoint`定义多边形顶点的对象。

*lpPolyCounts*<br/>
指向整数的数组，其中每个中的多边形之一中指定的点数*lpPoints*数组。

*nCount*<br/>
中的条目数*lpPolyCounts*数组。 此数字指定要绘制的多边形的数量。 此值必须至少为 2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

多边形可能是不连续或重叠。

在调用中指定每个多边形`PolyPolygon`函数，必须关闭。 与多边形创建的不同`Polygon`成员函数，创建的多边形`PolyPolygon`不会自动关闭。

该函数将创建两个或多个多边形。 若要创建单个多边形，应用程序应使用`Polygon`成员函数。

可以检索或设置通过使用当前的多边形填充模式`GetPolyFillMode`和`SetPolyFillMode`成员函数。

##  <a name="polypolyline"></a>  CDC::PolyPolyline

绘制多个相连的线段序列。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向包含折线的顶点的结构的数组。 连续指定折线。

*lpPolyPoints*<br/>
指向数组的变量指定的中点的数量*lpPoints*数组中相应的多边形。 每个条目必须大于或等于 2。

*nCount*<br/>
指定的总数中的计数*lpPolyPoints*数组。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

通过使用当前笔绘制的直线线段。 按细分格式正确的图表数据未被填充。 当前的位置都不使用也不更新此函数。

##  <a name="ptvisible"></a>  CDC::PtVisible

确定给定的点是否在设备上下文的剪辑区域内。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>参数

*x*<br/>
指定点的逻辑 x 坐标。

*y*<br/>
指定点的逻辑 y 坐标。

*点*<br/>
指定要检查以逻辑坐标表示的点。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

如果指定的点内的剪辑区域; 为非零值否则为 0。

##  <a name="queryabort"></a>  CDC::QueryAbort

调用中止函数的情况下安装[SetAbortProc](#setabortproc)是否应终止打印成员函数用于打印应用程序和查询。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>返回值

如果应继续打印或没有中止过程，返回值为非零值。 如果应终止打印作业，则为 0。 中止函数提供返回值。

##  <a name="realizepalette"></a>  CDC::RealizePalette

将映射到系统调色板条目从当前逻辑调色板。

```
UINT RealizePalette();
```

### <a name="return-value"></a>返回值

指示在逻辑调色板中的多个条目已映射到系统调色板中的不同项。 这表示此函数将重新映射，以适应系统调色板中的更改，因为上一次实现逻辑调色板的条目数。

### <a name="remarks"></a>备注

逻辑调色板可以充当缓冲区之间颜色密集型应用程序和系统，使应用程序可使用多按需而不会影响其自己的颜色显示颜色或与其他窗口的显示颜色。

当窗口具有输入的焦点和调用`RealizePalette`，Windows 可确保该窗口将显示所有请求的颜色，最大数量的屏幕上同时可用。 Windows 还会显示在窗口的调色板中未找到通过将它们与可用颜色匹配的颜色。

此外，Windows 请求以尽可能接近的可用颜色紧密地调用该函数的非活动窗口的颜色相匹配。 这将显著减少不必要的更改，在非活动窗口中显示的颜色。

##  <a name="rectangle"></a>  CDC::Rectangle

绘制一个矩形使用当前笔。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定 （以逻辑单位） 的矩形的左上角的 x 坐标。

*y1*<br/>
指定 （以逻辑单位） 的矩形的左上角的 y 坐标。

*x2*<br/>
指定 （以逻辑单位） 的矩形的右下角的 x 坐标。

*y2*<br/>
指定 （以逻辑单位） 的矩形的右下角的 y 坐标。

*lpRect*<br/>
逻辑单元中指定的矩形。 您可以传递`CRect`对象或一个指向`RECT`结构为此参数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前画笔填充的矩形的内部。

该矩形最多个扩展，但不包括右侧和底部坐标。 这意味着是矩形的高度*y2* - *y1*矩形的宽度为*x2* - *x1*. 宽度和一个矩形的高度必须大于 2 个单位和小于 32,767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

确定是否显示上下文的剪辑区域内位于给定任何的矩形部分。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向`RECT`结构或`CRect`对象，其中包含指定矩形的逻辑坐标。

### <a name="return-value"></a>返回值

如果给定任何的矩形部分中的剪辑区域; 非零值否则为 0。

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

调用此成员函数可设置`m_hAttribDC`为 NULL。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>备注

这不会导致`Detach`发生。 仅输出设备上下文附加到`CDC`对象，并且它仅可以分离。

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

调用此成员函数可设置`m_hDC`为 NULL 的成员。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>备注

不能调用此成员函数，当输出设备上下文附加到`CDC`对象。 使用`Detach`成员函数可分离输出设备上下文。

##  <a name="resetdc"></a>  CDC::ResetDC

调用此成员函数以更新设备上下文由包装`CDC`对象。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>参数

*lpDevMode*<br/>
指向 Windows`DEVMODE`结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

从指定在 Windows 中的信息更新的设备上下文`DEVMODE`结构。 此成员函数仅重置属性的设备上下文。

应用程序通常会使用`ResetDC`成员函数，当一个窗口处理`WM_DEVMODECHANGE`消息。 此成员函数还可用于打印文档时更改纸张方向或纸张箱。

此成员函数不能用于更改驱动程序名称、 设备名称，或输出端口。 当用户更改设备名称的端口连接时，必须删除原始的设备上下文，并使用新的信息创建新的设备上下文。

在调用此成员函数之前，必须确保已选的设备上下文中的所有对象 （而不是常用对象） 具有出所都选。

##  <a name="restoredc"></a>  CDC::RestoreDC

还原到以前的状态由标识设备上下文*nSavedDC*。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>参数

*nSavedDC*<br/>
指定要还原的设备上下文。 它可以是先前返回的值`SaveDC`函数调用。 如果*nSavedDC*为-1，最新保存设备上下文将得以还原。

### <a name="return-value"></a>返回值

如果指定的上下文还原; 非零值否则为 0。

### <a name="remarks"></a>备注

`RestoreDC` 将设备上下文的弹出堆栈创建的早期调用的状态信息还原`SaveDC`成员函数。

堆栈可以包含多个设备上下文的状态信息。 如果指定的上下文*nSavedDC*不是位于堆栈顶部`RestoreDC`删除指定的设备上下文之间的所有状态信息*nSavedDC*和堆栈的顶部。 已删除的信息将丢失。

##  <a name="roundrect"></a>  CDC::RoundRect

带有圆使用当前笔绘制矩形。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定 （以逻辑单位） 的矩形的左上角的 x 坐标。

*y1*<br/>
指定 （以逻辑单位） 的矩形的左上角的 y 坐标。

*x2*<br/>
指定 （以逻辑单位） 的矩形的右下角的 x 坐标。

*y2*<br/>
指定 （以逻辑单位） 的矩形的右下角的 y 坐标。

*x3*<br/>
指定用于绘制圆角的半径 （以逻辑单位） 的椭圆宽度。

*y3*<br/>
指定用于绘制圆角的半径 （以逻辑单位） 的椭圆的高度。

*lpRect*<br/>
逻辑单元中指定的边框。 您可以传递`CRect`对象或一个指向`RECT`结构为此参数。

*点*<br/>
X 坐标*点*指定的宽度 （以逻辑单位） 绘制圆的角的椭圆。 Y 坐标*点*指定要绘制圆角的半径 （以逻辑单位） 的椭圆的高度。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前画笔填充的矩形的内部。

此函数绘制的图最多扩展，但不包括右侧和底部坐标。 这意味着图的高度*y2* - *y1*图的宽度为*x2* - *x1*。 必须大于 2 个单位和小于 32,767 个单位的高度和宽度的边框。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

将通过复制状态信息 （如剪辑区域、 所选的对象和映射模式） 的设备上下文的当前状态保存到上下文堆栈由 Windows 维护中。

```
virtual int SaveDC();
```

### <a name="return-value"></a>返回值

一个整数，它标识的已保存的设备上下文。 如果发生错误，则为 0。 此返回值可以用于通过调用还原设备上下文`RestoreDC`。

### <a name="remarks"></a>备注

通过使用更高版本可以还原已保存的设备上下文`RestoreDC`。

`SaveDC` 可以是任意次数用于保存任意数量的设备上下文状态。

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

修改相对于当前值的视区扩展盘区。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>参数

*xNum*<br/>
指定用来乘当前 x 盘区。

*xDenom*<br/>
指定要除以的值相乘当前 x 盘区的结果数量*xNum*参数。

*yNum*<br/>
指定用来乘当前 y 程度。

*yDenom*<br/>
指定要除以的值相乘 y 当前范围的结果数量*yNum*参数。

### <a name="return-value"></a>返回值

上一个视区范围 （以设备为单位） 为`CSize`对象。

### <a name="remarks"></a>备注

公式编写，如下所示：

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

新的视区范围的计算方法的当前扩展盘区乘以给定分子，然后除以给定分母。

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

修改窗口范围相对于当前值。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>参数

*xNum*<br/>
指定用来乘当前 x 盘区。

*xDenom*<br/>
指定要除以的值相乘当前 x 盘区的结果数量*xNum*参数。

*yNum*<br/>
指定用来乘当前 y 程度。

*yDenom*<br/>
指定要除以的值相乘 y 当前范围的结果数量*yNum*参数。

### <a name="return-value"></a>返回值

上一个窗口中的范围 （逻辑单位） 为`CSize`对象。

### <a name="remarks"></a>备注

公式编写，如下所示：

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新的窗口范围的计算方法的当前扩展盘区乘以给定分子，然后除以给定分母。

##  <a name="scrolldc"></a>  CDC::ScrollDC

水平和垂直滚动的位的矩形。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>参数

*dx*<br/>
指定水平滚动单元数。

*dy*<br/>
指定垂直滚动单元数。

*lpRectScroll*<br/>
指向`RECT`结构或`CRect`对象，它包含滚动矩形的坐标。

*lpRectClip*<br/>
指向`RECT`结构或`CRect`对象，其中包含的剪辑矩形的坐标。 当此矩形小于一个指向的原始*lpRectScroll*，仅在较小的矩形中滚动发生。

*pRgnUpdate*<br/>
标识滚动进程由发现的区域。 `ScrollDC`函数用于定义此区域; 它不一定是一个矩形。

*lpRectUpdate*<br/>
指向`RECT`结构或`CRect`对象，它接收的限定滚动更新区域的矩形的坐标。 这是需要重新绘制的最大矩形区域。 中的结构或对象时该函数将返回值是在工作区坐标，而不考虑给定的设备上下文映射模式。

### <a name="return-value"></a>返回值

如果执行滚动; 非零值否则为 0。

### <a name="remarks"></a>备注

如果*lpRectUpdate*为 NULL，Windows 不会计算更新矩形。 如果这两个*pRgnUpdate*并*lpRectUpdate*为 NULL 时，Windows 不会计算更新区域。 如果*pRgnUpdate*不为 NULL，Windows 假定它包含滚动进程由发现的区域的有效指针 (由定义`ScrollDC`成员函数)。 更新区域中返回*lpRectUpdate*可以传递给`CWnd::InvalidateRgn`必要。

应用程序应使用`ScrollWindow`类的成员函数`CWnd`必要滚动窗口的整个客户端区域时。 否则，它应使用`ScrollDC`。

##  <a name="selectclippath"></a>  CDC::SelectClipPath

选择作为设备上下文中，使用指定的模式来组合在新区域中使用任何现有的剪辑区域的剪辑区域的当前路径。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>参数

*nMode*<br/>
指定要使用的路径的方式。 允许使用以下值：

- RGN_AND 新剪辑区域包括 （重叠区域） 为当前剪辑区域与当前路径的交集。

- RGN_COPY 新剪辑区域是当前路径。

- RGN_DIFF 新剪辑区域包括当前剪辑区域的区域和那些当前路径中排除。

- RGN_OR 新剪辑区域包括 （合并面积） 为当前剪辑区域与当前路径的并集。

- RGN_XOR 新剪辑区域包括联合为当前剪辑区域与当前路径，但并没有重叠区域。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

标识的设备上下文必须包含封闭的路径。

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

选择给定的区域作为设备上下文的当前剪辑区域。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要选择的区域。

- 此函数中，如果此值为 NULL，则选择整个工作区并输出仍剪辑到窗口的第一个版本。

- 有关此函数的第二个版本，此句柄仅在指定 RGN_COPY 模式时可以为 NULL。

*nMode*<br/>
指定要执行的操作。 它必须是以下值之一：

- RGN_AND 结合了新的剪辑区域的当前剪辑区域和区域由标识的重叠区域*pRgn*。

- RGN_COPY 新剪辑区域是由标识的区域的副本*pRgn*。 这是功能等同的第一个版本于`SelectClipRgn`。 如果该区域由标识*pRgn*为 NULL，新的剪辑区域变得默认剪辑区域 （null 区域）。

- RGN_DIFF 结合了新的剪辑区域与从由标识区域中排除这些区域当前剪辑区域的区域*pRgn*。

- RGN_OR 新剪辑区域组合的当前剪辑区域和区域由标识*pRgn*。

- RGN_XOR 新剪辑区域组合的当前剪辑区域和区域由标识*pRgn*但不包括任何重叠区域。

### <a name="return-value"></a>返回值

区域的类型。 它可以是以下值之一：

- COMPLEXREGION 新剪辑区域有重叠的边框。

- 错误的设备上下文或区域不是有效的。

- NULLREGION 新剪辑区域为空。

- SIMPLEREGION 新剪辑区域具有不重叠的边框。

### <a name="remarks"></a>备注

使用仅所选区域的副本。 区域本身可以为任意数量的其他设备上下文中，选择或删除它。

该函数假定给定区域的坐标以设备为单位指定。 某些打印机设备支持的文本输出以高分辨率比图形输出以保留 express 文本规格所需的精度。 这些设备报告更高分辨率设备单位，即文本单位。 这些设备然后缩放图形的坐标，以便多个报告设备单元映射到只有 1 图形单元。 应始终调用`SelectClipRgn`函数使用文本单位。

必须执行图形中的对象的 GDI 缩放的应用程序可以使用 GETSCALINGFACTOR 打印机转义以确定缩放系数。 这个缩放比例影响剪辑。 如果一个区域用于剪辑图形，GDI 将坐标除以比例因子。 如果该区域用于剪切文本，GDI 会做任何缩放调整。 扩展因子为 1 会导致要除以 2; 的坐标扩展因子为 2 会导致坐标除以 4;等等。

##  <a name="selectobject"></a>  CDC::SelectObject

选择在设备上下文对象。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>参数

*pPen*<br/>
一个指向[CPen](../../mfc/reference/cpen-class.md)要选择的对象。

*pBrush*<br/>
一个指向[CBrush](../../mfc/reference/cbrush-class.md)要选择的对象。

*pFont*<br/>
一个指向[CFont](../../mfc/reference/cfont-class.md)要选择的对象。

*pBitmap*<br/>
一个指向[CBitmap](../../mfc/reference/cbitmap-class.md)要选择的对象。

*pRgn*<br/>
一个指向[CRgn](../../mfc/reference/crgn-class.md)要选择的对象。

*pObject*<br/>
一个指向[CGdiObject](../../mfc/reference/cgdiobject-class.md)要选择的对象。

### <a name="return-value"></a>返回值

指向要替换的对象的指针。 这是指向派生自的类之一的对象的指针`CGdiObject`，如`CPen`，取决于使用哪一版本的函数。 如果出现错误，则返回值为 NULL。 此函数可返回到临时对象的指针。 此临时对象在一个 Windows 消息的处理过程才有效。 有关详细信息，请参阅 `CGdiObject::FromHandle` 。

使用区域参数的成员函数的版本执行相同的任务`SelectClipRgn`成员函数。 它的返回值可以是以下任一项：

- COMPLEXREGION 新剪辑区域有重叠的边框。

- 错误的设备上下文或区域不是有效的。

- NULLREGION 新剪辑区域为空。

- SIMPLEREGION 新剪辑区域具有不重叠的边框。

### <a name="remarks"></a>备注

类`CDC`提供了五个版本专用于特定种类的 GDI 对象，包括钢笔、 画笔、 字体、 位图和区域。 新选定的对象替换上一个相同类型的对象。 例如，如果*pObject*的通用版本`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)对象，该函数使用指定的笔替换当前笔*pObject*.

应用程序可以选择一个位图到内存设备上下文仅和到只有一个内存设备上下文中一次。 位图的格式必须是单色或兼容的设备上下文中;如果不是，`SelectObject`返回错误。

对于 Windows 3.1 和更高版本，`SelectObject`函数是否使用图元文件中或不返回相同的值。 在以前版本的 Windows，`SelectObject`在图元文件中使用它时返回非零值表示成功，0 表示失败。

##  <a name="selectpalette"></a>  CDC::SelectPalette

选择指定的逻辑调色板*pPalette*作为设备上下文的所选的面板对象。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>参数

*pPalette*<br/>
标识要选择的逻辑调色板。 此调色板必须具有已创建了具有`CPalette`成员函数[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)。

*bForceBackground*<br/>
指定是否强制逻辑调色板是背景调色板。 如果*bForceBackground*为非零值，为所选的面板始终背景调色板，而不考虑窗口是否具有输入的焦点。 如果*bForceBackground*为 0 和设备上下文附加到窗口，窗口具有输入的焦点时，逻辑调色板将为前台调色板。

### <a name="return-value"></a>返回值

一个指向`CPalette`对象标识替换为指定的调色板的逻辑调色板*pPalette*。 如果出现错误，则为 NULL。

### <a name="remarks"></a>备注

新的调色板将成为用于通过 GDI 显示设备上下文中的控件颜色的调色板对象，并替换以前的调色板。

应用程序可以选择多个设备上下文的逻辑调色板。 但是，对逻辑调色板的更改会影响为其选择的所有设备上下文。 如果应用程序到多个设备上下文选择调色板，设备上下文必须全部属于同一个物理设备。

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

选择[CGdiObject](../../mfc/reference/cgdiobject-class.md)对应于预定义的股票钢笔、 画笔或字体之一的对象。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>参数

*nIndex*<br/>
指定所需的常用对象的类型。 它可以是下列值之一：

- BLACK_BRUSH 黑色画笔。

- DKGRAY_BRUSH 暗灰色的画笔。

- GRAY_BRUSH 灰色画笔。

- 空心 HOLLOW_BRUSH 画笔。

- LTGRAY_BRUSH 浅灰色画笔。

- NULL_BRUSH Null 画笔。

- WHITE_BRUSH 白色画笔。

- BLACK_PEN 黑色笔。

- NULL_PEN Null 笔。

- WHITE_PEN 白色笔。

- ANSI_FIXED_FONT ANSI 修复系统字体。

- ANSI_VAR_FONT ANSI 变量系统字体。

- DEVICE_DEFAULT_FONT 依赖于设备的字体。

- 依赖于 OEM_FIXED_FONT OEM 的固定字体。

- SYSTEM_FONT 系统字体。 默认情况下，Windows 使用系统字体绘制菜单、 对话框控件和其他文本。 它是最佳的但是，不依赖于 SYSTEM_FONT 获取使用对话框和窗口的字体。 请改用`SystemParametersInfo`与要检索当前字体的 SPI_GETNONCLIENTMETRICS 参数的函数。 `SystemParametersInfo` 考虑到当前主题，并提供隐藏式字幕、 菜单和消息对话框的字体信息。

- SYSTEM_FIXED_FONT Windows 中使用之前的版本 3.0 的固定宽度系统字体。 此对象是可用于与早期版本的 Windows 兼容性。

- DEFAULT_PALETTE 默认调色板。 此调色板包含系统调色板中的 20 静态颜色。

### <a name="return-value"></a>返回值

一个指向`CGdiObject`如果函数运行成功被替换的对象。 指向实际对象是[CPen](../../mfc/reference/cpen-class.md)， [CBrush](../../mfc/reference/cbrush-class.md)，或[CFont](../../mfc/reference/cfont-class.md)对象。 如果调用失败，返回值为 NULL。

##  <a name="setabortproc"></a>  CDC::SetAbortProc

安装打印作业的中止过程。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>参数

*lpfn*<br/>
指向要中止过程作为安装的中止函数的指针。 有关回调函数的详细信息，请参阅[回调函数的 cdc:: setabortproc](callback-functions-used-by-mfc.md#setabortproc)。

### <a name="return-value"></a>返回值

指定结果的`SetAbortProc`函数。 以下值的一些比其他，更有可能发生，但所有都是可行。

- SP_ERROR 常规错误。

- SP_OUTOFDISK 不足够的磁盘空间是目前适用于后台处理，并没有更多的空间将变为可用。

- SP_OUTOFMEMORY 不足够的内存是适用于后台处理。

- SP_USERABORT 用户结束通过打印管理器作业。

### <a name="remarks"></a>备注

如果应用程序，以允许在后台处理过程中取消打印作业打印作业开始使用之前，它必须设置中止函数[StartDoc](#startdoc)成员函数。 打印管理器在后台处理，以允许应用程序来取消打印作业，或处理的磁盘空间不足条件调用中止函数。 如果设置中止函数，打印作业将失败，如果没有足够的磁盘空间用于后台打印。

请注意，Microsoft Visual c + + 的功能简化传递给回调函数的创建`SetAbortProc`。 地址传递给`EnumObjects`成员函数是指向与导出的函数的指针`__declspec(dllexport)`且`__stdcall`调用约定。

也不需要导出中的函数名称**导出**应用程序的模块定义文件中的语句。 你可以改用**导出**函数修饰符，如

**BOOL 回调导出**AFunction ( **HDC**， `int` **);**

若要使编译器将发出导出的正确导出记录，方法是不带别名名称。 这适用于大多数需求。 对于某些特殊情况下，例如导出函数的序号比较还是别名导出，你仍需要使用**导出**模块定义文件中的语句。

回调注册接口现在是类型安全 （必须传递一个指向正确类型的特定的回调函数的函数指针）。

另请注意，所有的回调函数必须返回到 Windows，因为不能跨回调边界引发异常之前捕获 Microsoft Foundation 异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

设置要用于弧线和矩形函数的绘制方向。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>参数

*nArcDirection*<br/>
指定新的反方向。 此参数可以是以下值：

- AD_COUNTERCLOCKWISE 逆时针绘制图形。

- AD_CLOCKWISE 沿顺时针方向绘制图形。

### <a name="return-value"></a>返回值

如果成功，则，指定旧的反方向，否则为 0。

### <a name="remarks"></a>备注

默认方向是开始沿逆时针方向。 `SetArcDirection`函数指定在其中以下函数绘图的方向：

|Arc|饼图|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

调用此函数可设置属性的设备上下文， `m_hAttribDC`。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

此成员函数不会附加到的设备上下文`CDC`对象。 仅输出设备上下文附加到`CDC`对象。

##  <a name="setbkcolor"></a>  CDC::SetBkColor

将当前的背景色设置为指定的颜色。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新背景色。

### <a name="return-value"></a>返回值

以前的背景色为 RGB 颜色值。 如果出错，则返回值将为 0x80000000。

### <a name="remarks"></a>备注

如果后台模式下是不透明，系统将使用的背景色来填充带样式的行中的间隙中字符单元格, 的背景画笔中的阴影的线之间的间隔。 将位图颜色和单色设备上下文之间转换时，系统还使用背景色。

如果设备无法显示指定的颜色，因此系统将设置为最接近的物理颜色的背景色。

##  <a name="setbkmode"></a>  CDC::SetBkMode

设置背景模式。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>参数

*nBkMode*<br/>
指定要设置的模式。 此参数可以是以下值：

- 与之前的文本阴影画笔的当前背景色填充不透明背景或笔绘制。 这是默认背景模式。

- 在绘制之前未更改透明背景。

### <a name="return-value"></a>返回值

先前的后台模式。

### <a name="remarks"></a>备注

后台模式下定义系统是否删除现有的背景色绘图图面上绘制文本、 阴影的画笔或笔样式，不是一条实线之前。

### <a name="example"></a>示例

  有关示例，请参阅[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

控制累积的边界矩形指定的设备上下文的信息。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>参数

*lpRectBounds*<br/>
指向`RECT`结构或`CRect`对象用于设置的边框。 矩形尺寸的单位以逻辑坐标表示。 此参数可以为 NULL。

*flags*<br/>
指定新矩形的累计矩形与组合的方式。 此参数可以是以下值的组合：

- DCB_ACCUMULATE 添加指定的矩形*lpRectBounds*到边框 （使用矩形联合操作）。

- DCB_DISABLE 关闭边界累积。

- DCB_ENABLE 打开边界累积。 （边界累积的默认设置被禁用）。

### <a name="return-value"></a>返回值

如果函数运行成功的边界矩形的当前状态。 像*标志*，则返回值可以是一系列**DCB_** 值：

- DCB_ACCUMULATE 边界矩形不为空。 始终将此值。

- DCB_DISABLE 边界累积处于关闭状态。

- 上有 DCB_ENABLE 边界累积。

### <a name="remarks"></a>备注

Windows 可以维护所有绘制操作的绑定矩形。 可以查询此矩形，并将其重置应用程序。 绘制边界可用于使位图缓存失效。

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

指定 GDI 会将分配给应用程序选择设备上下文中的下一步画笔的来源。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定的 x 坐标 （以设备为单位） 的新的源。 此值必须在范围 0 到 7。

*y*<br/>
指定的 y 坐标 （以设备为单位） 的新的源。 此值必须在范围 0 到 7。

*点*<br/>
指定新的原点 x 和 y 坐标。 每个值必须在范围 0 到 7。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

以前以设备为单位的画笔的原点。

### <a name="remarks"></a>备注

默认值的画笔源坐标为 （0，0）。 若要更改一个画笔的原点，调用`UnrealizeObject`函数`CBrush`对象，请调用`SetBrushOrg`，然后调用`SelectObject`成员函数以选择在设备上下文画笔。

不要使用`SetBrushOrg`与库存`CBrush`对象。

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

设置使用指定的值的设备上下文的颜色调整值。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>参数

*lpColorAdjust*<br/>
指向[COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)数据结构，它包含的颜色调整值。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

颜色调整值用于调整输入对的调用的源位图的颜色`CDC::StretchBlt`成员函数时半色调模式设置。

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

将当前的设备上下文 (DC) 画笔颜色设置为指定的颜色值。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新的画笔颜色。

### <a name="return-value"></a>返回值

如果函数成功，返回的值指定 COLORREF 值形式的上一个 DC 画笔颜色。

如果函数失败，返回值将为 CLR_INVALID。

### <a name="remarks"></a>备注

此方法来模拟函数的功能[SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor)，如 Windows SDK 中所述。

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

将当前的设备上下文 (DC) 钢笔颜色设置为指定的颜色值。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新的钢笔颜色。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor)，如 Windows SDK 中所述。

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

设置指定的设备上下文的图形模式。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>参数

*iMode*<br/>
指定的图形模式。 此参数可以采用值的列表，请参阅[SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)。

### <a name="return-value"></a>返回值

成功后返回旧图形模式。

在失败时返回 0。 若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

此方法会包装 Windows GDI 函数[SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)。

##  <a name="setlayout"></a>  CDC::SetLayout

调用此成员函数以将文本和图形的设备上下文的布局更改为保留，如阿拉伯语和希伯来语区域性的标准布局的权利。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>参数

*dwLayout*<br/>
设备上下文布局和位图控制标志。 它可以是以下值的组合。

|值|含义|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|禁用对调用任何反射[cdc:: bitblt](#bitblt)并[CDC::StretchBlt](#stretchblt)。|
|LAYOUT_RTL|设置默认水平布局为从右向左。|
|LAYOUT_LTR|设置默认布局，以从左到右。|

### <a name="return-value"></a>返回值

如果成功，设备上下文的上一个布局。

如果不成功，GDI_ERROR。 若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

通常情况下，不会调用`SetLayout`窗口。 相反，您通过设置控制在窗口中的从右到左布局[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)WS_EX_RTLREADING 等。 设备上下文，如打印机或图元文件，不会继承此布局。 从右到左布局是调用设置的设备上下文的唯一办法`SetLayout`。

如果您调用**SetLayout (LAYOUT_RTL** )，`SetLayout`自动更改为 MM_ISOTROPIC 的映射模式。 因此，随后调用[GetMapMode](#getmapmode)将返回而不是 MM_TEXT MM_ISOTROPIC。

在某些情况下，如具有多个位图，您可能想要保留从左到右布局。 在这些情况下，通过调用呈现图像`BitBlt`或`StretchBlt`，然后将设置为位图控制标志*dwLayout* LAYOUT_BITMAPORIENTATIONPRESERVED 到。

一旦更改包含 LAYOUT_RTL 标志的布局，通常情况下指定的标志右侧或左侧会反转。 为避免混淆，您可能想要定义的标准标志的替代名称。 建议的替代标志名称的列表，请参阅[SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) Windows SDK 中。

##  <a name="setmapmode"></a>  CDC::SetMapMode

设置映射模式。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>参数

*nMapMode*<br/>
指定新的映射模式。 它可以是以下值之一：

- 具有任意缩放轴，MM_ANISOTROPIC 逻辑单元将转换为任意单位。 映射模式设置为 MM_ANISOTROPIC 不会更改当前窗口或视区设置。 若要更改单位，方向和缩放，调用[SetWindowExt](#setwindowext)并[SetViewportExt](#setviewportext)成员函数。

- 每个逻辑单元转换为 0.001 英寸 MM_HIENGLISH。 向右; 是正 x正 y 已启动。

- 每个逻辑单元转换为 0.01 毫米 MM_HIMETRIC。 向右; 是正 x正 y 已启动。

- MM_ISOTROPIC 逻辑单元都具有同样缩放轴; 转换为任意单位即，沿 x 轴的 1 个单位等于 1 个单位的沿 y 轴。 使用`SetWindowExt`和`SetViewportExt`成员函数来指定所需的单位和轴的方向。 GDI 根据需要进行调整以确保 x 和 y 单位保持同样的大小。

- MM_LOENGLISH 每个逻辑单元将转换为 0.01 英寸。 向右; 是正 x正 y 已启动。

- 每个逻辑单元转换为 0.1 毫米 MM_LOMETRIC。 向右; 是正 x正 y 已启动。

- MM_TEXT 每个逻辑单元转换为 1 台设备像素。 向右; 是正 x正 y 已关闭。

- MM_TWIPS 每个逻辑单元将转换为 1/20 的点。 （因为点 1/72 英寸，缇为 1/1440年英寸。）向右; 是正 x正 y 已启动。

### <a name="return-value"></a>返回值

先前的映射模式。

### <a name="remarks"></a>备注

映射模式定义用于将转换为设备单位; 的逻辑单元的度量的单位它还定义了设备的 x 轴和 y 轴的方向。 GDI 使用映射模式以逻辑坐标转换为适当的设备坐标。 MM_TEXT 模式允许应用程序能够以设备像素为单位，其中 1 个单位等于 1 个像素。 物理像素大小各不相同设备的。

MM_HIENGLISH、 MM_HIMETRIC、 MM_LOENGLISH、 MM_LOMETRIC 和 MM_TWIPS 模式可用于应用程序必须在物理上有意义的单元 （如英寸或毫米） 中进行绘制。 MM_ISOTROPIC 模式可确保 1:1 的纵横比，一定要记住的图像的确切形状时，这很有用。 MM_ANISOTROPIC 模式允许 x 坐标和 y 坐标来独立地进行调整。

> [!NOTE]
>  如果您调用[SetLayout](#setlayout)若要为从右到左布局，更改 DC （设备上下文）`SetLayout`自动更改为 MM_ISOTROPIC 的映射模式。

### <a name="example"></a>示例

  有关示例，请参阅[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

更改时将转换为物理字体的逻辑字体的字体映射器使用的方法。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>参数

*dwFlag*<br/>
指定是否字体映射器尝试进行字体的方面高度和宽度与设备匹配。 此值为 ASPECT_FILTERING，映射器会选择唯一的方面 x 和 y 方面与指定设备完全相同的字体。

### <a name="return-value"></a>返回值

字体映射器标志的以前的值。

### <a name="remarks"></a>备注

应用程序可以使用`SetMapperFlags`导致尝试选择仅与指定设备的纵横比完全匹配的物理字体的字体映射器。

使用仅光栅字体的应用程序可以使用`SetMapperFlags`函数，以确保选择的字体映射器的字体是极具吸引力和指定的设备上可读。 通常使用 (TrueType) 显示可缩放字体的应用程序不使用`SetMapperFlags`。

如果没有物理字体具有匹配的逻辑字体中的规范纵横比，GDI 选择新的长宽比，并选择与此新的纵横比匹配的字体。

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

设置设备上下文的斜接联接的长度的限制。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>参数

*fMiterLimit*<br/>
指定设备上下文的新斜联接限制。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

斜接长度定义为从联接的内侧的行墙的交集到联接外侧的行墙的交集的距离。 斜角限制为线条宽度对斜接长度的最大允许的比率。 默认斜联接限制为 10.0。

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

调用此成员函数来设置输出设备上下文， `m_hDC`。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

设备上下文未附加到时，才可以调用此成员函数`CDC`对象。 此成员函数将设置`m_hDC`但不会附加到的设备上下文`CDC`对象。

##  <a name="setpixel"></a>  CDC::SetPixel

设置到指定的颜色接近指定的点的像素*crColor*。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要设置的点的逻辑 x 坐标。

*y*<br/>
指定要设置的点的逻辑 y 坐标。

*crColor*<br/>
一个 COLORREF RGB 值，该值指定用来绘制点的颜色。 请参阅[COLORREF](/windows/desktop/gdi/colorref)适用于此值的说明的 Windows SDK 中。

*点*<br/>
指定逻辑 x 坐标和 y 坐标点设置。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

实际绘制点的颜色 RGB 值。 此值可以是不同于指定的*crColor*如果使用该颜色的近似值。 如果函数失败 （如果剪切区域外部点），则返回值为-1。

### <a name="remarks"></a>备注

点必须位于中的剪辑区域。 如果该点不在的剪辑区域，该函数没有任何影响。

不是所有的设备都支持 `SetPixel` 函数。 若要确定设备是否支持`SetPixel`，调用`GetDeviceCaps`成员函数具有 RASTERCAPS 索引，并检查 RC_BITBLT 标志的返回值。

##  <a name="setpixelv"></a>  CDC::SetPixelV

将像素设置为接近的指定颜色的指定坐标处。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要设置的点的逻辑单元中的 x 坐标。

*y*<br/>
要设置的点的逻辑单元中指定的 y 坐标。

*crColor*<br/>
指定要用来绘制点的颜色。

*点*<br/>
指定逻辑 x 坐标和 y 坐标点设置。 您可以传递[点](/windows/desktop/api/windef/ns-windef-tagpoint)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

点必须是中的剪辑区域和设备表面的可见部分。 并非所有设备都支持此成员函数。 有关详细信息，请参阅中的 RC_BITBLT 功能`CDC::GetDeviceCaps`成员函数。 `SetPixelV` 快于`SetPixel`因为它不需要返回实际绘制的点的颜色值。

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

设置多边形填充模式。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>参数

*nPolyFillMode*<br/>
指定新的填充模式。 此值可能为备用或缠绕。 在 Windows 中设置的默认模式是备用。

### <a name="return-value"></a>返回值

如果成功，则以前填充模式否则为 0。

### <a name="remarks"></a>备注

备用的多边形填充模式时，系统将填充每个扫描行上的奇数和偶数多边形边之间的区域。 它是系统填充区域的第一个和第二个端之间、 之间的第三个和第四个端，依此类推。 此模式是默认值。

绕组多边形填充模式下，系统会将在其中绘制图来确定是否填充区域的方向。 顺时针或逆时针方向绘制多边形内的每个直线线段。 每当从封闭区域到图的外面绘制的虚线通过顺时针线段，计数将递增。 行在经过一开始沿逆时针方向条线段，计数将减少。 如果在行达到图外部时，计数为非零值，填充区域。

##  <a name="setrop2"></a>  CDC::SetROP2

设置当前的绘制模式。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>参数

*nDrawMode*<br/>
指定新的绘制模式。 它可以是以下值之一：

- R2_BLACK 像素始终为黑色。

- R2_WHITE 像素始终为白色。

- R2_NOP 像素保持不变。

- R2_NOT 像素都是反转屏幕颜色。

- R2_COPYPEN 像素都是钢笔颜色。

- R2_NOTCOPYPEN 像素都是钢笔颜色的反函数。

- R2_MERGEPENNOT 像素都是和反转屏幕颜色的钢笔颜色组合 (最终像素 = （不屏幕像素） 或笔)。

- R2_MASKPENNOT 像素都是普遍适用于笔的颜色组合和屏幕的反转 (最终像素 = （不屏幕像素） 和笔)。

- R2_MERGENOTPEN 像素是钢笔颜色反转和屏幕颜色的组合 (最终像素 = （不笔） 或屏幕像素)。

- R2_MASKNOTPEN 像素都是在屏幕上常见的颜色组合和笔反转 (最终像素 = （而不是笔形） 和屏幕像素)。

- R2_MERGEPEN 像素都是钢笔颜色和屏幕颜色的组合 (最终像素 = 笔或屏幕像素)。

- R2_NOTMERGEPEN 像素就是 R2_MERGEPEN 颜色 (最终像素 = 未 （笔或屏幕像素）)。

- R2_MASKPEN 像素都是通用的笔和屏幕颜色的组合 (最终像素 = 笔和屏幕像素)。

- R2_NOTMASKPEN 像素就是 R2_MASKPEN 颜色 (最终像素 = 未 （笔和屏幕像素）)。

- R2_XORPEN 像素都是在笔或在屏幕中，但不在两者中的颜色的组合 (最终像素 = 笔 XOR 屏幕像素)。

- R2_NOTXORPEN 像素就是 R2_XORPEN 颜色 (最终像素 = 未 （笔 XOR 屏幕像素）)。

### <a name="return-value"></a>返回值

以前的绘制模式。

它可以是任何 Windows SDK 中提供的值。

### <a name="remarks"></a>备注

绘制模式指定如何与已在显示图面上的颜色组合笔的颜色和填充对象的内部。

绘制模式是仅适用于光栅设备;它不适用于向量的设备。 绘图模式是二进制的光栅操作代码表示所有可能的布尔组合的两个变量，不使用二元运算符 AND、 OR 和 XOR (独占 OR) 和一元运算。

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

设置的位图拉伸模式`StretchBlt`成员函数。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>参数

*nStretchMode*<br/>
指定的拉伸模式。 它可以是以下值之一：

|值|描述|
|-----------|-----------------|
|BLACKONWHITE|执行布尔 AND 操作使用为已清除的和现有像素的颜色值。 如果位图是单色位图，此模式会保留代价白色像素是黑色像素。|
|COLORONCOLOR|删除的像素为单位。 此模式下不尝试保留其信息的情况下删除所有消除的像素行数。|
|半色调|会从源矩形的像素映射到目标矩形中的像素的块。 通过目标块的像素为单位的平均颜色近似于源像素的颜色。|
||在设置后半色调拉伸模式下，应用程序必须调用 Win32 函数[SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex)设置画笔的原点。 如果它无法执行此操作，会发生画笔未对齐。|
|STRETCH_ANDSCANS|**Windows 95/98**:BLACKONWHITE 相同|
|STRETCH_DELETESCANS|**Windows 95/98**:COLORONCOLOR 相同|
|STRETCH_HALFTONE|**Windows 95/98**:半色调相同。|
|STRETCH_ORSCANS|**Windows 95/98**:WHITEONBLACK 相同|
|WHITEONBLACK|执行使用消除和现有像素的颜色值的布尔值或操作。 如果位图是单色位图，此模式会保留但要牺牲黑色像素的白色像素。|

### <a name="return-value"></a>返回值

以前的拉伸模式。 它可以是 STRETCH_ANDSCANS、 STRETCH_DELETESCANS 或 STRETCH_ORSCANS。

### <a name="remarks"></a>备注

位图拉伸模式定义如何从使用该函数压缩的位图中删除信息。

BLACKONWHITE (STRETCH_ANDSCANS) 和 WHITEONBLACK (STRETCH_ORSCANS) 模式通常用于保留前景色中单色位图的像素为单位。 COLORONCOLOR (STRETCH_DELETESCANS) 模式通常用于保留在色位图中的颜色。

半色调模式需要比其他三种模式; 的源映像的更多处理它低于他人，但会产生更高质量图像。 另请注意，`SetBrushOrgEx`设置以避免画笔未对齐的半色调模式后，必须调用。

拉伸模式可能也可根据设备驱动程序的功能。

##  <a name="settextalign"></a>  CDC::SetTextAlign

设置文本对齐方式的标志。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指定文本对齐方式的标志。 标志指定一个点和限定文本的矩形之间的关系。 点可以是当前的位置或文本输出函数指定的坐标。 限定文本的矩形被定义的文本字符串中的相邻字符单元格。 *NFlags*参数可以是以下三个类别中的一个或多个标志。 从每个类别中选择一个标志。 第一个类别会影响在 x 方向的文本对齐方式：

- TA_CENTER 对齐边界矩形的水平居中的点。

- TA_LEFT 对齐边界矩形的左侧和右侧的点。 此为默认设置。

- TA_RIGHT 对齐边界矩形的点的右侧。

第二个类别会影响在 y 方向的文本对齐方式：

- TA_BASELINE 对齐所选字体的基准线的点。

- TA_BOTTOM 对齐边界矩形底边的点。

- TA_TOP 对齐边界矩形的顶部的点。 此为默认设置。

第三个类别设置确定写入文本时是否更新当前的位置：

- 文本输出函数每次调用后，TA_NOUPDATECP 不会更新当前的位置。 此为默认设置。

- 每次调用文本输出函数之后的 TA_UPDATECP 更新当前的 x 位置。 新的位置是文本的边界矩形右侧。 如果设置此标志，对的调用中指定的坐标`TextOut`成员函数将被忽略。

### <a name="return-value"></a>返回值

以前文本对齐方式的设置，如果成功。 低序位字节包含水平设置和高位字节包含垂直设置;否则为 0。

### <a name="remarks"></a>备注

`TextOut`和`ExtTextOut`成员函数使用这些标志时定位的显示或设备上的文本字符串。 标志指定的特定点和限定文本的矩形之间的关系。 此点的坐标作为参数传递到`TextOut`成员函数。 由文本字符串中的相邻字符单元格构成限定文本的矩形。

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

设置 intercharacter 间距量。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>参数

*nCharExtra*<br/>
指定 （以逻辑单位） 的额外空间量要添加到每个字符。 如果当前映射模式不是`MM_TEXT`， *nCharExtra*进行转换，并舍入为最接近像素。

### <a name="return-value"></a>返回值

上一 intercharacter 间距量。

### <a name="remarks"></a>备注

GDI 将此间距添加到每个字符，包括中断字符时它将一行文本写入到的设备上下文。 Intercharacter 间距量的默认值为 0。

##  <a name="settextcolor"></a>  CDC::SetTextColor

设置为指定的颜色的文本颜色。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定 RGB 颜色值形式的文本的颜色。

### <a name="return-value"></a>返回值

以前的文本颜色的 RGB 值。

### <a name="remarks"></a>备注

向此设备上下文以及之间的转换位图的颜色和单色设备上下文中写入文本时，系统将使用此文本颜色。

如果设备不能表示的指定的颜色，因此系统将设置为最接近的物理颜色的文本颜色。 指定一个字符的背景色`SetBkColor`和`SetBkMode`成员函数。

### <a name="example"></a>示例

  有关示例，请参阅[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

##  <a name="settextjustification"></a>  CDC::SetTextJustification

将空间添加到字符串中的中断字符。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>参数

*nBreakExtra*<br/>
指定要添加到 （以逻辑单位） 的文本行的总额外空间。 如果当前映射模式不是`MM_TEXT`，此参数提供的值转换为当前的映射模式，并舍入为最接近的设备单位。

*nBreakCount*<br/>
指定的行中的中断字符数。

### <a name="return-value"></a>返回值

一个函数运行成功; 如果否则为 0。

### <a name="remarks"></a>备注

应用程序可以使用`GetTextMetrics`成员函数来检索字体的中断字符。

之后`SetTextJustification`调用成员函数时，对文本输出函数的调用 (如`TextOut`) 分布均匀地分布在指定数量的中断字符指定额外的空间。 换行符字符通常是空格字符 (ASCII 32)，但可能按某些其他字符作为字体定义。

成员函数`GetTextExtent`通常用于`SetTextJustification`。 `GetTextExtent` 计算给定之前对齐线的宽度。 应用程序可以确定在指定的空间大小*nBreakExtra*通过返回的值中减去参数`GetTextExtent`从后对齐方式的字符串的宽度。

`SetTextJustification`函数可用于对齐一行，其中包含多个运行在不同的字体。 在这种情况下，在行必须段落创建通过对齐并单独编写每个运行。

因为舍入错误可能会发生对齐方式，系统将保留一个正在运行的错误术语，它定义当前错误。 对齐一行，其中包含多个运行时`GetTextExtent`会自动使用它将计算下一次运行的范围时此误差项。 这样，新的运行会融入了错误的文本输出函数。

对齐每行后，必须清除此错误术语，以防止它合并到下一行。 可以通过调用清除术语`SetTextJustification`与*nBreakExtra*设置为 0。

##  <a name="setviewportext"></a>  CDC::SetViewportExt

设置 x-和 y 的盘区的设备上下文的视区。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>参数

*cx*<br/>
指定 （以设备为单位） 的视区的 x 范围。

*cy*<br/>
指定 （以设备为单位） 的视区的 y 范围。

*size*<br/>
指定 x-和 y 的盘区的视区 （以设备为单位）。

### <a name="return-value"></a>返回值

为视区的上一个盘区[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。 发生错误时，x 坐标和 y 坐标所返回的`CSize`对象均设置为 0。

### <a name="remarks"></a>备注

在视区，以及设备上下文窗口中，定义 GDI 如何映射到实际设备的坐标系统中的点的逻辑坐标系统中的点。 换而言之，他们会定义 GDI 如何将逻辑坐标转换成设备坐标。

当设置了以下映射模式时，会调用到`SetWindowExt`和`SetViewportExt`将被忽略：

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

当设置 MM_ISOTROPIC 模式时，应用程序必须调用`SetWindowExt`成员函数调用之前`SetViewportExt`。

### <a name="example"></a>示例

  有关示例，请参阅[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

设置设备上下文的视区原点。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定的 x 坐标 （以设备为单位） 的视区原点。 值必须在设备坐标系统的范围内。

*y*<br/>
指定的 y 坐标 （以设备为单位） 的视区原点。 值必须在设备坐标系统的范围内。

*点*<br/>
指定的视区原点。 值必须在设备坐标系统的范围内。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

以前 （在设备区坐标中） 作为的视区原点`CPoint`对象。

### <a name="remarks"></a>备注

在视区，以及设备上下文窗口中，定义 GDI 如何映射到实际设备的坐标系统中的点的逻辑坐标系统中的点。 换而言之，他们会定义 GDI 如何将逻辑坐标转换成设备坐标。

视区原点标记在设备坐标系统 GDI 映射窗口原点，由指定的逻辑坐标系统中的点到点`SetWindowOrg`成员函数。 GDI 按照相同的过程映射到视区原点的窗口原点需映射所有其他点。 例如，在窗口原点的点为圆心中的所有点都将中位于视区原点的点为圆心。 同样，通过窗口原点的行中的所有点都会通过视区原点的行中。

### <a name="example"></a>示例

  有关示例，请参阅[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setwindowext"></a>  CDC::SetWindowExt

设置 x-和 y 的盘区的设备上下文与关联的窗口。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>参数

*cx*<br/>
指定的 x 的范围 （以逻辑单位） 的窗口。

*cy*<br/>
指定 y-范围 （以逻辑单位） 的窗口。

*size*<br/>
指定 x-和 y 的扩展盘区 （以逻辑单位） 的窗口。

### <a name="return-value"></a>返回值

（以逻辑单位） 窗口中，根据上一盘区`CSize`对象。 如果发生错误，x 坐标和 y 坐标所返回的`CSize`对象均设置为 0。

### <a name="remarks"></a>备注

窗口中的，设备上下文视区，以及定义 GDI 如何映射到设备坐标系统中的点的逻辑坐标系统中的点。

当设置了以下映射模式时，会调用到`SetWindowExt`和`SetViewportExt`函数将被忽略：

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

当设置 MM_ISOTROPIC 模式时，应用程序必须调用`SetWindowExt`成员函数之前调用`SetViewportExt`。

### <a name="example"></a>示例

  有关示例，请参阅[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

设置设备上下文窗口的原点。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定窗口的新的源的逻辑 x 坐标。

*y*<br/>
指定窗口的新的源的逻辑 y 坐标。

*点*<br/>
指定窗口的新的源的逻辑坐标。 您可以传递`POINT`结构或`CPoint`为此参数的对象。

### <a name="return-value"></a>返回值

为窗口的上一个原点`CPoint`对象。

### <a name="remarks"></a>备注

窗口中的，设备上下文视区，以及定义 GDI 如何映射到设备坐标系统中的点的逻辑坐标系统中的点。

窗口原点标记从中 GDI 映射视区原点，由指定的设备坐标系统中的点的逻辑坐标系统中的点`SetWindowOrg`函数。 GDI 按照相同的过程映射到视区原点的窗口原点需映射所有其他点。 例如，在窗口原点的点为圆心中的所有点都将中位于视区原点的点为圆心。 同样，通过窗口原点的行中的所有点都会通过视区原点的行中。

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

设置全局空间和指定的设备上下文的页面空间之间的二维线性转换。 此转换可用于缩放、 旋转、 倾斜对象，或转换的图形输出。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>参数

*rXform*<br/>
引用[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)结构，其中包含转换数据。

### <a name="return-value"></a>返回值

成功时返回非零值。

在失败时返回 0。

若要获得扩展错误信息，请调用[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>备注

此方法会包装 Windows GDI 函数[SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform)。

##  <a name="startdoc"></a>  CDC::StartDoc

通知的新打印作业正在启动的设备驱动程序，所有后续`StartPage`和`EndPage`的调用应在同一个作业直到下假脱机`EndDoc`调用时发生。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>参数

*lpDocInfo*<br/>
指向[DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa)结构，它包含文档文件的名称和输出文件的名称。

*lpszDocName*<br/>
指向包含文档文件的名称的字符串指针。

### <a name="return-value"></a>返回值

如果函数成功，则返回值是大于零。 此值是文档的打印作业标识符。

如果函数失败，返回值是小于或等于零。

### <a name="remarks"></a>备注

这可确保文档超过一页将不能与其他作业进行分布。

对于 Windows 3.1 及更高版本，此函数将替换 STARTDOC 打印机转义。 使用此函数可确保包含多个页的文档不穿插其他打印作业。

`StartDoc` 不应在图元文件内使用。

### <a name="example"></a>示例

此代码片段获取默认打印机，将打开一个打印作业，并后台处理与"Hello，World ！"的一页 它。 由于此代码由打印的文本不缩放到打印机的逻辑单元，因此输出文本可能在此类大小写字母的结果是不可读。 缩放函数，如的 CDC `SetMapMode`， `SetViewportOrg`，和`SetWindowExt`，可以用于修复的缩放。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

调用此成员函数以准备打印机驱动程序以接收数据。

```
int StartPage();
```

### <a name="return-value"></a>返回值

大于或等于如果函数运行成功，则为 0 或负值是否发生错误。

### <a name="remarks"></a>备注

`StartPage` 将取代 NEWFRAME 和 BANDINFO 转义符。

有关打印的调用序列的概述，请参阅[StartDoc](#startdoc)成员函数。

系统会禁用`ResetDC`成员函数调用之间`StartPage`和`EndPage`。

### <a name="example"></a>示例

  有关示例，请参阅[CDC::StartDoc](#startdoc)。

##  <a name="stretchblt"></a>  CDC::StretchBlt

将位图从源矩形复制到目标矩形，必要时可拉伸或压缩位图以符合目标矩形的尺寸。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的 x 坐标（使用逻辑单位）。

*y*<br/>
指定目标矩形左上角的 y 坐标（使用逻辑单位）。

*nWidth*<br/>
指定目标矩形的宽度（使用逻辑单位）。

*nHeight*<br/>
指定目标矩形的高度（使用逻辑单位）。

*pSrcDC*<br/>
指定源设备上下文。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（使用逻辑单位）。

*ySrc*<br/>
指定源矩形左上角的 y 坐标（使用逻辑单位）。

*nSrcWidth*<br/>
指定源矩形的宽度（使用逻辑单位）。

*nSrcHeight*<br/>
指定源矩形的高度（使用逻辑单位）。

*dwRop*<br/>
指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、可能的源位图和目标位图的输出操作中的颜色。 该参数可能是下列值之一：

- BLACKNESS 打开黑色，所有输出。

- DSTINVERT 反转目标位图。

- MERGECOPY 合并模式与源位图使用布尔 AND 运算符。

- MERGEPAINT 合并反转的源位图与目标位图使用布尔 OR 运算符。

- NOTSRCCOPY 将反转的源位图复制到目标。

- NOTSRCERASE 反转目标位图与源位图使用布尔 OR 运算符组合的结果。

- PATCOPY 将模式复制到目标位图。

- PATINVERT 合并目标位图与模式使用布尔 XOR 运算符。

- PATPAINT 合并反转的源位图与模式使用布尔 OR 运算符。 使用布尔 OR 运算符合并该操作的结果与目标位图。

- SRCAND 结合了使用布尔 AND 运算符的目标和源位图的像素。

- SRCCOPY 将源位图复制到目标位图。

- SRCERASE 反转目标位图，并与源位图使用布尔 AND 运算符合并结果。

- SRCINVERT 结合了使用布尔 XOR 运算符的目标和源位图的像素。

- SRCPAINT 结合了使用布尔 OR 运算符的目标和源位图的像素。

- WHITENESS 打开空白，所有输出。

### <a name="return-value"></a>返回值

如果绘制出位图，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该函数使用目标设备上下文的拉伸模式（由 `SetStretchBltMode` 设置）确定如何拉伸或压缩位图。

`StretchBlt`函数将从通过给定的源设备移动位图*pSrcDC*到所调用的成员函数的设备上下文对象所表示的目标设备。 *XSrc*， *ySrc*， *nSrcWidth*，以及*nSrcHeight*参数定义的左上角和源矩形的尺寸. *X*， *y*， *nWidth*，以及*nHeight*参数提供的左上角和目标矩形的尺寸。 指定的光栅操作*dwRop*定义如何组合源位图和已在目标设备上的位。

`StretchBlt`函数创建的位图的镜像，如果的迹象*nSrcWidth*并*nWidth*或*nSrcHeight*和*nHeight*参数不同。 如果*nSrcWidth*并*nWidth*符号不同，该函数将创建的沿 x 轴的位图的镜像。 如果*nSrcHeight*并*nHeight*符号不同，该函数将创建的沿 y 轴的位图的镜像。

`StretchBlt` 函数将在内存中拉伸或压缩源位图，然后将结果复制到目标。 如果一个模式将与该结果合并，则合并操作会等到拉伸的源位图复制到目标后执行。 如果使用画笔，则为在目标设备上下文中选择的画笔。 目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。

如果目标位图、源位图和模式位图没有相同的颜色格式，`StretchBlt` 将转换源位图和模式位图，以与目标位图匹配。 在转换中将使用目标设备上下文的前景色和背景色。

如果 `StretchBlt` 必须将单色位图转换为彩色，则会将白色位 (1) 设置为背景色，黑色位 (0) 设置为前景色。 若要将彩色位图转换为单色，它会将与背景色匹配的像素设置为白色 (1)，其他所有像素设置为黑色 (0)。 在转换中将使用彩色设备上下文的前景色和背景色。

不是所有的设备都支持 `StretchBlt` 函数。 若要确定设备是否支持`StretchBlt`，调用`GetDeviceCaps`成员函数具有 RASTERCAPS 索引，并检查 RC_STRETCHBLT 标志的返回值。

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

关闭任何打开的图形路径中、 通过使用当前笔描边的路径的轮廓和填充其内部使用的当前画笔。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含封闭的路径。 `StrokeAndFillPath`成员函数具有与关闭在路径中，所有开放图形相同的效果和描边，并分别填充路径，只不过填充的区域不会重叠绘制的区域即使触笔位于宽。

##  <a name="strokepath"></a>  CDC::StrokePath

通过使用当前笔呈现指定的路径。

```
BOOL StrokePath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含封闭的路径。

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

调用此成员函数将扩展到指定的制表位位置数组中的值的选项卡的指定位置处字符的字符串。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>参数

*x*<br/>
指定字符串的起始点的逻辑 x 坐标。

*y*<br/>
指定字符串的起始点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。 可以将任一指针传递到字符数组或[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，长度进行计算。

*nTabPositions*<br/>
指定的制表位位置数组中的值的数目。

*lpnTabStopPositions*<br/>
指向数组，其中包含的制表位位置 （以逻辑单位）。 必须以递增顺序; 排序的制表位最小 x 值应为数组中的第一项。

*nTabOrigin*<br/>
指定从其选项卡展开 （以逻辑单位） 的起始位置的 x 坐标。

*str*<br/>
一个`CString`对象，其中包含指定的字符。

### <a name="return-value"></a>返回值

为字符串 （以逻辑单位） 的维度`CSize`对象。

### <a name="remarks"></a>备注

当前所选字体中编写文本。 如果*nTabPositions*为 0 并*lpnTabStopPositions*为 NULL，选项卡扩展到八次平均字符宽度。

如果*nTabPositions*为 1，停止分隔第一个值中指定的距离选项卡*lpnTabStopPositions*数组。 如果*lpnTabStopPositions*数组包含多个值，一个制表位设置为每个值在数组中，指定的数目可高达*nTabPositions*。 *NTabOrigin*参数，应用程序可以调用`TabbedTextOut`几次为单个行的函数。 如果应用程序调用该函数一次与*nTabOrigin*每次设置为相同的值，函数可展开相对于指定的位置的所有选项卡*nTabOrigin*。

默认情况下，函数不使用或更新当前位置。 如果应用程序需要更新当前位置，当调用该函数时，应用程序可以调用[SetTextAlign](#settextalign)成员函数*nFlags*设置为 TA_UPDATECP。 在设置此标志，Windows 将忽略*x*并*y*到后续调用的参数`TabbedTextOut`，改为使用当前的位置。

##  <a name="textout"></a>  CDC::TextOut

使用当前选定的字体在指定位置写入字符串。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>参数

*x*<br/>
指定文本起点的逻辑 x 坐标。

*y*<br/>
指定文本起点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。

*nCount*<br/>
指定字符串中的字符数。

*str*<br/>
包含要绘制的字符的 `CString` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

字符原点位于字符单元格的左上角。 默认情况下，函数不使用或更新当前位置。

如果应用程序需要时它将调用更新当前位置`TextOut`，应用程序可以调用`SetTextAlign`成员函数*nFlags*设置为 TA_UPDATECP。 在设置此标志，Windows 将忽略*x*并*y*到后续调用的参数`TextOut`，改为使用当前的位置。

### <a name="example"></a>示例

  有关示例，请参阅[cdc:: beginpath](#beginpath)。

##  <a name="transparentblt"></a>  CDC::TransparentBlt

调用此成员函数以传输到目标设备上下文中指定的源设备上下文中，对应于像素的矩形的颜色数据位块。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>参数

*xDest*<br/>
指定以逻辑单位，目标矩形左上角的 x 坐标。

*yDest*<br/>
指定以逻辑单位，目标矩形左上角的 y 轴坐标。

*nDestWidth*<br/>
指定的宽度，以逻辑单元，目标矩形。

*nDestHeight*<br/>
指定以逻辑单位，目标矩形的高度。

*pSrcDC*<br/>
指向源设备上下文指针。

*xSrc*<br/>
指定以逻辑单位，源矩形的 x 坐标。

*ySrc*<br/>
指定 y 轴坐标中的源矩形的逻辑单元。

*nSrcWidth*<br/>
指定的宽度，以逻辑单元，源矩形。

*nSrcHeight*<br/>
指定以逻辑单位，源矩形的高度。

*clrTransparent*<br/>
中要被视为透明的源位图的 RGB 颜色。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

`TransparentBlt` 允许对透明度;代表 RGB 颜色，即由*clrTransparent*呈现透明传输。

有关详细信息，请参阅[TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) Windows SDK 中。

##  <a name="updatecolors"></a>  CDC::UpdateColors

在系统调色板在逐像素的基础上的客户端区域中更新的设备上下文的匹配当前工作区的颜色。

```
void UpdateColors();
```

### <a name="remarks"></a>备注

实现逻辑调色板的非活动窗口都可以调用`UpdateColors`作为系统调色板发生更改时，重绘其工作区的替代方法。

有关使用调色板的详细信息，请参阅[UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) Windows SDK 中。

`UpdateColors`成员函数通常比重绘区域更快地更新工作区。 但是，由于该函数执行系统调色板发生更改之前基于每个像素的颜色的颜色转换，因此每次调用此函数会导致某些颜色准确度损失。

##  <a name="widenpath"></a>  CDC::WidenPath

将当前路径重新定义为将如果路径已描边，使用当前所选入设备上下文的笔绘制的区域。

```
BOOL WidenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数是仅当当前触笔位于几何笔的第二个版本创建的成功`CreatePen`成员函数，或如果使用的第一个版本创建笔`CreatePen`和具有宽度、 设备单位，大于 1。 设备上下文必须包含封闭的路径。 在路径中的任何 Bzier 曲线转换为直线，直线逼近加宽的曲线的序列。 在这种情况下，没有 Bzier 曲线处于后的路径`WidenPath`调用。

## <a name="see-also"></a>请参阅

[CObject 类](../../mfc/reference/cobject-class.md)<br/>
[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC 类](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC 类](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC 类](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC 类](../../mfc/reference/cmetafiledc-class.md)
