---
title: CDC 类
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: d25cad720a4e1abb9bca6b3ab22eea0261f24b48
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/22/2020
ms.locfileid: "81753426"
---
# <a name="cdc-class"></a>CDC 类

定义设备上下文对象的类。

## <a name="syntax"></a>语法

```
class CDC : public CObject
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|[CDC：：CDC](#cdc)|构造 `CDC` 对象。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CDC：：中止](#abortdoc)|终止当前打印作业，消除应用程序自上次调用`StartDoc`成员函数以来写入设备的所有内容。|
|[CDC：：中止路径](#abortpath)|关闭并丢弃设备上下文中的任何路径。|
|[CDC：：添加MetaFile评论](#addmetafilecomment)|将缓冲区的注释复制到指定的增强格式元文件中。|
|[CDC：：阿尔法布林](#alphablend)|显示具有透明或半透明像素的位图。|
|[CDC：：角弧](#anglearc)|绘制线段和圆弧，并将当前位置移动到圆弧的终点。|
|[CDC：：弧形](#arc)|绘制椭圆弧。|
|[CDC：：Arcto](#arcto)|绘制椭圆弧。此函数与`Arc`类似，但当前位置已更新。|
|[CDC：：附加](#attach)|将 Windows 设备上下文附加到`CDC`此对象。|
|[CDC：：开始路径](#beginpath)|在设备上下文中打开路径支架。|
|[CDC::BitBlt](#bitblt)|从指定的设备上下文复制位图。|
|[CDC：：乔德](#chord)|绘制和弦（由椭圆和线段的交点边界的闭合图）。|
|[CDC：：关闭图](#closefigure)|关闭路径中的打开图形。|
|[CDC：：创建兼容DC](#createcompatibledc)|创建与另一个设备上下文兼容的内存设备上下文。 您可以使用它来准备内存中的图像。|
|[CDC：：创建DC](#createdc)|为特定设备创建设备上下文。|
|[CDC：：创建IC](#createic)|为特定设备创建信息上下文。 这提供了一种快速的方式，无需创建设备上下文即可获取有关设备的信息。|
|[CDC：:DeleteDC](#deletedc)|删除与此`CDC`对象关联的 Windows 设备上下文。|
|[CDC：:DeleteTempMap](#deletetempmap)|由`CWinApp`空闲时间处理程序调用以删除 由 创建`CDC``FromHandle`的任何临时对象。 还要分离设备上下文。|
|[CDC：:D](#detach)|将 Windows 设备上下文从此`CDC`对象分离。|
|[CDC：:DPtoHIMETRIC](#dptohimetric)|将设备单元转换为 HIMETRIC 单位。|
|[CDC：:DPtoLP](#dptolp)|将设备单元转换为逻辑单位。|
|[CDC：:D原始3dRect](#draw3drect)|绘制三维矩形。|
|[CDC：:DrawDragrect](#drawdragrect)|在拖动矩形时擦除并重绘矩形。|
|[CDC：:D原始边缘](#drawedge)|绘制矩形的边缘。|
|[CDC：:D原始逃生](#drawescape)|访问无法通过图形设备接口 （GDI） 直接可用的视频显示的绘图功能。|
|[CDC：:D原始焦点Rect](#drawfocusrect)|在用于指示焦点的样式中绘制矩形。|
|[CDC：:D原始框架控制](#drawframecontrol)|绘制帧控件。|
|[CDC：:D原](#drawicon)|绘制图标。|
|[CDC：:D原](#drawstate)|显示图像并应用视觉效果以指示状态。|
|[nFormat](#drawtext)|在指定的矩形中绘制格式化文本。|
|[CDC：:D原始文本Ex](#drawtextex)|使用其他格式在指定的矩形中绘制格式化文本。|
|[CDC：：椭圆](#ellipse)|绘制椭圆形。|
|[CDC：：结束文件](#enddoc)|结束由成员函数启动的`StartDoc`打印作业。|
|[CDC：：结束页](#endpage)|通知设备驱动程序页面即将结束。|
|[CDC：：结束路径](#endpath)|关闭路径括号，并将支架定义的路径选择到设备上下文中。|
|[CDC：：枚举对象](#enumobjects)|枚举设备上下文中可用的笔和画笔。|
|[CDC：：逃生](#escape)|允许应用程序通过 GDI 访问无法直接从特定设备获得的设施。 还允许访问 Windows 转义功能。 应用程序发出的转义呼叫将翻译并发送到设备驱动程序。|
|[CDC：：排除剪辑](#excludecliprect)|创建由现有裁剪区域减去指定矩形的新裁剪区域。|
|[CDC：：排除更新Rgn](#excludeupdatergn)|通过将窗口中的更新区域从剪切区域中排除，防止在窗口无效区域内绘图。|
|[CDC：：ExtFlownFill](#extfloodfill)|用当前画笔填充区域。 提供比[CDC：：flownFill](#floodfill)成员函数更大的灵活性。|
|[CDC：：ExtTextOut](#exttextout)|使用当前选择的字体在矩形区域内写入字符串。|
|[CDC：：FillPath](#fillpath)|关闭当前路径中的任何打开图形，并使用当前画笔和多边形填充模式填充路径的内部。|
|[CDC：：FillRect](#fillrect)|使用特定的画笔填充给定的矩形。|
|[CDC：：菲尔根](#fillrgn)|使用指定的画笔填充特定区域。|
|[CDC：：FillSolidrect](#fillsolidrect)|用纯色填充矩形。|
|[CDC：：扁平路径](#flattenpath)|将所选路径中的任何曲线转换为当前设备上下文，并将每个曲线转换为一系列直线。|
|[CDC：：洪水填充](#floodfill)|用当前画笔填充区域。|
|[CDC：：帧重新](#framerect)|在矩形周围绘制边框。|
|[CDC：：框架Rgn](#framergn)|使用画笔在特定区域周围绘制边框。|
|[CDC：：从手](#fromhandle)|当为设备上下文指定`CDC`句柄时，返回指向对象的指针。 如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。|
|[CDC：：获取Arc方向](#getarcdirection)|返回设备上下文的当前弧方向。|
|[CDC：：获取Aspectratio过滤器](#getaspectratiofilter)|检索当前纵横比筛选器的设置。|
|[CDC：：GetBkColor](#getbkcolor)|检索当前背景颜色。|
|[CDC：：GetBkMode](#getbkmode)|检索后台模式。|
|[CDC：：获取"界限"](#getboundsrect)|返回指定设备上下文的当前累积边界矩形。|
|[CDC：：GetBrushOrg](#getbrushorg)|检索当前画笔的原点。|
|[CDC：：获取查布布宽度](#getcharabcwidths)|检索当前字体中给定范围内连续字符的宽度（以逻辑单位为单位）。|
|[CDC：：获取查拉布·斯波西](#getcharabcwidthsi)|检索当前 TrueType 字体中指定范围内的连续字形索引的宽度（以逻辑单位为单位）。|
|[CDC：：获取字符放置](#getcharacterplacement)|检索字符串上的各种类型的信息。|
|[CDC：：获取字符宽度](#getcharwidth)|从当前字体检索给定范围内连续字符的小数宽度。|
|[CDC：：获取字符](#getcharwidthi)|从当前字体中检索指定范围内的连续字形索引的宽度（逻辑坐标）。|
|[CDC：：获取剪辑盒](#getclipbox)|检索当前剪切边界周围最紧密边界矩形的尺寸。|
|[CDC：：获取颜色调整](#getcoloradjustment)|检索设备上下文的颜色调整值。|
|[CDC：：获取当前位图](#getcurrentbitmap)|返回指向当前选定`CBitmap`对象的指针。|
|[CDC：：获取当前画笔](#getcurrentbrush)|返回指向当前选定`CBrush`对象的指针。|
|[CDC：：获取当前字体](#getcurrentfont)|返回指向当前选定`CFont`对象的指针。|
|[CDC：：获取电流调色板](#getcurrentpalette)|返回指向当前选定`CPalette`对象的指针。|
|[CDC：：获取电流笔](#getcurrentpen)|返回指向当前选定`CPen`对象的指针。|
|[CDC：获取电流位置](#getcurrentposition)|检索笔的当前位置（在逻辑坐标中）。|
|[CDC：：获取DCBrush颜色](#getdcbrushcolor)|检索当前画笔的颜色。|
|[CDC：：获取DCPenColor](#getdcpencolor)|检索当前的钢笔颜色。|
|[CDC：获取设备Caps](#getdevicecaps)|检索有关给定显示设备的功能的指定设备特定信息。|
|[CDC：：获取字体数据](#getfontdata)|从可扩展的字体文件中检索字体指标信息。 通过指定要检索的信息在字体文件中指定偏移量和要返回的信息长度来标识。|
|[CDC：：获取字体语言信息](#getfontlanguageinfo)|返回有关指定显示上下文的当前选定字体的信息。|
|[CDC：获取字形图](#getglyphoutline)|检索当前字体中轮廓字符的轮廓曲线或位图。|
|[CDC：：获取图形模式](#getgraphicsmode)|检索指定设备上下文的当前图形模式。|
|[CDC：：获取哈弗通刷](#gethalftonebrush)|检索半色调画笔。|
|[CDC：：获取凯宁配对](#getkerningpairs)|检索当前在指定设备上下文中选择的字体的字符角对。|
|[CDC：：获取布局](#getlayout)|检索设备上下文 （DC） 的布局。 布局可以是从左到右（默认）或从右到左（镜像）。|
|[CDC：：获取地图模式](#getmapmode)|检索当前映射模式。|
|[CDC：：获取限制](#getmiterlimit)|返回设备上下文的斜接限制。|
|[CDC：获取最接近的颜色](#getnearestcolor)|检索给定设备可以表示的指定逻辑颜色的最接近的逻辑颜色。|
|[CDC：：获取大纲文本指标](#getoutlinetextmetrics)|检索 TrueType 字体的字体指标信息。|
|[CDC：：获取输出字符宽度](#getoutputcharwidth)|使用输出设备上下文从当前字体检索连续字符组中单个字符的宽度。|
|[CDC：：获取输出标签文本范围](#getoutputtabbedtextextent)|计算输出设备上下文中字符串的宽度和高度。|
|[CDC：：获取输出文本范围](#getoutputtextextent)|使用当前字体计算输出设备上下文中文本行的宽度和高度，以确定尺寸。|
|[CDC：获取输出文本指标](#getoutputtextmetrics)|从输出设备上下文检索当前字体的指标。|
|[CDC：获取路径](#getpath)|检索定义行端点的坐标以及选择到设备上下文中的路径中找到的曲线的控制点。|
|[CDC：获取像素](#getpixel)|在指定点检索像素的 RGB 颜色值。|
|[CDC：：获取多利填充模式](#getpolyfillmode)|检索当前多边形填充模式。|
|[CDC：GetROP2](#getrop2)|检索当前绘图模式。|
|[CDC：：获取安全Hdc](#getsafehdc)|返回[CDC：：m_hDC](#m_hdc)，输出设备上下文。|
|[CDC：：获取拉伸模式](#getstretchbltmode)|检索当前位图拉伸模式。|
|[CDC：：获取标签文本范围](#gettabbedtextextent)|计算属性设备上下文中字符串的宽度和高度。|
|[CDC：：获取文本对齐](#gettextalign)|检索文本对齐标志。|
|[CDC：：获取文本字符额外](#gettextcharacterextra)|检索字符间间距量的当前设置。|
|[CDC：：获取文本颜色](#gettextcolor)|检索当前文本颜色。|
|[CDC：：获取文本范围](#gettextextent)|使用当前字体计算属性设备上下文中文本行的宽度和高度，以确定尺寸。|
|[CDC：：获取文本范围ExPointI](#gettextextentexpointi)|检索指定字符串中将适合指定空间的字符数，并为每个字符填充文本范围的数组。|
|[CDC：获取文本范围点I](#gettextextentpointi)|检索指定字形索引数组的宽度和高度。|
|[CDC：：获取文本面](#gettextface)|将当前字体的字体名称作为 null 终止字符串复制到缓冲区中。|
|[CDC：：获取文本指标](#gettextmetrics)|从属性设备上下文中检索当前字体的指标。|
|[CDC：：获取查看端口Ext](#getviewportext)|检索视口的 x 和 y 范围。|
|[CDC：：获取查看端口组织](#getviewportorg)|检索视口原点的 x 坐标和 y 坐标。|
|[CDC：：获取窗口](#getwindow)|返回与显示设备上下文关联的窗口。|
|[CDC：：获取窗口Ext](#getwindowext)|检索关联窗口的 x 和 y 范围。|
|[CDC：：获取窗口组织](#getwindoworg)|检索关联窗口的原点的 x 和 y 坐标。|
|[CDC：：获取世界转型](#getworldtransform)|检索当前世界空间到页面空间转换。|
|[CDC：：梯度填充](#gradientfill)|用格拉达颜色填充矩形和三角形结构。|
|[CDC：：灰色字符串](#graystring)|在给定位置绘制灰色（灰色）文本。|
|[CDC：：HIMETRITtoDP](#himetrictodp)|将 HIMETRIC 单元转换为设备单元。|
|[CDC：：HIMETRICTOLP](#himetrictolp)|将 HIMETRIC 单位转换为逻辑单位。|
|[CDC：：相交剪辑](#intersectcliprect)|通过形成当前区域和矩形的交集创建新的裁剪区域。|
|[CDC：：反逆转](#invertrect)|反转矩形的内容。|
|[CDC：：反逆](#invertrgn)|反转区域中的颜色。|
|[CDC：：正在打印](#isprinting)|确定设备上下文是否用于打印。|
|[CDC：：线到](#lineto)|从当前位置向上绘制一条线，但不包括点。|
|[CDC：LPtoDP](#lptodp)|将逻辑单位转换为设备单元。|
|[CDC：LPtoHIMETRIC](#lptohimetric)|将逻辑单位转换为 HIMETRIC 单位。|
|[CDC：：MaskBlt](#maskblt)|使用给定蒙版和栅格操作组合源和目标位图的颜色数据。|
|[CDC：：修改世界变换](#modifyworldtransform)|使用指定的模式更改设备上下文的世界转换。|
|[CDC：：移动到](#moveto)|移动当前位置。|
|[CDC：：偏移夹子](#offsetcliprgn)|移动给定设备的剪切区域。|
|[CDC：：偏移视口组织](#offsetviewportorg)|相对于当前视口原点的坐标修改视口原点。|
|[CDC：：偏移窗口组织](#offsetwindoworg)|相对于当前窗口原点的坐标修改窗口原点。|
|[CDC：:P](#paintrgn)|使用所选画笔填充区域。|
|[CDC：:PatBlt](#patblt)|创建位模式。|
|[CDC：:Pie](#pie)|绘制饼形楔形。|
|[CDC：:PlayMetaFile](#playmetafile)|在给定设备上播放指定元文件的内容。 增强版本`PlayMetaFile`显示存储在给定增强格式元文件中的图片。 元文件可以播放任意次数。|
|[CDC：:PlgBlt](#plgblt)|执行位块传输颜色数据位从源设备上下文中的指定矩形到给定设备上下文中的指定并行四字形。|
|[CDC：:P诺利·贝塞尔](#polybezier)|绘制一个或多个 Bzier 样条线。 当前位置既不使用也不更新。|
|[CDC：:P奥利贝塞尔托](#polybezierto)|绘制一个或多个 Bzier 样条线，并将当前位置移动到最后一个 Bzier 样条线的结束点。|
|[CDC：:P](#polydraw)|绘制一组线段和 Bzier 样条线。 此函数更新当前位置。|
|[CDC：:P](#polygon)|绘制由两个或多个点（顶点）组成的多边形，这些点由线连接。|
|[CDC：:Polyline](#polyline)|绘制一组连接指定点的线段。|
|[CDC：:Polylylylyto](#polylineto)|绘制一条或多条直线，并将当前位置移动到最后一行的结束点。|
|[CDC：:P多利多贡](#polypolygon)|创建使用当前多边形填充模式填充的两个或多个面。 多边形可能不交，也可能重叠。|
|[CDC：:P多利线](#polypolyline)|绘制多个串联线段系列。 此函数既不使用也不更新当前位置。|
|[CDC：:P可见](#ptvisible)|指定给定点是否位于剪切区域内。|
|[CDC：实现调色板](#realizepalette)|将当前逻辑调色板中的调色板条目映射到系统调色板。|
|[CDC：矩形](#rectangle)|使用当前笔绘制矩形并使用当前画笔填充矩形。|
|[CDC：：可分割](#rectvisible)|确定给定矩形的任何部分是否位于裁剪区域内。|
|[CDC：：释放AtribDC](#releaseattribdc)|释放`m_hAttribDC`，属性设备上下文。|
|[CDC：：释放输出DC](#releaseoutputdc)|释放`m_hDC`，输出设备上下文。|
|[CDC：：ResetDC](#resetdc)|更新`m_hAttribDC`设备上下文。|
|[CDC：：恢复DC](#restoredc)|将设备上下文还原到与`SaveDC`保存的上一个状态。|
|[CDC：：圆形Rect](#roundrect)|使用当前笔绘制圆角的矩形，并使用当前画笔填充。|
|[CDC：：保存DC](#savedc)|保存设备上下文的当前状态。|
|[CDC：：规模视口Ext](#scaleviewportext)|修改相对于当前值的视口范围。|
|[CDC：：缩放窗口Ext](#scalewindowext)|修改相对于当前值的窗口范围。|
|[CDC：：ScrollDC](#scrolldc)|水平和垂直滚动位矩形。|
|[CDC：：选择剪辑路径](#selectclippath)|选择当前路径作为设备上下文的剪切区域，使用指定的模式将新区域与任何现有剪切区域合并。|
|[CDC：：选择ClipRgn](#selectcliprgn)|使用指定的模式将给定区域与当前剪切区域合并。|
|[CDC::SelectObject](#selectobject)|选择 GDI 绘图对象（如笔）。|
|[CDC：：选择调色板](#selectpalette)|选择逻辑调色板。|
|[CDC::SelectStockObject](#selectstockobject)|选择 Windows 提供的预定义的库存笔、画笔或字体之一。|
|[CDC：：SetAbortProc](#setabortproc)|设置如果必须中止打印作业，Windows 调用的程序员提供的回调函数。|
|[CDC：：SetArc方向](#setarcdirection)|设置用于圆弧和矩形函数的绘图方向。|
|[疾控中心：：塞特特里布](#setattribdc)|设置`m_hAttribDC`，属性设备上下文。|
|[CDC：：SetBkColor](#setbkcolor)|设置当前背景颜色。|
|[CDC：：SetBkMode](#setbkmode)|设置背景模式。|
|[CDC：：SetBundsRect](#setboundsrect)|控制指定设备上下文的边界矩形信息的累积。|
|[CDC：：SetBrushOrg](#setbrushorg)|指定选择到设备上下文中的下一个画笔的原点。|
|[CDC：：设置颜色调整](#setcoloradjustment)|使用指定值设置设备上下文的颜色调整值。|
|[CDC：：SetDCBrush颜色](#setdcbrushcolor)|设置当前画笔颜色。|
|[CDC：：SetDCPenColor](#setdcpencolor)|设置当前笔颜色。|
|[CDC：：设置图形模式](#setgraphicsmode)|设置指定设备上下文的当前图形模式。|
|[CDC：：设置布局](#setlayout)|更改设备上下文 （DC） 的布局。|
|[CDC：：设置地图模式](#setmapmode)|设置当前映射模式。|
|[CDC：：设置映射标记](#setmapperflags)|更改字体映射器在将逻辑字体映射到物理字体时使用的算法。|
|[CDC：：设置Miter限制](#setmiterlimit)|设置设备上下文的斜接联接长度限制。|
|[CDC：：设置输出DC](#setoutputdc)|设置`m_hDC`，输出设备上下文。|
|[CDC：：设置像素](#setpixel)|将指定点的像素设置到指定颜色的最接近近似值。|
|[CDC：：SetPixelV](#setpixelv)|将指定坐标处的像素设置为指定颜色的最接近近似值。 `SetPixelV`比`SetPixel`它不需要返回实际绘制的点的颜色值更快。|
|[CDC：：设置Poly填充模式](#setpolyfillmode)|设置多边形填充模式。|
|[CDC：：SetROP2](#setrop2)|设置当前绘图模式。|
|[CDC：：设置拉伸模式](#setstretchbltmode)|设置位图拉伸模式。|
|[CDC：：设置文本对齐](#settextalign)|设置文本对齐标志。|
|[CDC：：设置文本字符额外](#settextcharacterextra)|设置字符间间距的量。|
|[CDC：：设置文本颜色](#settextcolor)|设置文本颜色。|
|[CDC：：设置文本对齐](#settextjustification)|向字符串中的分隔符添加空间。|
|[CDC：：SetViewportExt](#setviewportext)|设置视口的 x 和 y 范围。|
|[CDC：：SetViewportOrg](#setviewportorg)|设置视口原点。|
|[CDC：：设置窗口Ext](#setwindowext)|设置关联窗口的 x 和 y 范围。|
|[CDC：：设置窗口组织](#setwindoworg)|设置设备上下文的窗口源。|
|[CDC：：设置世界转换](#setworldtransform)|将当前世界空间设置为页面空间转换。|
|[CDC：：启动文档](#startdoc)|通知设备驱动程序新的打印作业正在启动。|
|[CDC：：起始页](#startpage)|通知设备驱动程序新页面正在启动。|
|[CDC：：拉伸Blt](#stretchblt)|将位图从源矩形和设备移动到目标矩形中，必要时拉伸或压缩位图以适合目标矩形的尺寸。|
|[CDC：：中风和填充路径](#strokeandfillpath)|关闭路径中的任何打开图形，使用当前笔绘制路径的轮廓，并使用当前画笔填充其内部。|
|[CDC：中风路径](#strokepath)|使用当前笔渲染指定的路径。|
|[CDC：：Tabbed文本出](#tabbedtextout)|在指定位置写入字符串，将选项卡扩展到制表停止位置数组中指定的值。|
|[CDC：：文本出](#textout)|使用当前选择的字体在指定位置写入字符串。|
|[CDC：：透明布拉特](#transparentblt)|将指定源设备上下文中的颜色数据位块传输到目标设备上下文，使指定的颜色在传输中透明。|
|[CDC：：更新颜色](#updatecolors)|通过将工作区中的当前颜色逐像素匹配到系统调色板，更新设备上下文的工作区。|
|[CDC：：宽道](#widenpath)|将当前路径重新定义为，如果使用当前选择的笔在设备上下文中绘制路径，则将绘制路径的区域。|

### <a name="public-operators"></a>公共运算符

|名称|说明|
|----------|-----------------|
|[CDC：：操作员 HDC](#operator_hdc)|检索设备上下文的句柄。|

### <a name="public-data-members"></a>公共数据成员

|名称|说明|
|----------|-----------------|
|[CDC：：m_hAttribDC](#m_hattribdc)|此`CDC`对象使用的属性设备上下文。|
|[CDC：：m_hDC](#m_hdc)|此`CDC`对象使用的输出设备上下文。|

## <a name="remarks"></a>备注

对象`CDC`提供用于处理设备上下文（如显示或打印机）的成员函数，以及用于处理与窗口工作区关联的显示上下文的成员。

通过`CDC`对象的成员函数进行所有绘图。 该类为设备上下文操作提供成员函数、使用绘图工具、类型安全图形设备接口 （GDI） 对象选择以及使用颜色和调色板。 它还提供成员函数，用于获取和设置绘图属性、映射、使用视口、使用窗口范围、转换坐标、使用区域、剪切、绘图线以及绘制简单形状、椭圆和面。 还提供了用于绘制文本、使用字体、使用打印机转义、滚动和播放元文件的成员函数。

要使用`CDC`对象，请构造它，然后调用并行使用设备上下文的 Windows 函数的成员函数。

> [!NOTE]
> 在 Windows 95/98 下，所有屏幕坐标限制为 16 位。 因此，传递给成员函数的`CDC` **int**必须位于范围 -32768 到 32767。

对于特定用途，Microsoft 基础类库提供了从 派生的`CDC`多个类。 `CPaintDC`封装对 和`BeginPaint``EndPaint`的调用。 `CClientDC`管理与窗口工作区关联的显示上下文。 `CWindowDC`管理与整个窗口关联的显示上下文，包括其框架和控件。 `CMetaFileDC`将设备上下文与元文件关联。

`CDC`提供了两个成员函数[GetLayout](#getlayout)和[SetLayout，](#setlayout)用于反转设备上下文的布局，而设备上下文不会从窗口继承其布局。 对于为区域性（如阿拉伯语或希伯来语）编写的应用程序（其中字符布局不是欧洲标准），这种从右到左的方向是必需的。

`CDC`包含两个设备上下文[，m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，在创建对象时`CDC`，它们引用同一设备。 `CDC`将所有输出 GDI 调用定向`m_hDC`到`m_hAttribDC`和 大多数属性 GDI 调用 。 （属性调用的示例是`GetTextColor`，而`SetTextColor`输出调用。

例如，框架使用这两个设备上下文来实现一个`CMetaFileDC`对象，该对象在从物理设备读取属性时将输出发送到元文件。 打印预览在框架中以类似方式实现。 您还可以在特定于应用程序的代码中以类似的方式使用这两个设备上下文。

有时，您可能需要来自 和`m_hDC``m_hAttribDC`设备上下文的文本度量信息。 以下函数对提供此功能：

|使用m_hAttribDC|使用m_hDC|
|-----------------------|-----------------|
|[获取文本范围](#gettextextent)|[获取输出文本范围](#getoutputtextextent)|
|[获取标签文本范围](#gettabbedtextextent)|[获取输出选项卡文本范围](#getoutputtabbedtextextent)|
|[获取文本指标](#gettextmetrics)|[获取输出文本指标](#getoutputtextmetrics)|
|[获取字符宽度](#getcharwidth)|[获取输出字符宽度](#getoutputcharwidth)|

有关 的详细信息`CDC`，请参阅[设备上下文](../../mfc/device-contexts.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>要求

**标头:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC：：中止

终止当前打印作业，并擦除自上次调用[StartDoc](#startdoc)成员函数以来应用程序写入设备的所有内容。

```
int AbortDoc();
```

### <a name="return-value"></a>返回值

如果成功，大于或等于 0 的值;如果发生错误，则为负值。 下面的列表显示了常见的错误值及其含义：

- SP_ERROR一般错误。

- SP_OUTOFDISK当前没有足够的磁盘空间可用于后台打印，并且不再有可用空间。

- SP_OUTOFMEMORY没有足够的内存可用于后台。

- SP_USERABORT 用户通过打印管理器终止作业。

### <a name="remarks"></a>备注

此成员功能将替换 ABORTDOC 打印机转义。

`AbortDoc`应用于终止以下内容：

- 使用[SetAbortProc](#setabortproc)未指定中止函数的打印操作。

- 尚未达到其第一个新帧或下一班德转义呼叫的打印操作。

如果应用程序遇到打印错误或已取消的打印操作，则不得尝试使用[EndDoc](#enddoc)或`AbortDoc`类`CDC`的成员函数终止操作。 GDI 在返回错误值之前自动终止操作。

如果应用程序显示一个对话框以允许用户取消打印操作，则必须在销毁对话框之前调用`AbortDoc`该对话框。

如果使用 Print Manager 启动打印作业，则调用`AbortDoc`擦除整个假脱机作业 - 打印机不会收到任何内容。 如果未使用打印管理器启动打印作业，则数据可能在调用之前`AbortDoc`已发送到打印机。 在这种情况下，打印机驱动程序将重置打印机（如果可能），并关闭打印作业。

### <a name="example"></a>示例

  请参阅 CDC[的示例：：StartDoc](#startdoc)。

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC：：中止路径

关闭并丢弃设备上下文中的任何路径。

```
BOOL AbortPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果设备上下文中有一个打开的路径支架，则路径支架将关闭，路径将被丢弃。 如果设备上下文中有闭合路径，则丢弃该路径。

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC：：添加MetaFile评论

将缓冲区的注释复制到指定的增强格式元文件中。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>参数

*n数据大小*<br/>
指定注释缓冲区的长度（以字节为单位）。

*pComment数据*<br/>
指向包含注释的缓冲区。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

注释可能包括任何私人信息，例如图片的来源和创建日期。 注释应以应用程序签名开头，后跟数据。 注释不应包含特定于位置的数据。 特定于位置的数据指定记录的位置，并且不应包含它，因为一个元文件可能嵌入到另一个元文件中。 此功能只能与增强的元文件一起使用。

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC：：阿尔法布林

调用此成员函数以显示具有透明或半透明像素的位图。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>参数

*xDest*<br/>
指定目标矩形左上角的 x 坐标（以逻辑单位表示）。

*yDest*<br/>
指定目标矩形左上角的 y 坐标（以逻辑单位表示）。

*nD最大宽度*<br/>
指定目标矩形的宽度（以逻辑单位为单位）。

*nDestHeight*<br/>
指定目标矩形的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向源设备上下文的指针。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（以逻辑单位表示）。

*伊斯尔克*<br/>
指定源矩形左上角的 y 坐标（以逻辑单位表示）。

*nSrcWidth*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nSrcHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*混合*<br/>
指定[BLEND，它结构](/windows/win32/api/wingdi/ns-wingdi-blendfunction)。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅 Windows SDK 中的[AlphaBlend。](/windows/win32/api/wingdi/nf-wingdi-alphablend)

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC：：角弧

绘制线段和圆弧。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>参数

*x*<br/>
指定圆中心的逻辑 x 坐标。

*Y*<br/>
指定圆中心的逻辑 y 坐标。

*nRadius*<br/>
以逻辑单位指定圆的半径。 该值必须是正数。

*fStartAngle*<br/>
指定起始角度（以度表示为相对于 x 轴）。

*fSweepAngle*<br/>
指定相对于起始角度的扫描角度（以度）。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

线段从当前位置绘制到圆弧的开头。弧线沿具有给定半径和中心的圆周线绘制。 圆弧的长度由给定的起始角和扫描角度定义。

`AngleArc`将当前位置移动到圆弧的终点。此函数绘制的弧可能看起来是椭圆形的，具体取决于当前的变换和映射模式。 在绘制圆弧之前，此函数将线段从当前位置绘制到圆弧的开头。弧是通过构造一个围绕指定中心点的指定半径的虚圆来绘制的。 弧的起点通过逆时针从圆的 x 轴测量起始角度中的度数来确定。 终点同样位于从起点逆时针测量扫描角度中的度数。

如果扫描角度大于 360 度，则圆弧将多次扫描。 此函数使用当前笔绘制线条。 图形未填充。

## <a name="cdcarc"></a><a name="arc"></a>CDC：：弧形

绘制椭圆弧。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定边界矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边界矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边界矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边界矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义圆弧起点（逻辑单位）的点的 x 坐标。 此点不必完全位于圆弧上。

*y3*<br/>
指定定义圆弧起点（逻辑单位）的点的 y 坐标。 此点不必完全位于圆弧上。

*x4*<br/>
指定定义圆弧端点（以逻辑单位）的点的 x 坐标。 此点不必完全位于圆弧上。

*y4*<br/>
指定定义圆弧端点（以逻辑单位）的点的 y 坐标。 此点不必完全位于圆弧上。

*lpRect*<br/>
指定边界矩形（以逻辑单位表示）。 您可以为此参数传递 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*pt 开始*<br/>
指定定义圆弧起点（以逻辑单位为单位）的点的 x 坐标和 y 坐标。 此点不必完全位于圆弧上。您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定定义圆弧结束点的点的 x 坐标和 y 坐标（以逻辑单位为单位）。 此点不必完全位于圆弧上。可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用 函数绘制的弧线是由指定边界矩形定义的椭圆段。

圆弧的实际起始点是从边界矩形中心穿过指定起点绘制的光线与椭圆相交的点。 圆弧的实际结束点是从边界矩形中心穿过指定结束点的光线与椭圆相交的点。 弧沿逆时针方向绘制。 由于圆弧不是闭合图形，因此不会填充。 矩形的宽度和高度必须大于 2 个单位，小于 32，767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC：：Arcto

绘制椭圆弧。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定边界矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边界矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边界矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边界矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义圆弧起点（逻辑单位）的点的 x 坐标。 此点不必完全位于圆弧上。

*y3*<br/>
指定定义圆弧起点（逻辑单位）的点的 y 坐标。 此点不必完全位于圆弧上。

*x4*<br/>
指定定义圆弧端点（以逻辑单位）的点的 x 坐标。 此点不必完全位于圆弧上。

*y4*<br/>
指定定义圆弧端点（以逻辑单位）的点的 y 坐标。 此点不必完全位于圆弧上。

*lpRect*<br/>
指定边界矩形（以逻辑单位表示）。 您可以传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)数据结构的指针或此参数的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*pt 开始*<br/>
指定定义圆弧起点（以逻辑单位为单位）的点的 x 坐标和 y 坐标。 此点不必完全位于圆弧上。您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定定义圆弧结束点的点的 x 坐标和 y 坐标（以逻辑单位为单位）。 此点不必完全位于圆弧上。您可以传递此参数`POINT`的数据结构或`CPoint`对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数与`CDC::Arc`类似，但当前位置已更新。 点 *（x1，* *y1*） 和 *（x2*， *y2*） 指定边界矩形。 由给定边界矩形形成的椭圆定义弧的曲线。弧逆时针延伸（默认弧方向），从与径向线相交的点从边界矩形的中心延伸到 *（x3*， *y3*）。 圆弧在从边界矩形的中心与径向线相交的位置结束至 *（x4，* *y4*）。 如果起始点和结束点相同，则绘制完整的椭圆。

线从当前位置绘制到圆弧的起点。如果未发生错误，则当前位置设置为圆弧的结束点。弧线使用当前笔绘制;未填充。

## <a name="cdcattach"></a><a name="attach"></a>CDC：：附加

使用此成员函数将*hDC*附加到`CDC`对象。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*hDC*存储在`m_hDC`输出设备上下文和`m_hAttribDC`属性设备上下文中。

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC：：开始路径

在设备上下文中打开路径支架。

```
BOOL BeginPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

路径支架打开后，应用程序可以开始调用 GDI 绘图函数来定义路径中的点。 应用程序可以通过调用成员函数关闭打开的`EndPath`路径支架。 当应用程序调用`BeginPath`时，将丢弃以前的任何路径。

有关定义路径中的点的绘图函数的列表，请参阅 Windows SDK 中的[BeginPath。](/windows/win32/api/wingdi/nf-wingdi-beginpath)

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC：：比特布拉特

将位图从源设备上下文复制到此当前设备上下文。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*Y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*n 宽度*<br/>
指定目标矩形和源位图的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定目标矩形和源位图的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向标识将从`CDC`中复制位图的设备上下文的对象的指针。 如果*dwRop*指定了不包含源的栅格操作，则它必须为 NULL。

*xSrc*<br/>
指定源位图左上角的逻辑 x 坐标。

*伊斯尔克*<br/>
指定源位图左上角的逻辑 y 坐标。

*dwRop*<br/>
指定要执行的光栅操作。 栅格操作代码定义 GDI 如何在涉及当前画笔、可能的源位图和目标位图的输出操作中组合颜色。 有关*dwRop*的栅格操作代码及其说明的列表，请参阅 Windows SDK 中的[BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt)

有关栅格操作代码的完整列表，请参阅 Windows SDK 中的["栅格操作代码"。](/windows/win32/gdi/raster-operation-codes)

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

应用程序可以对齐字节边界上的窗口或工作区，以确保操作`BitBlt`发生在与字节对齐的矩形上。 （在注册窗口类时设置CS_BYTEALIGNWINDOW或CS_BYTEALIGNCLIENT标志。

`BitBlt`与不对齐的矩形上的工序快`BitBlt`得多。 如果要为自己的设备上下文指定类样式（如字节对齐），则必须注册窗口类，而不是依赖 Microsoft Foundation 类来为您执行此操作。 使用全局函数[AfxRegisterwndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

GDI 转换*nWidth*和*nHeight*， 一次使用目标设备上下文， 一次通过使用源设备上下文. 如果生成的范围不匹配，GDI 会根据需要使用 Windows`StretchBlt`函数压缩或拉伸源位图。

如果目标、源和模式位图的颜色格式不同，则`BitBlt`函数将源和模式位图转换为与目标匹配。 转换中使用了目标位图的前景和背景颜色。

当`BitBlt`函数将单色位图转换为颜色时，它将白色位 （1） 设置到背景颜色，将黑色位 （0） 转换为前景颜色。 使用目标设备上下文的前景和背景颜色。 要将颜色转换为单色，将`BitBlt`匹配背景颜色的像素设置为白色，并将所有其他像素设置为黑色。 `BitBlt`使用颜色设备上下文的前景和背景颜色从颜色转换为单色。

请注意，并非所有设备上下文都支持`BitBlt`。 要检查给定的设备上下文是否支持`BitBlt`，请使用`GetDeviceCaps`成员函数并指定 RASTERCAPS 索引。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：创建兼容DC](#createcompatibledc)。

## <a name="cdccdc"></a><a name="cdc"></a>CDC：：CDC

构造 `CDC` 对象。

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC：：乔德

绘制和弦（由椭圆和线段的交点边界的闭合图）。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定和弦边界矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定和弦边界矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定和弦边界矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定和弦边界矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义和弦起点（以逻辑单位为单位）的点的 x 坐标。

*y3*<br/>
指定定义和弦起点（逻辑单位）的点的 y 坐标。

*x4*<br/>
指定定义和弦端点（以逻辑单位）的点的 x 坐标。

*y4*<br/>
指定定义和弦端点（以逻辑单位）的点的 y 坐标。

*lpRect*<br/>
指定边界矩形（以逻辑单位表示）。 您可以为此参数传递 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*pt 开始*<br/>
指定定义和弦起点（以逻辑单位为单位）的点的 x 和 y 坐标。 这一点不必完全躺在和弦上。 可以传递此参数`POINT`的结构或`CPoint`对象。

*ptEnd*<br/>
指定定义和弦结束点的点的 x 坐标和 y 坐标（以逻辑单位表示）。 这一点不必完全躺在和弦上。 您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*（x1、y1*） 和 *（x2*， *y2*） 参数分别指定矩形的左上角和右下角，该矩形与作为和弦一部分的椭圆的边界。 *y1* *（x3、y3*） 和 *（x4*， *y4*） 参数指定与椭圆相交的线的端点。 *y3* 使用所选笔绘制和弦，并使用所选画笔填充。

函数绘制的`Chord`图形最多延伸到，但不包括右坐标和底部坐标。 这意味着图形的高度为*y2* - *y1，* 图形的宽度为*x2* - *x1*。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC：：关闭图

关闭路径中的打开图形。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

函数通过将一条线从当前位置绘制到图形的第一个点（通常是最近对`MoveTo`成员函数调用指定的点）来关闭图形，并使用线路联接样式连接线。 如果使用`LineTo`成员函数而不是`CloseFigure`关闭图形，则使用结束大写来创建角而不是联接。 `CloseFigure`仅当设备上下文中存在打开的路径支架时，才应调用。

路径中的图形是打开的，除非使用此函数显式关闭它。 （即使图形的当前点和起始点相同，也可以打开图形。启动新图形后`CloseFigure`添加到路径的任何线或曲线。

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC：：创建兼容DC

创建与*pDC*指定的设备的内存设备上下文。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>参数

*pDC*<br/>
一个指向设备上下文的指针。 如果*pDC*为 NULL，则函数将创建与系统显示兼容的内存设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

内存设备上下文是表示显示表面的内存块。 它可用于在将图像复制到兼容设备的实际设备表面之前在内存中准备图像。

创建内存设备上下文时，GDI 会自动为其选择 1 个黑白股票位图。 仅当已创建位图并将其选择到该上下文中时，GDI 输出函数才能与内存设备上下文一起使用。

此功能只能用于为支持栅格操作的设备创建兼容的设备上下文。 有关设备上下文之间的位块传输的信息，请参阅[CDC：BitBlt](#bitblt)成员函数。 要确定设备上下文是否支持栅格操作，请参阅成员函数中的RC_BITBLT栅格功能`CDC::GetDeviceCaps`。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC：：创建DC

为指定的设备创建设备上下文。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>参数

*lpsz司机名称*<br/>
指向指定设备驱动程序的文件名（不带扩展名）的 null 端接字符串（例如"EPSON"）。 您还可以传递此参数`CString`的对象。

*lpszDevice名称*<br/>
指向指定要支持的特定设备名称的 null 端接字符串（例如，"EPSON FX-80"）。 如果模块支持多个设备，则使用*lpszDeviceName*参数。 您还可以传递此参数`CString`的对象。

*lpsz输出*<br/>
指向指定物理输出介质（文件或输出端口）的文件或设备名称的 null 端接字符串。 您还可以传递此参数`CString`的对象。

*lpInitData*<br/>
指向包含`DEVMODE`设备驱动程序的设备特定初始化数据的结构。 Windows`DocumentProperties`函数检索为给定设备填充的此结构。 如果设备驱动程序要使用用户通过控制面板指定的默认初始化（如果有），*则 lpInitData*参数必须为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

打印。如果使用[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)结构，则需要 H 标头文件。

设备名称遵循这些约定：结束冒号（:)建议，但可选。 Windows 会剥离终止冒号，以便以冒号结尾的设备名称映射到与没有冒号的相同名称相同的端口。 驱动程序和端口名称不得包含前导空格或尾随空格。 GDI 输出函数不能与信息上下文一起使用。

## <a name="cdccreateic"></a><a name="createic"></a>CDC：：创建IC

为指定的设备创建信息上下文。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>参数

*lpsz司机名称*<br/>
指向指定设备驱动程序的文件名（不带扩展名）的 null 端接字符串（例如"EPSON"）。 您可以传递此参数`CString`的对象。

*lpszDevice名称*<br/>
指向指定要支持的特定设备名称的 null 端接字符串（例如，"EPSON FX-80"）。 如果模块支持多个设备，则使用*lpszDeviceName*参数。 您可以传递此参数`CString`的对象。

*lpsz输出*<br/>
指向指定物理输出介质（文件或端口）的文件或设备名称的 null 端接字符串。 您可以传递此参数`CString`的对象。

*lpInitData*<br/>
指向设备驱动程序的设备特定初始化数据。 如果设备驱动程序要使用用户通过控制面板指定的默认初始化（如果有），*则 lpInitData*参数必须为 NULL。 有关`CreateDC`特定于设备的初始化的数据格式，请参阅。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

信息上下文提供了一种快速的方式，无需创建设备上下文即可获取有关设备的信息。

设备名称遵循这些约定：结束冒号（:)建议，但可选。 Windows 会剥离终止冒号，以便以冒号结尾的设备名称映射到与没有冒号的相同名称相同的端口。 驱动程序和端口名称不得包含前导空格或尾随空格。 GDI 输出函数不能与信息上下文一起使用。

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC：:DeleteDC

通常，不要调用此函数;因此，不要调用此函数。毁灭者会为你做

```
BOOL DeleteDC();
```

### <a name="return-value"></a>返回值

如果函数成功完成，则非零;否则 0。

### <a name="remarks"></a>备注

成员`DeleteDC`函数删除与当前`m_hDC``CDC`对象中关联的 Windows 设备上下文。 如果此`CDC`对象是给定设备的最后一个活动设备上下文，则会通知设备，并释放设备使用的所有存储和系统资源。

如果对象已选择到`DeleteDC`设备上下文中，则应用程序不应调用。 必须先从设备上下文中选择对象，然后才能将其删除。

应用程序不得删除其句柄通过调用[CWnd：：getDC](../../mfc/reference/cwnd-class.md#getdc)获得的设备上下文。 相反，它必须调用[CWnd：：ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc)来释放设备上下文。 提供[CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)类来包装此功能。

该`DeleteDC`函数通常用于删除使用[CreateDC、CreateIC](#createdc)或 Create [CreateIC](#createic)[兼容DC](#createcompatibledc)创建的设备上下文。

### <a name="example"></a>示例

  请参阅[CPrintDialog 的示例：获取 PrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC：:DeleteTempMap

由`CWinApp`空闲时间处理程序自动调用`DeleteTempMap`，删除 由 创建`CDC``FromHandle`的任何临时对象，但不会销毁临时与`hDC``CDC`对象关联的设备上下文句柄。

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC：:D

调用此函数以从`m_hDC``CDC`对象分离（输出设备上下文），并将和`m_hDC``m_hAttribDC`NULL 同时设置为 NULL。

```
HDC Detach();
```

### <a name="return-value"></a>返回值

Windows 设备上下文。

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC：:DPtoHIMETRIC

将 HIMETRIC 大小转换为 OLE 时，请使用此功能，将像素转换为 HIMETRIC。

```cpp
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[SIZE](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC 或MM_HIMETRIC，则转换基于物理英寸中的像素数。 如果映射模式是其他非约束模式之一（例如，MM_TEXT），则转换基于逻辑英寸中的像素数。

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC：:DPtoLP

将设备单元转换为逻辑单位。

```cpp
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象的数组。

*nCount*<br/>
数组中的点数。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于将一个矩形从设备点转换为逻辑点的简单情况。

*lpSize*<br/>
指向[SIZE](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

该函数将每个点的坐标或大小的尺寸从设备坐标系映射到 GDI 的逻辑坐标系。 转换取决于当前映射模式以及设备窗口和视口的源和范围的设置。

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC：:D原始3dRect

调用此成员函数以绘制三维矩形。

```cpp
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指定边界矩形（以逻辑单位表示）。 您可以传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构的指针或此参数的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*clrTop左*<br/>
指定三维矩形的顶部和左侧的颜色。

*clrBottomRight*<br/>
指定三维矩形底部和右侧的颜色。

*x*<br/>
指定三维矩形左上角的逻辑 x 坐标。

*Y*<br/>
指定三维矩形左上角的逻辑 y 坐标。

*残雪*<br/>
指定三维矩形的宽度。

*cy*<br/>
指定三维矩形的高度。

### <a name="remarks"></a>备注

矩形将以*clrTopLeft*指定的颜色绘制，在*clrBottomRight*指定的颜色中绘制底部和右侧。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC：:DrawDragrect

重复调用此成员函数以重绘拖动矩形。

```cpp
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定矩形的逻辑坐标 - 在这种情况下，要重绘的矩形的结束位置。

size <br/>
指定从外部边框的左上角到矩形内边框的左上角（即边框的粗细）的位移。

*lpRectLast*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定矩形位置的逻辑坐标 - 在这种情况下，要重绘的矩形的原始位置。

*大小 上次*<br/>
指定从外边框左上角到要重绘的原始矩形的左上角（即边框的粗细）的位移。

*pBrush*<br/>
指向画笔对象的指针。 设置为 NULL 以使用默认半色调画笔。

*pBrushLast*<br/>
指向使用的最后一个画笔对象。 设置为 NULL 以使用默认半色调画笔。

### <a name="remarks"></a>备注

在采样鼠标位置时在循环中调用它，以便提供视觉反馈。 调用`DrawDragRect`时，将擦除上一个矩形，并绘制一个新矩形。 例如，当用户在屏幕上拖动矩形时，`DrawDragRect`将擦除原始矩形并在其新位置重新绘制新矩形。 默认情况下，`DrawDragRect`使用半色调画笔绘制矩形以消除闪烁并创建平滑移动矩形的外观。

首次调用`DrawDragRect`时 *，lpRectLast*参数应为 NULL。

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC：:D原始边缘

调用此成员函数以绘制指定类型和样式的矩形的边缘。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含矩形逻辑`RECT`坐标的结构的指针。

*nEdge*<br/>
指定要绘制的内边缘和外边缘的类型。 此参数必须是一个内边界标志和一个外部边框标志的组合。 有关参数类型的表，请参阅 Windows SDK 中的[DrawEdge。](/windows/win32/api/winuser/nf-winuser-drawedge)

*nFlags*<br/>
指定要绘制的边框类型的标志。 有关`DrawEdge`参数值的表，请参阅 Windows SDK。 对于对角线，BF_RECT标志指定由矩形参数边界的矢量的终点。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC：:D原始逃生

访问无法通过图形设备接口 （GDI） 直接可用的视频显示的绘图功能。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>参数

*n逃生*<br/>
指定要执行的转义函数。

*nInputSize*<br/>
指定*lpszInputData*参数指向的数据字节数。

*lpszInput数据*<br/>
指向指定转义所需的输入结构。

### <a name="return-value"></a>返回值

指定函数的结果。 如果成功，大于零，但查询CSUPPORT绘制转义除外，该转义仅检查实现;或零，如果未实现转义;或小于零，如果发生错误。

### <a name="remarks"></a>备注

当应用程序调用`DrawEscape`时 *，nInputSize*和*lpszInputData*标识的数据将直接传递到指定的显示驱动程序。

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC：:D原始焦点Rect

在样式中绘制矩形，用于指示矩形具有焦点。

```cpp
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定要绘制的矩形的逻辑坐标。

### <a name="remarks"></a>备注

由于这是布尔 XOR 函数，因此第二次使用相同的矩形调用此函数会从显示中删除矩形。 无法滚动由此函数绘制的矩形。 要滚动包含此函数绘制的矩形的区域，请先调用`DrawFocusRect`从显示中删除矩形，然后滚动该区域，然后再次调用`DrawFocusRect`以在新位置绘制矩形。

> [!CAUTION]
> `DrawFocusRect`仅在MM_TEXT模式下工作。 在其他模式下，此函数不能正确绘制焦点矩形，但不会返回错误值。

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC：:D原始框架控制

调用此成员函数以绘制指定类型和样式的帧控件。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含矩形逻辑`RECT`坐标的结构的指针。

nType**<br/>
指定要绘制的帧控件的类型。 有关此参数的可能值的列表，请参阅 Windows SDK 中的[DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol)中的*uType*参数。

*n州*<br/>
指定帧控件的初始状态。 可以是 Windows SDK 中`DrawFrameControl`为*uState*参数描述的一个或多个值。 使用*nState*值DFCS_ADJUSTRECT调整边界矩形以排除按钮的周围边缘。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

在多种情况下 *，nState*依赖于*nType*参数。 下面的列表显示了四个*nType*值和*nState*之间的关系：

- DFC_BUTTON

  - DFCS_BUTTON3STATE三状态按钮

  - DFCS_BUTTONCHECK复选框

  - DFCS_BUTTONPUSH按钮

  - DFCS_BUTTONRADIO单选按钮

  - DFCS_BUTTONRADIOIMAGE用于单选按钮的图像（非方形需要图像）

  - DFCS_BUTTONRADIOMASK单选按钮的蒙版（非方形需要蒙版）

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE 关闭按钮

  - DFCS_CAPTIONHELP帮助按钮

  - DFCS_CAPTIONMAX 最大化按钮

  - DFCS_CAPTIONMIN 最小化按钮

  - DFCS_CAPTIONRESTORE 还原按钮

- DFC_MENU

  - DFCS_MENUARROW子菜单箭头

  - DFCS_MENUBULLET项目符号

  - DFCS_MENUCHECK检查标记

- DFC_SCROLL

  - DFCS_SCROLLCOMBOBOX组合框滚动条

  - DFCS_SCROLLDOWN滚动条向下箭头

  - DFCS_SCROLLLEFT滚动条的左箭头

  - DFCS_SCROLLRIGHT滚动条的右箭头

  - DFCS_SCROLLSIZEGRIP 窗口右下角的尺寸夹点

  - DFCS_SCROLLUP滚动条的向上箭头

### <a name="example"></a>示例

此代码在窗口右下角绘制大小夹持器。 它适用于对话框的`OnPaint`处理程序，该对话框没有样式，通常不包含可能为其提供大小夹持器的其他控件（如状态栏）。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC：:D原

在由当前`CDC`对象表示的设备上绘制图标。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>参数

*x*<br/>
指定图标左上角的逻辑 x 坐标。

*Y*<br/>
指定图标左上角的逻辑 y 坐标。

*hIcon*<br/>
标识要绘制的图标的句柄。

*点*<br/>
指定图标左上角的逻辑 x 坐标。 您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果函数成功完成，则非零;否则 0。

### <a name="remarks"></a>备注

该函数将图标的左上角置于*x*和*y*指定的位置。 该位置受设备上下文的当前映射模式的约束。

图标资源以前必须使用 函数`CWinApp::LoadIcon`或`CWinApp::LoadStandardIcon``CWinApp::LoadOEMIcon`加载。 在`MM_TEXT`使用此函数之前，必须选择映射模式。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：：IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC：:D原

调用此成员函数以显示图像并应用视觉效果以指示状态，如禁用或默认状态。

> [!NOTE]
> 对于除DSS_NORMAL之外的所有*nFlag*状态，在应用视觉效果之前，图像将转换为单色。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>参数

*pt*<br/>
指定图像的位置。

size <br/>
指定图像的大小。

*hBitmap*<br/>
位图的句柄。

*nFlags*<br/>
指定图像类型和状态的标志。 有关可能的*nFlags*类型和状态，请参阅 Windows SDK 中的[绘制状态](/windows/win32/api/winuser/nf-winuser-drawstatew)。

*hBrush*<br/>
刷子的手柄。

*pBitmap*<br/>
指向 CBitmap 对象的指针。

*pBrush*<br/>
指向 CBrush 对象的指针。

*hIcon*<br/>
图标的图柄。

*lpszText*<br/>
指向文本的指针。

*bPrefix文本*<br/>
可能包含加速器助记符的文本。 *lData*参数指定字符串的地址 *，nTextLen*参数指定长度。 如果*nTextLen*为 0，则假定字符串为 null 终止。

*nTextLen*<br/>
*lpszText*指向的文本字符串的长度。 如果*nTextLen*为 0，则假定字符串为 null 终止。

*lpDrawProc*<br/>
指向用于渲染图像的回调函数的指针。 如果*nFlags*中的图像类型DST_COMPLEX，则需要此参数。 它是可选的，如果图像类型为 DST_TEXT，则可以为 NULL。 对于所有其他图像类型，将忽略此参数。 有关回调功能的详细信息，请参阅 Windows SDK 中的[DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc)函数。

*lData*<br/>
指定有关图像的信息。 此参数的含义取决于图像类型。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC：:D原文本

调用此成员函数以在给定矩形中设置文本的格式。 要指定其他格式选项，请使用[CDC：:DrawTextEx](#drawtextex)。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为 -1，则字符串必须为 null 终止。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为 -1，则*假定 lpszString*是指向 null 终止字符串的长`DrawText`指针，并自动计算字符计数。

*lpRect*<br/>
指向包含要格式化文本的矩形（在逻辑坐标中）的[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*Str*<br/>
包含要绘制的指定字符的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nFormat*<br/>
指定设置文本格式的方法。 它可以是 Windows SDK 中[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中为*uFormat*参数描述的数值的任意组合。 （使用位或运算符组合）：

> [!NOTE]
> 某些*uFormat*标志组合可能导致修改传递的字符串。 将DT_MODIFYSTRING与DT_END_ELLIPSIS或DT_PATH_ELLIPSIS一起使用可能会导致字符串被修改，从而导致重写中的`CString`断言。 值DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP和DT_NOPREFIX不能与DT_TABSTOP值一起使用。

### <a name="return-value"></a>返回值

如果函数成功，则文本的高度。

### <a name="remarks"></a>备注

它通过将选项卡扩展到适当的空格，将文本对齐到给定矩形的左侧、右侧或中心，并将文本分解为适合给定矩形的行，从而设置文本的格式。 格式的类型由*nFormat*指定。

此成员函数使用设备上下文的选定字体、文本颜色和背景颜色来绘制文本。 除非使用DT_NOCLIP格式，否则`DrawText`剪辑文本，以便文本不会显示在给定矩形之外。 除非给出了DT_SINGLELINE格式，否则所有格式都假定具有多行。

如果所选字体对于指定的矩形太大，则`DrawText`成员函数不会尝试替换较小的字体。

如果指定了DT_CALCRECT标志，*则 lpRect*指定的矩形将更新以反映绘制文本所需的宽度和高度。

如果设置了TA_UPDATECP文本对齐标志（请参阅[CDC：SetTextAlign），](#settextalign)`DrawText`将显示从当前位置开始的文本，而不是在给定矩形的左侧。 `DrawText`设置TA_UPDATECP标志时不会换行文本（也就是说，DT_WORDBREAK标志将不起作用）。

文本颜色可以由 CDC 设置[：setTextColor](#settextcolor)。

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC：:D原始文本Ex

在给定矩形中设置文本的格式。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为 -1，则字符串必须为 null 终止。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为 -1，则*假定 lpszString*是指向 null 终止字符串的长`DrawText`指针，并自动计算字符计数。

*lpRect*<br/>
指向包含要格式化文本的矩形（在逻辑坐标中）的[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*Str*<br/>
包含要绘制的指定字符的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nFormat*<br/>
指定设置文本格式的方法。 它可以是 Windows SDK 中[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中为*uFormat*参数描述的数值的任意组合。 （**使用位或**运算符进行组合）：

> [!NOTE]
> 某些*uFormat*标志组合可能导致修改传递的字符串。 将DT_MODIFYSTRING与DT_END_ELLIPSIS或DT_PATH_ELLIPSIS一起使用可能会导致字符串被修改，从而导致重写中的`CString`断言。 值DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP和DT_NOPREFIX不能与DT_TABSTOP值一起使用。

*lpDTParams*<br/>
指向指定其他格式选项的[DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams)结构的指针。 此参数可以是 NULL。

### <a name="remarks"></a>备注

它通过将选项卡扩展到适当的空格，将文本对齐到给定矩形的左侧、右侧或中心，并将文本分解为适合给定矩形的行，从而设置文本的格式。 格式的类型由*nFormat*和*lpDTParams*指定。 有关详细信息，请参阅 Windows SDK 中的[CDC：:DrawText](#drawtext)和[DrawTextEx。](/windows/win32/api/winuser/nf-winuser-drawtextexw)

文本颜色可以由 CDC 设置[：setTextColor](#settextcolor)。

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC：：椭圆

绘制椭圆形。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定椭圆边界矩形左上角的逻辑 x 坐标。

*y1*<br/>
指定椭圆边界矩形左上角的逻辑 y 坐标。

*x2*<br/>
指定椭圆边界矩形右下角的逻辑 x 坐标。

*y2*<br/>
指定椭圆边界矩形右下角的逻辑 y 坐标。

*lpRect*<br/>
指定椭圆的边界矩形。 您还可以为此参数传递[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

椭圆的中心是由*x1、y1、x2*和*y2**y1*或*lpRect*指定的边界矩形的中心。 *x2* 椭圆用当前笔绘制，其内部用当前画笔填充。

此函数绘制的图形最多延伸到右坐标和底部坐标，但不包括该坐标。 这意味着图形的高度为*y2* - *y1，* 图形的宽度为*x2* - *x1*。

如果边界矩形的宽度或高度为 0，则不绘制椭圆。

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC：：结束文件

结束由调用[StartDoc](#startdoc)成员函数启动的打印作业。

```
int EndDoc();
```

### <a name="return-value"></a>返回值

如果函数成功，大于或等于 0;如果发生错误，则为负值。

### <a name="remarks"></a>备注

此成员功能将替换 ENDDOC 打印机转义，在完成成功打印作业后立即调用。

如果应用程序遇到打印错误或已取消的打印操作，则不得尝试使用 或`EndDoc` [AbortDoc](#abortdoc)终止操作。 GDI 在返回错误值之前自动终止操作。

不应在元文件中使用此功能。

### <a name="example"></a>示例

  请参阅 CDC[的示例：：StartDoc](#startdoc)。

## <a name="cdcendpage"></a><a name="endpage"></a>CDC：：结束页

通知设备应用程序已完成写入页面。

```
int EndPage();
```

### <a name="return-value"></a>返回值

如果函数成功，大于或等于 0;如果发生错误，则为负值。

### <a name="remarks"></a>备注

此成员函数通常用于指示设备驱动程序前进到新页面。

此成员功能将替换 NEWFRAME 打印机转义。 与 NEWFRAME 不同，此函数始终在打印页面后调用。

### <a name="example"></a>示例

  请参阅 CDC[的示例：：StartDoc](#startdoc)。

## <a name="cdcendpath"></a><a name="endpath"></a>CDC：：结束路径

关闭路径括号，并将支架定义的路径选择到设备上下文中。

```
BOOL EndPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：开始路径](#beginpath)。

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC：：枚举对象

枚举设备上下文中可用的笔和画笔。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>参数

*nObject类型*<br/>
指定对象类型。 它可以具有值OBJ_BRUSH或OBJ_PEN。

*利夫芬*<br/>
是应用程序提供的回调函数的过程实例地址。 请参阅下面的"备注"部分。

*lpData*<br/>
指向应用程序提供的数据。 数据与对象信息一起传递到回调函数。

### <a name="return-value"></a>返回值

指定[回调函数](callback-functions-used-by-mfc.md#enum_objects)返回的最后一个值。 其含义是用户定义的。

### <a name="remarks"></a>备注

对于给定类型的每个对象，您传递的回调函数将随该对象的信息一起调用。 系统调用回调功能，直到没有更多的对象或回调函数返回 0。

请注意，Microsoft VisualC++的新功能允许您使用普通函数作为函数传递给`EnumObjects`。 传递给的地址`EnumObjects`指向使用**EXPORT**导出的函数和 Pascal 调用约定的函数的指针。 在保护模式应用程序中，您不必使用 Windows MakeProcA 函数创建此函数，也不必在使用 FreeProcInstance Windows 功能后释放该函数。

您也不必在应用程序的模块定义文件中的**EXPORTS**语句中导出函数名称。 您可以改为使用**EXPORT**函数修改器，如

**int 回拨导出**功能 **（LPSTR，** **LPSTR）;**

使编译器发出正确的导出记录，以便按名称导出，而无需别名。 这适用于大多数需求。 对于某些特殊情况，例如通过单位导出或别名导出函数，您仍然需要在模块定义文件中使用**EXPORT**语句。

对于编译 Microsoft 基础程序，您通常将使用 /GA 和 /GEs 编译器选项。 /Gw 编译器选项不与 Microsoft 基础类一起使用。 （如果使用 Windows 函数`MakeProcInstance`，则需要显式将返回的函数指针从 FARPROC 转换为此 API 中所需的类型。回调注册接口现在属于类型安全（您必须传递一个函数指针，该函数指针指向特定回调的正确类型的函数）。

另请注意，所有回调函数在返回到 Windows 之前都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章["例外](../../mfc/exception-handling-in-mfc.md)"。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC：：逃生

此成员函数实际上已过时，用于 Win32 编程。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>参数

*n逃生*<br/>
指定要执行的转义函数。

有关转义函数的完整列表，请参阅 Windows SDK 中的[转义](/windows/win32/api/wingdi/nf-wingdi-escape)。

*nCount*<br/>
指定*lpszInData*指向的数据字节数。

*lpszInData*<br/>
指向此转义所需的输入数据结构。

*lpOutData*<br/>
指向要从此转义接收输出的结构。 如果未返回任何数据，*则 lpOutData*参数为 NULL。

*nInputSize*<br/>
指定*lpszInputData*参数指向的数据字节数。

*lpszInput数据*<br/>
指向指定转义所需的输入结构。

*n 输出大小*<br/>
指定*lpszOutputData*参数指向的数据字节数。

*lpsz输出数据*<br/>
指向从此转义接收输出的结构。 如果未返回任何数据，则此参数应为 NULL。

### <a name="return-value"></a>返回值

如果函数成功，则返回正值，但查询支持转义除外，该转义仅检查实现。 如果未实现转义，则返回零。 如果发生错误，将返回负值。 以下是常见的错误值：

- SP_ERROR一般错误。

- SP_OUTOFDISK当前没有足够的磁盘空间可用于后台打印，并且不再有可用空间。

- SP_OUTOFMEMORY没有足够的内存可用于后台。

- SP_USERABORT用户通过打印管理器结束了作业。

### <a name="remarks"></a>备注

在原始打印机转义中，Win32 应用程序仅支持查询支持。 所有其他打印机转义都已过时，仅支持与 16 位应用程序的兼容性。

对于 Win32 编程`CDC`，现在提供了六个成员函数，这些函数将取代相应的打印机转义：

- [CDC：：中止](#abortdoc)

- [CDC：：结束文件](#enddoc)

- [CDC：：结束页](#endpage)

- [CDC：：SetAbortProc](#setabortproc)

- [CDC：：启动文档](#startdoc)

- [CDC：：起始页](#startpage)

此外[，CDC：：GetDeviceCaps](#getdevicecaps)支持 Win32 索引，这些索引将取代其他打印机转义。 有关详细信息，请参阅 Windows SDK 中的[GetDeviceCaps。](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps)

此成员功能允许应用程序访问无法通过 GDI 直接可用的特定设备的设施。

如果应用程序使用预定义的转义值，请使用第一个版本。 如果应用程序定义私有转义值，请使用第二个版本。 有关第二个版本的详细信息，请参阅 Windows SDK 中的[ExtEscape。](/windows/win32/api/wingdi/nf-wingdi-extescape)

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC：：排除剪辑

创建由现有裁剪区域减去指定矩形的新裁剪区域。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形右下角的逻辑 y 坐标。

*lpRect*<br/>
指定矩形。 也可以是一个`CRect`对象。

### <a name="return-value"></a>返回值

指定新裁剪区域的类型。 可以是以下任一值：

- 区域具有重叠边框。

- 未创建任何区域。

- NULL 区域为空。

- 区域没有重叠边框。

### <a name="remarks"></a>备注

矩形的宽度（由*x2* - *x1*的绝对值指定）不得超过 32，767 个单位。 此限制也适用于矩形的高度。

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC：：排除更新Rgn

通过将窗口中的更新区域从与`CDC`对象的剪切区域中排除，防止在窗口无效区域内绘图。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
指向正在更新其窗口的窗口对象。

### <a name="return-value"></a>返回值

排除区域的类型。 它可以是以下任一值：

- 区域具有重叠边框。

- 未创建任何区域。

- NULL 区域为空。

- 区域没有重叠边框。

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC：：ExtFlownFill

使用当前画笔填充显示表面的区域。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>参数

*x*<br/>
指定填充开始点的逻辑 x 坐标。

*Y*<br/>
指定填充开始点的逻辑 y 坐标。

*crColor*<br/>
指定要填充的边界或区域的颜色。 *crColor*的解释取决于*nFillType*的值。

*n 填充类型*<br/>
指定要执行的泛洪填充类型。 它必须是以下值之一：

- 填充区域由*crColor*指定的颜色绑定。 此样式与 执行的`FloodFill`填充相同。

- 填充区域由*crColor*指定的颜色定义。 只要遇到颜色，填充会向外所有方向继续。 此样式可用于填充具有多色边界的区域。

### <a name="return-value"></a>返回值

如果函数成功，则非零;否则 0 如果无法完成填充，则给定点具有*crColor*指定的边界颜色（如果请求了泛色填充），如果给定点没有*crColor*指定的颜色（如果请求了 FLOODFILLSURFACE），或者该点位于剪切区域之外。

### <a name="remarks"></a>备注

此成员函数提供了比`FloodFill`在*nFillType*中指定填充类型更大的灵活性。

如果*nFillType*设置为"泛填充"，则假定该区域完全由*crColor*指定的颜色绑定。 函数从*x*和*y*指定的点开始，并填充到颜色边界的所有方向。

如果*nFillType*设置为 FLOODFILLSURFACE，则函数从*x*和*y*指定的点开始，然后继续所有方向，填充包含*crColor*指定颜色的所有相邻区域。

只有支持栅格显示技术支持的内存设备上下文和设备`ExtFloodFill`。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数。

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC：：ExtTextOut

调用此成员函数，使用当前选择的字体在矩形区域内写入字符串。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>参数

*x*<br/>
指定指定字符串中第一个字符的字符单元格的逻辑 x 坐标。

*Y*<br/>
指定指定字符串中第一个字符的字符单元格顶部的逻辑 y 坐标。

*n选项*<br/>
指定矩形类型。 此参数可以是一个、两个值，也可以是以下两个值：

- ETO_CLIPPED指定文本剪切到矩形。

- ETO_OPAQUE 指定当前背景颜色填充矩形。 （您可以使用[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成员功能设置和查询当前背景颜色。

*lpRect*<br/>
指向确定矩形尺寸的[RECT](/windows/win32/api/windef/ns-windef-rect)结构。 此参数可以是 NULL。 您还可以为此参数传递[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*lpszString*<br/>
指向要绘制的指定字符串。 您还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定字符串中的字符数。

*lpDx 宽度*<br/>
指向指示相邻字符单元格原点之间的距离的值数组。 例如 *，lpDxWidths*= *i*= 逻辑单位将分隔字符单元格*i*和字符单元格*i* = 1 的源。 如果*lpDxWidths*为`ExtTextOut`NULL，则使用字符之间的默认间距。

*Str*<br/>
包含`CString`要绘制的指定字符的对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

矩形区域可以是不透明的（填充当前背景颜色），也可以是剪切区域。

如果*nOptions*为*0，lpRect*为 NULL，则函数无需使用矩形区域即可将文本写入设备上下文。 默认情况下，函数不使用或更新当前位置。 如果应用程序在`ExtTextOut`调用时需要更新当前位置，则应用程序可以调用`CDC`成员函数[SetTextAlign，nFlags](#settextalign) *nFlags*设置为TA_UPDATECP。 设置此标志时，Windows 会忽略对后续调用`ExtTextOut`的*x*和*y，* 而是使用当前位置。 当应用程序使用TA_UPDATECP更新当前位置时，`ExtTextOut`将当前位置设置到上一行文本的末尾，或者将当前位置设置到*lpDxWidths*指向的数组的最后一个元素指定的位置，以较大者为准。

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC：：FillPath

关闭当前路径中的任何打开图形，并使用当前画笔和多边形填充模式填充路径的内部。

```
BOOL FillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

填充其内部后，路径将从设备上下文丢弃。

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC：：FillRect

调用此成员函数以使用指定的画笔填充给定的矩形。

```cpp
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含要填充的矩形的逻辑坐标的[RECT](/windows/win32/api/windef/ns-windef-rect)结构。 您还可以为此参数传递[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*pBrush*<br/>
标识用于填充矩形的画笔。

### <a name="remarks"></a>备注

函数填充整个矩形，包括左边框和顶部边框，但它不填充右边框和底部边框。

画笔需要使用[CBrush](../../mfc/reference/cbrush-class.md)成员函数[CreateHatchBrush、CreatePatternBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)创建，或者由`GetStockObject`Windows 函数检索。 [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)

填充指定的矩形时，`FillRect`不包括矩形的右侧和底部。 GDI 填充矩形，最多不超过右列和下一行，而不考虑当前映射模式。 `FillRect`比较`top`指定的`bottom`矩形的值。 `left` `right` 如果`bottom`小于 或等于`top`，或者小于`right`或等于`left`，则不绘制矩形。

`FillRect`类似于[CDC：：FillSolidrect;](#fillsolidrect)但是，`FillRect`使用画笔，因此可用于填充具有纯色、抖红色、阴影画笔或图案的矩形。 `FillSolidRect`仅使用纯色（由 COLORREF 参数指示）。 `FillRect`通常比`FillSolidRect`慢。

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC：：菲尔根

用*pBrush*指定的画笔填充*pRgn*指定的区域。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向要填充的区域的指针。 给定区域的坐标以逻辑单位指定。

*pBrush*<br/>
标识用于填充区域的画笔。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

必须`CBrush`使用成员函数`CreateHatchBrush`、、`CreatePatternBrush``CreateSolidBrush`或 通过`GetStockObject`检索 brush。

### <a name="example"></a>示例

  请参阅[CRgn 的示例：：创建RoundrectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC：：FillSolidrect

调用此成员函数以使用指定的纯色填充给定的矩形。

```cpp
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指定边界矩形（以逻辑单位表示）。 您可以传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)数据结构的指针或此参数`CRect`的对象。

*clr*指定用于填充矩形的颜色。

*x*<br/>
指定矩形左上角的逻辑 x 坐标。

*Y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*残雪*<br/>
指定矩形的宽度。

*cy*<br/>
指定矩形的高度。

### <a name="remarks"></a>备注

`FillSolidRect`与[CDC非常相似：fillrect;](#fillrect)但是，`FillSolidRect`仅使用纯色（由 COLORREF 参数指示），`FillRect`同时使用画笔，因此可用于填充具有纯色、抖红色、阴影画笔或图案的矩形。 `FillSolidRect`通常比 快`FillRect`。

> [!NOTE]
> 调用`FillSolidRect`时，以前使用[SetBkColor](#setbkcolor)设置的背景颜色设置为*clr*指示的颜色。

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC：：扁平路径

将所选路径中的任何曲线转换为当前设备上下文，并将每个曲线转换为一系列直线。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC：：洪水填充

使用当前画笔填充显示表面的区域。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定填充开始点的逻辑 x 坐标。

*Y*<br/>
指定填充开始点的逻辑 y 坐标。

*crColor*<br/>
指定边界的颜色。

### <a name="return-value"></a>返回值

如果函数成功，则非零;否则，如果填充无法完成，则返回 0，给定点具有*crColor*指定的边界颜色，或者该点位于剪切区域之外。

### <a name="remarks"></a>备注

该区域假定为*crColor*指定的边界。 函数`FloodFill`从*x*和*y*指定的点开始，然后以所有方向继续到颜色边界。

只有支持栅格显示技术的内存设备上下文和设备支持`FloodFill`成员功能。 有关RC_BITBLT功能的信息，`GetDeviceCaps`请参阅成员函数。

该`ExtFloodFill`功能提供类似的功能，但更大的灵活性。

## <a name="cdcframerect"></a><a name="framerect"></a>CDC：：帧重新

在*lpRect*指定的矩形周围绘制边框。

```cpp
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含矩形左上角和右下角逻辑坐标的[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 您还可以传递此参数`CRect`的对象。

*pBrush*<br/>
标识用于绘制矩形的画笔。

### <a name="remarks"></a>备注

该函数使用给定的画笔绘制边框。 边框的宽度和高度始终为 1 个逻辑单位。

`bottom`如果矩形的坐标小于或等于`top`，或者小于`right`或等于`left`，则不绘制矩形。

绘制`FrameRect`的边框与`Rectangle`成员函数使用相同的坐标绘制的边框位于同一位置（如果使用`Rectangle`1 个逻辑单位宽的笔）。 矩形的内部不由 填充`FrameRect`。

## <a name="cdcframergn"></a><a name="framergn"></a>CDC：：框架Rgn

使用*pBrush*指定的画笔在*pRgn*指定的区域周围绘制边框。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
指向标识要`CRgn`包含在边框中的区域的对象。 给定区域的坐标以逻辑单位指定。

*pBrush*<br/>
指向标识要`CBrush`用于绘制边框的画笔的对象。

*n 宽度*<br/>
以设备单位表示垂直笔刷描边中的边框宽度。

*nHeight*<br/>
以设备单位表示水平画笔描边中的边框高度。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  请参阅[CRgn 的示例：：合并 Rgn](../../mfc/reference/crgn-class.md#combinergn)。

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC：：从手

当为设备上下文指定`CDC`句柄时，返回指向对象的指针。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
包含 Windows 设备上下文的句柄。

### <a name="return-value"></a>返回值

指针可能是临时的，不应存储超出立即使用的范围。

### <a name="remarks"></a>备注

如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。

### <a name="example"></a>示例

  请参阅[CPrintDialog 的示例：获取 PrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC：：获取Arc方向

返回设备上下文的当前弧方向。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>返回值

指定当前圆弧方向（如果成功）。 以下是有效的返回值：

- AD_COUNTERCLOCKWISE逆时针绘制的弧形和矩形。

- AD_CLOCKWISE顺时针绘制的弧形和矩形。

如果发生错误，则返回值为零。

### <a name="remarks"></a>备注

圆弧和矩形函数使用圆弧方向。

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC：：获取Aspectratio过滤器

检索当前纵横比筛选器的设置。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>返回值

表示`CSize`当前纵横比筛选器使用的纵横比的对象。

### <a name="remarks"></a>备注

纵横比是由设备的像素宽度和高度形成的比。 有关设备的纵横比的信息用于字体的创建、选择和显示。 Windows 提供了一个特殊的筛选器，即纵横比筛选器，用于从所有可用字体中选择针对特定纵横比设计的字体。 筛选器使用`SetMapperFlags`成员函数指定的纵横比。

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC：：GetBkColor

返回当前背景颜色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

RGB 颜色值。

### <a name="remarks"></a>备注

如果背景模式为 OPAQUE，则系统使用背景颜色来填充样式线中的间隙、画笔中阴影线和字符单元格中的背景之间的间隙。 在颜色和单色设备上下文之间转换位图时，系统还使用背景颜色。

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC：：GetBkMode

返回背景模式。

```
int GetBkMode() const;
```

### <a name="return-value"></a>返回值

当前背景模式，可以是 OPAQUE 或 OPAQUE。

### <a name="remarks"></a>备注

背景模式定义在绘制文本、阴影画笔或不是实线的任何笔样式之前，系统是否删除绘图图面上的现有背景颜色。

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC：：获取"界限"

返回指定设备上下文的当前累积边界矩形。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>参数

*lpRectBounds*<br/>
指向将接收当前边界矩形的缓冲区。 矩形以逻辑坐标返回。

*flag*<br/>
指定在返回边界矩形后是否清除边界矩形。 此参数应为零或设置为以下值：

- DCB_RESET 强制返回边界矩形后清除该矩形。

### <a name="return-value"></a>返回值

如果函数成功，则指定边界矩形的当前状态。 它可以是以下值的组合：

- DCB_ACCUMULATE边界矩形累积正在发生。

- DCB_RESET边界矩形为空。

- DCB_SET边界矩形不为空。

- DCB_ENABLE边界累积已打开。

- DCB_DISABLE边界累积已关闭。

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC：：GetBrushOrg

检索当前为设备上下文选择的画笔的原点（以设备单位为单位）。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>返回值

画笔的当前原点（以设备单位为单位）作为[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="remarks"></a>备注

初始画笔原点位于工作区的 （0，0）。 返回值指定相对于桌面窗口的原点的设备单位中的此点。

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC：：获取字符放置

检索字符串上的各种类型的信息。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>参数

*lpString*<br/>
指向要处理的字符串的指针。

*nCount*<br/>
指定字符串的长度。 对于 ANSI 版本，它是 BYTE 计数，对于 Unicode 函数，它是 WORD 计数。 有关详细信息，请参阅[获取角色放置](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)。

*nMax*<br/>
指定处理字符串的最大范围（以逻辑单位为单位）。 如果处理超过此范围的字符将被忽略。 任何必需的排序或字形数组的计算仅适用于包含的字符。 仅当在*dwFlags*参数中指定GCP_MAXEXTENT值时，才使用此参数。 当函数处理输入字符串时，仅当总范围尚未超过最大值时，才会将每个字符及其范围添加到输出、范围和其他数组中。 达到限制后，处理将停止。

*lp结果*<br/>
指向接收函数结果[的GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw)结构的指针。

dwFlags**<br/>
指定如何将字符串处理到所需的数组中。 此参数可以是[Get字符放置](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)主题的*dwFlags*部分中列出的一个或多个值。

*Str*<br/>
指向要处理的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象的指针。

### <a name="return-value"></a>返回值

如果函数成功，则返回值是逻辑单位中字符串的宽度和高度。

如果函数失败，则返回值为零。

### <a name="remarks"></a>备注

此成员函数模拟函数[Get字符放置](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)的功能，如 Windows SDK 中所述。

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC：：获取查布布宽度

从当前 TrueType 字体检索指定范围内的连续字符的宽度。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>参数

*n第一查尔*<br/>
指定当前字体中返回字符宽度的字符范围中的第一个字符。

*nLastChar*<br/>
指定当前字体中返回字符宽度的字符范围中的最后一个字符。

*lpabc*<br/>
指向在函数返回时接收字符宽度的[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)结构数组。 此数组必须包含至少与*nFirstChar 和 nLastChar*参数指定的范围内的字符相同的结构。 *nLastChar* `ABC`

*lpABCF*<br/>
指向应用程序提供的缓冲区，其中包含[ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat)结构数组，以在函数返回时接收字符宽度。 此函数返回的宽度采用 IEEE 浮点格式。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

宽度以逻辑单位返回。 此功能仅使用 TrueType 字体成功。

在选择特定点大小后，TrueType 栅格器提供"ABC"字符间距。 "A"间距是在放置字形之前添加到当前位置的距离。 "B"间距是字形的黑色部分的宽度。 "C"间距添加到当前位置，以考虑字形右侧的空白。 总高级宽度由 A + B + C 给出。

当`GetCharABCWidths`成员函数检索字符的负"A"或"C"宽度时，该字符包括下悬或悬垂。

要将 ABC 宽度转换为字体设计单位，应用程序应创建一个字体，其高度（如`lfHeight`[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)结构成员中指定）等于存储在[NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw)结构`ntmSizeEM`成员中的值。 （可以通过调用`ntmSizeEM`[EnumFont 家庭](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw)窗口功能来检索成员的值。

默认字符的 ABC 宽度用于当前所选字体范围之外的字符。

要检索非 TrueType 字体中的字符宽度，应用程序应使用[GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows 功能。

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC：：获取查拉布·斯波西

检索当前 TrueType 字体中指定范围内的连续字形索引的宽度（以逻辑单位为单位）。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>参数

*吉第一*<br/>
指定当前字体的连续字形索引组中的第一个字形索引。 仅当*pgi*参数为 NULL 时，才使用此参数。

*Cgi*<br/>
指定字形索引的数量。

*pgi*<br/>
指向包含字形索引的数组的指针。 如果值为 NULL，则改为使用*giFirst*参数。 *cgi*参数指定此数组中的字形索引数。

*lpabc*<br/>
指向接收字符宽度的[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)结构数组的指针。 此数组必须包含至少与`ABC`*cgi*参数指定的字形索引相同的结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi)的功能，如 Windows SDK 中所述。

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC：：获取字符宽度

使用 输入`m_hAttribDC`设备上下文从当前字体中检索连续字符组中单个字符的宽度。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>参数

*n第一查尔*<br/>
指定当前字体中连续字符组中的第一个字符。

*nLastChar*<br/>
指定当前字体中连续字符组中的最后一个字符。

*lpBuffer*<br/>
指向将接收当前字体中连续一组字符的宽度值的缓冲区。

*lpFloatBuffer*<br/>
指向缓冲区以接收字符宽度。 返回的宽度为 32 位 IEEE 浮点格式。 （宽度沿字符的基线测量。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识字母"a"，nLastChar 标识字母"z"，则函数将检索所有小写字符的宽度。 *nLastChar*

函数将值存储在*lpBuffer*指向的缓冲区中。 此缓冲区必须足够大，以容纳所有宽度。 也就是说，给定示例中必须至少有 26 个条目。

如果连续字符组中的字符在特定字体中不存在，则将为默认字符的宽度值分配该字符。

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC：：获取字符

从当前字体中检索指定范围内的连续字形索引的宽度（逻辑坐标）。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>参数

*吉第一*<br/>
指定当前字体的连续字形索引组中的第一个字形索引。 仅当*pgi*参数为 NULL 时，才使用此参数。

*Cgi*<br/>
指定字形索引的数量。

*pgi*<br/>
指向包含字形索引的数组的指针。 如果值为 NULL，则改为使用*giFirst*参数。 *cgi*参数指定此数组中的字形索引数。

*lpBuffer*<br/>
指向接收宽度的缓冲区的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetCharWidthI 的功能](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi)，如 Windows SDK 中所述。

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC：：获取剪辑盒

检索当前剪切边界周围最紧密边界矩形的尺寸。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向接收矩形尺寸的[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="return-value"></a>返回值

裁剪区域的类型。 可以是以下任一值：

- 复杂区域剪切区域具有重叠边框。

- 错误设备上下文无效。

- NULL 区域剪切区域为空。

- SIMPLE 区域剪切区域没有重叠边框。

### <a name="remarks"></a>备注

维度复制到*lpRect*指向的缓冲区。

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC：：获取颜色调整

检索设备上下文的颜色调整值。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>参数

*lpColorAdjust*<br/>
指向[COLOR 调整](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)数据结构以接收颜色调整值。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC：：获取当前位图

返回指向当前选定`CBitmap`对象的指针。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>返回值

指针指向`CBitmap`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

此成员函数可以返回临时对象。

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC：：获取当前画笔

返回指向当前选定`CBrush`对象的指针。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>返回值

指针指向`CBrush`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

此成员函数可以返回临时对象。

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC：：获取当前字体

返回指向当前选定`CFont`对象的指针。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>返回值

指针指向`CFont`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

此成员函数可以返回临时对象。

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC：：获取电流调色板

返回指向当前选定`CPalette`对象的指针。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>返回值

指针指向`CPalette`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

此成员函数可以返回临时对象。

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC：：获取电流笔

返回指向当前选定`CPen`对象的指针。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>返回值

指针指向`CPen`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

此成员函数可以返回临时对象。

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC：获取电流位置

检索当前位置（在逻辑坐标中）。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>返回值

作为`CPoint`对象的当前位置。

### <a name="remarks"></a>备注

可以使用`MoveTo`成员函数设置当前位置。

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC：：获取DCBrush颜色

检索当前画笔的颜色。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>返回值

如果函数成功，则返回值是当前画笔颜色的[COLORREF](/windows/win32/gdi/colorref)值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)的功能，如 Windows SDK 中所述。

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC：：获取DCPenColor

检索当前的钢笔颜色。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>返回值

如果函数成功，则返回值是当前笔颜色的[COLORREF](/windows/win32/gdi/colorref)值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[GetDCPenColor，](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)如 Windows SDK 中所述。

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC：获取设备Caps

检索有关显示设备的各种特定于设备的信息。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>参数

*nIndex*<br/>
指定要返回的信息类型。 有关值列表，请参阅 Windows SDK 中的[GetDeviceCaps。](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps)

### <a name="return-value"></a>返回值

如果函数成功，则请求的功能的值。

### <a name="example"></a>示例

  请参阅[CPrintDialog 示例：获取默认值](../../mfc/reference/cprintdialog-class.md#getdefaults)。

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC：：获取字体数据

从可扩展的字体文件中检索字体度量信息。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>参数

*dwTable*<br/>
指定要返回的指标表的名称。 此参数可以是 Microsoft 公司发布的 TrueType 字体文件规范中记录的指标表之一。 如果此参数为 0，则从字体文件的开头开始检索信息。

*dwOffset*<br/>
指定开始检索信息的表开头的偏移量。 如果此参数为 0，则从*dwTable*参数指定的表的开头开始检索信息。 如果此值大于或等于表的大小，`GetFontData`则返回 0。

*lpData*<br/>
指向将接收字体信息的缓冲区。 如果此值为 NULL，则函数将返回*dwTable*参数中指定的字体数据所需的缓冲区大小。

*cbData*<br/>
指定要检索的信息的长度（以字节为单位）。 如果此参数为 0，`GetFontData`则返回*dwTable*参数中指定的数据的大小。

### <a name="return-value"></a>返回值

指定在函数成功时*由 lpData*指向的缓冲区中返回的字节数;否则 -1。

### <a name="remarks"></a>备注

通过指定要检索的信息在字体文件中指定偏移量和要返回的信息长度来标识。

应用程序有时可以使用`GetFontData`成员函数将 TrueType 字体与文档一起保存。 为此，应用程序确定是否可以嵌入字体，然后检索整个字体文件，为*dwTable、dwOffset*和*cbData*参数指定*dwOffset*0。

应用程序可以通过检查`otmfsType`[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)结构的成员来确定是否可以嵌入字体。 如果设置了 bit `otmfsType` 1，则不允许对字体进行嵌入。 如果位 1 清晰，则可以嵌入字体。 如果设置了位 2，则嵌入为只读。

如果应用程序尝试使用此函数检索非 TrueType 字体的信息，则`GetFontData`成员函数返回 -1。

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC：：获取字体语言信息

返回有关指定显示上下文的当前选定字体的信息。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>返回值

返回值标识当前所选字体的特征。 有关可能值的完整列表，请参阅[GetFont 语言信息](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)。

### <a name="remarks"></a>备注

此成员函数模拟了[GetFont 语言信息](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)功能的功能，如 Windows SDK 中所述。

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC：获取字形图

检索当前字体中轮廓字符的轮廓曲线或位图。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>参数

*n查尔*<br/>
指定要为其返回信息的字符。

*nFormat*<br/>
指定函数在其中返回信息的格式。 它可以是以下值之一，也可以是 0：

|“值”|含义|
|-----------|-------------|
|GGO_BITMAP|返回字形位图。 当函数返回时 *，lpBuffer*指向的缓冲区包含一个 1 位/像素位图，其行以双字边界开始。|
|GGO_NATIVE|使用设备单位返回栅格器本机格式的曲线数据点。 指定此值时，将忽略*lpmat2*中指定的任何转换。|

当*nFormat*的值为 0 时，函数填充[GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics)结构，但不会返回字形轮廓数据。

*lpgm*<br/>
指向描述字形在字符单元格中的位置的 GLYPHMETRICS 结构。

*cbBuffer*<br/>
指定函数将有关大纲字符的信息复制到的缓冲区大小。 如果此值为 0，并且*nFormat*参数是GGO_BITMAP或GGO_NATIVE值，则函数将返回缓冲区所需的大小。

*lpBuffer*<br/>
指向函数将有关大纲字符的信息复制到的缓冲区。 如果*nFormat*指定GGO_NATIVE值，则信息将采用 TTPOLYGONHEADER 和 TTPOLYCURVE 结构的形式复制。 如果此值为 NULL，并且*nFormat*是GGO_BITMAP或GGO_NATIVE值，则函数将返回缓冲区所需的大小。

*lpmat2*<br/>
指向包含字符转换矩阵的[MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2)结构。 此参数不能为 NULL，即使为*nFormat*指定了GGO_NATIVE值 。

### <a name="return-value"></a>返回值

如果*cbBuffer*为 0 或*lpBuffer*为 NULL，则检索信息所需的缓冲区的大小（以字节为单位）。 否则，如果函数成功，则为正值;如果出现错误，则为 -1。

### <a name="remarks"></a>备注

应用程序可以通过在*lpmat2*指向的结构中指定 2×2 变换矩阵来旋转以位图格式检索的字符。

字形轮廓作为一系列轮廓返回。 每个轮廓由[TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)结构定义，后面跟着`TTPOLYCURVE`描述它所需的结构。 所有点都返回为[POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx)结构，表示绝对位置，而不是相对移动。 [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) `pfxStart`结构成员给出的起始点是轮廓轮廓开始的点。 后面可采用[的 TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve)结构可以是折线记录或样条线记录。 折线记录是一系列点;点之间绘制的线条描述字符的轮廓。 样条线记录表示 TrueType（即二次 b 样条线）使用的二次曲线。

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC：：获取图形模式

检索指定设备上下文的当前图形模式。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>返回值

成功时返回当前图形模式。 有关此方法可以返回的值的列表，请参阅[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

失败后返回 0。

要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC：：获取哈弗通刷

调用此成员函数以检索半色调画笔。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>返回值

指向`CBrush`对象的指针（如果成功）;如果成功，则指向对象。否则 NULL。

### <a name="remarks"></a>备注

半色调画笔显示交替前景和背景颜色以创建抖除图案的像素。 下面是由半色调画笔创建的抖红色图案的示例。

![抖动钢笔笔画详细信息](../../mfc/reference/media/vc318s1.gif "抖动钢笔笔画详细信息")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC：：获取凯宁配对

检索当前在指定设备上下文中选择的字体的字符角对。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>参数

*n配对*<br/>
指定*由 lpkrnpair*指向的[KERningPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair)结构的数量。 函数不会复制比*nPairs*指定的更多的角对。

*lpkrnpair*<br/>
指向在函数返回时`KERNINGPAIR`接收角线对的结构数组。 此数组必须包含至少与*nPairs*指定的相同多个结构。 如果此参数为 NULL，则函数将返回字体的字距对总数。

### <a name="return-value"></a>返回值

指定检索的角线对数或字体中的字角对总数（如果函数成功）。 如果函数失败或字体没有角线对，则返回零。

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC：：获取布局

调用此成员函数以确定设备上下文（如打印机或元文件）的文本和图形的布局。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>返回值

如果成功，则当前设备上下文的布局标志。 否则，GDI_ERROR。 有关扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。 有关布局标志的列表，请参阅[CDC：：SetLayout](#setlayout)。

### <a name="remarks"></a>备注

默认布局从左到右。

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC：：获取地图模式

检索当前映射模式。

```
int GetMapMode() const;
```

### <a name="return-value"></a>返回值

映射模式。

### <a name="remarks"></a>备注

有关映射模式的说明，请参阅`SetMapMode`成员函数。

> [!NOTE]
> 如果调用[SetLayout](#setlayout)将 DC 更改为从右到左布局，`SetLayout`则自动将映射模式更改为MM_ISOTROPIC。 因此，任何后续调用`GetMapMode`都将返回MM_ISOTROPIC。

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC：：获取限制

返回设备上下文的斜接限制。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

绘制具有斜接连接的几何线时，使用斜接限制。

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC：获取最接近的颜色

返回与指定逻辑颜色最匹配的纯色。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定要匹配的颜色。

### <a name="return-value"></a>返回值

RGB（红色、绿色、蓝色）颜色值，用于定义最接近设备可以表示的*crColor*值的纯色。

### <a name="remarks"></a>备注

给定的设备必须能够表示此颜色。

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC：：获取大纲文本指标

检索 TrueType 字体的指标信息。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>参数

*lpotm*<br/>
指向一系列[OUTLINETEXTMETRIC 结构](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)。 如果此参数为 NULL，则函数将返回检索的指标数据所需的缓冲区大小。

*cbData*<br/>
指定返回信息的缓冲区的大小（以字节为单位）。

*lpotm*<br/>
指向结构`OUTLINETEXTMETRIC`。 如果此参数为 NULL，则函数将返回检索的指标信息所需的缓冲区大小。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)结构包含 TrueType 格式提供的大部分字体度量信息，包括[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。 `OUTLINETEXTMETRIC`结构的最后四个成员是指向字符串的指针。 除了其他成员所需的空间外，应用程序还应为这些字符串分配空间。 由于字符串的大小没有系统施加的限制，因此分配内存的最简单方法是通过在函数`GetOutlineTextMetrics`的第一次调用中指定*lpotm*的 NULL 来检索所需的大小。

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC：：获取输出字符宽度

使用输出设备上下文 ，`m_hDC`并从当前字体中检索连续字符组中各个字符的宽度。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>参数

*n第一查尔*<br/>
指定当前字体中连续字符组中的第一个字符。

*nLastChar*<br/>
指定当前字体中连续字符组中的最后一个字符。

*lpBuffer*<br/>
指向将接收当前字体中连续一组字符的宽度值的缓冲区。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识字母"a"，nLastChar 标识字母"z"，则函数将检索所有小写字符的宽度。 *nLastChar*

函数将值存储在*lpBuffer*指向的缓冲区中。 此缓冲区必须足够大，以容纳所有宽度;因此，此缓冲区必须足够大，以容纳所有宽度。也就是说，给定示例中必须至少有 26 个条目。

如果连续字符组中的字符在特定字体中不存在，则将为默认字符的宽度值分配该字符。

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC：：获取输出标签文本范围

调用此成员函数，使用输出设备上下文[m_hDC](#m_hdc)计算字符字符串的宽度和高度。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向要测量的字符串。 您还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向[的字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTab*<br/>
指定*lpnTabStop定位*指向的数组中的制表位数。

*lpnTabStop位置*<br/>
指向包含逻辑单位中的制表位的整数数组。 必须按增加的顺序对制表位进行排序;最小的 x 值应该是数组中的第一个项。 不允许返回选项卡。

*Str*<br/>
包含`CString`要测量的指定字符的对象。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串（以逻辑单位为单位）的尺寸。

### <a name="remarks"></a>备注

如果字符串包含一个或多个选项卡字符，则字符串的宽度基于*lpnTabStop定位*指定的制表位。 该函数使用当前选择的字体计算字符串的尺寸。

当前裁剪区域不会偏移函数返回的`GetOutputTabbedTextExtent`宽度和高度。

由于某些设备不将字符放置在常规单元格数组中（即它们与字符一起），因此字符串中字符的范围和可能与字符串的范围不相等。

如果*nTabPositions*为 0，*并且 lpnTabStop定位*为 NULL，则选项卡将扩展到八个平均字符宽度。 如果*nTabPoints 为*1，则制表位将由*lpnTabStopPoints*点指向的数组中第一个值指定的距离分隔。 如果*lpnTabStopPositions*指向多个值，则为数组中的每个值设置一个制表位，最多为*nTabPoints*指定的数字。

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC：：获取输出文本范围

调用此成员函数使用输出设备上下文[，m_hDC，](#m_hdc)并使用当前字体计算文本行的宽度和高度。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符串。 您还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向[的字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*Str*<br/>
包含`CString`要测量的指定字符的对象。

### <a name="return-value"></a>返回值

在[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中返回的字符串的尺寸（以逻辑单位为单位）。

### <a name="remarks"></a>备注

当前裁剪区域不会影响 返回的`GetOutputTextExtent`宽度和高度。

由于某些设备不将字符放置在常规单元格数组中（即它们执行角线），因此字符串中字符的范围和可能与字符串的范围不相等。

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC：获取输出文本指标

使用 检索当前字体的指标，输出`m_hDC`设备上下文。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>参数

*lpMetrics*<br/>
指向接收指标的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC：获取路径

检索定义行端点的坐标以及选择到设备上下文中的路径中找到的曲线的控制点。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向放置线端点[POINT](/windows/win32/api/windef/ns-windef-point)和曲线控制点的`CPoint`POINT 数据结构或对象数组。

*lpType*<br/>
指向放置顶点类型的字节数组。 值是以下值之一：

- PT_MOVETO 指定*lpPoints*中的相应点启动不相交的数字。

- PT_LINETO 指定*lpPoints*中的前一个点和相应的点是行的终结点。

- PT_BEZIERTO 指定*lpPoints*中的相应点是 Bzier 曲线的控制点或结束点。

PT_BEZIERTO类型始终以三组的形式出现。 紧接路径中的点定义 Bzier 曲线的起点。 前两个PT_BEZIERTO点是控制点，第三个PT_BEZIERTO点是终点（如果用硬编码）。

   PT_LINETO或PT_BEZIERTO类型可与以下标志（通过使用位运算符**OR**）组合，以指示相应的点是图中的最后一个点，并且图形应关闭：

- PT_CLOSEFIGURE 指定绘制相应的线或曲线后，图形将自动关闭。 通过从直线或曲线端点绘制一条线到与最后一个PT_MOVETO对应的点来关闭图形。

*nCount*<br/>
指定可放置在*lpPoints*数组中的[POINT](/windows/win32/api/windef/ns-windef-point)数据结构的总数。 此值必须与可能放置在*lpType*数组中的字节数相同。

### <a name="return-value"></a>返回值

如果*nCount*参数是非零，则枚举的点数。 如果*nCount*为 0，则路径中的点总数（不`GetPath`写入缓冲区）。 如果*nCount*是非零且小于路径中的点数，则返回值为 -1。

### <a name="remarks"></a>备注

设备上下文必须包含闭合路径。 路径的点以逻辑坐标返回。 点存储在设备坐标中的路径中，因此`GetPath`使用当前变换的逆向将点从设备坐标更改为逻辑坐标。 可以在`FlattenPath`之前`GetPath`调用成员函数，以将路径中的所有曲线转换为线段。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：开始路径](#beginpath)。

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC：获取像素

检索*x*和*y*指定的点的像素的 RGB 颜色值。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>参数

*x*<br/>
指定要检查的点的逻辑 x 坐标。

*Y*<br/>
指定要检查的点的逻辑 y 坐标。

*点*<br/>
指定要检查的点的逻辑 x 和 y 坐标。

### <a name="return-value"></a>返回值

对于函数的任一版本，给定点颜色的 RGB 颜色值。 如果坐标未指定剪切区域中的点，则为 -1。

### <a name="remarks"></a>备注

该点必须位于剪切区域中。 如果点不在剪切区域中，则函数不起作用，返回 -1。

不是所有的设备都支持 `GetPixel` 函数。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数下的RC_BITBLT栅格功能。

成员`GetPixel`函数有两种形式。 第一个采用两个坐标值;第二个使用坐标值。第二个对象是[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC：：获取多利填充模式

检索当前多边形填充模式。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>返回值

如果函数成功，则当前多边形填充模式（ALTERNATE 或 WINDING）。

### <a name="remarks"></a>备注

有关多边`SetPolyFillMode`形填充模式的说明，请参阅成员函数。

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC：GetROP2

检索当前绘图模式。

```
int GetROP2() const;
```

### <a name="return-value"></a>返回值

绘图模式。 有关绘图模式值的列表，`SetROP2`请参阅成员函数。

### <a name="remarks"></a>备注

绘图模式指定笔的颜色和填充对象的内部如何与显示表面上已有的颜色组合。

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC：：获取安全Hdc

调用此成员函数以获取[输出设备上下文m_hDC。](#m_hdc)

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>返回值

设备上下文句柄。

### <a name="remarks"></a>备注

此成员函数也适用于空指针。

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC：：获取拉伸模式

检索当前位图拉伸模式。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>返回值

如果函数成功，返回值指定当前位图拉伸模式（STRETCH_ANDSCANS、STRETCH_DELETESCANS或STRETCH_ORSCANS）。

### <a name="remarks"></a>备注

位图拉伸模式定义如何从`StretchBlt`成员函数拉伸或压缩的位图中删除信息。

STRETCH_ANDSCANS和STRETCH_ORSCANS模式通常用于在单色位图中保留前景像素。 STRETCH_DELETESCANS模式通常用于在颜色位图中保留颜色。

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC：：获取标签文本范围

调用此成员函数，使用属性设备上下文[m_hAttribDC](#m_hattribdc)计算字符串的宽度和高度。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符串。 您还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向[的字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTab*<br/>
指定*lpnTabStop定位*指向的数组中的制表位数。

*lpnTabStop位置*<br/>
指向包含逻辑单位中的制表位的整数数组。 必须按增加的顺序对制表位进行排序;最小的 x 值应该是数组中的第一个项。 不允许返回选项卡。

*Str*<br/>
包含`CString`要绘制的指定字符的对象。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串（以逻辑单位为单位）的尺寸。

### <a name="remarks"></a>备注

如果字符串包含一个或多个选项卡字符，则字符串的宽度基于*lpnTabStop定位*指定的制表位。 该函数使用当前选择的字体计算字符串的尺寸。

当前裁剪区域不会偏移函数返回的`GetTabbedTextExtent`宽度和高度。

由于某些设备不将字符放置在常规单元格数组中（即它们与字符一起），因此字符串中字符的范围和可能与字符串的范围不相等。

如果*nTabPositions*为 0，*并且 lpnTabStopPositions*为 NULL，则选项卡将扩展到平均字符宽度的八倍。 如果*nTabPoints 为*1，则制表位将由*lpnTabStopPoints*点指向的数组中第一个值指定的距离分隔。 如果*lpnTabStopPositions*指向多个值，则为数组中的每个值设置一个制表位，最多为*nTabPoints*指定的数字。

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC：：获取文本对齐

检索设备上下文的文本对齐标志的状态。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>返回值

文本对齐标志的状态。 返回值是以下一个或多个值：

- TA_BASELINE 指定 x 轴和边界矩形内所选字体的基线对齐。

- TA_BOTTOM指定 x 轴和边界矩形底部的对齐方式。

- TA_CENTER指定 y 轴和边界矩形的中心对齐。

- TA_LEFT指定边界矩形的 y 轴和左侧的对齐方式。

- TA_NOUPDATECP 指定当前位置未更新。

- TA_RIGHT指定边界矩形的 y 轴和右侧的对齐方式。

- TA_TOP指定 x 轴和边界矩形顶部的对齐方式。

- TA_UPDATECP 指定更新当前位置。

### <a name="remarks"></a>备注

文本对齐标志确定 和`TextOut``ExtTextOut`成员函数如何相对于字符串的起始点对齐文本字符串。 文本对齐标志不一定是单位标志，可能等于 0。 要测试是否设置了标志，应用程序应遵循以下步骤：

1. 将位或运算符应用于标志及其相关标志，分组如下：

   - TA_LEFT、TA_CENTER和TA_RIGHT

   - TA_BASELINE、TA_BOTTOM和TA_TOP

   - TA_NOUPDATECP和TA_UPDATECP

1. 将位-AND 运算符应用于 结果和 返回`GetTextAlign`值。

1. 测试此结果和标志的相等性。

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC：：获取文本字符额外

检索字符间间距量的当前设置。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>返回值

字符间距的量。

### <a name="remarks"></a>备注

GDI 向每个字符（包括中断字符）向设备上下文写入文本行时，都会将此间距添加到其中。

字符间间距量的默认值为 0。

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC：：获取文本颜色

检索当前文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

当前文本颜色作为 RGB 颜色值。

### <a name="remarks"></a>备注

文本颜色是使用 GDI 文本输出成员函数[TextOut、ExtTextOut](#exttextout)和[TextOut](#textout)[TabbedTextOut](#tabbedtextout)绘制的字符的前景颜色。

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC：：获取文本范围

调用此成员函数，使用当前字体计算文本行的宽度和高度，以确定尺寸。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>参数

*lpszString*<br/>
指向字符串。 您还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定字符串中的字符数。

*Str*<br/>
包含`CString`指定字符的对象。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串（以逻辑单位为单位）的尺寸。

### <a name="remarks"></a>备注

从属性设备上下文[m_hAttribDC](#m_hattribdc)检索信息。

默认情况下，`GetTextExtent`假定它检索维度的文本沿水平线设置（即转义为 0）。 如果创建指定非零转义的字体，则必须显式转换文本的角度以获取字符串的尺寸。

当前裁剪区域不会影响 返回的`GetTextExtent`宽度和高度。

由于某些设备不将字符放置在常规单元格数组中（即它们执行角线），因此字符串中字符的范围和可能与字符串的范围不相等。

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC：：获取文本范围ExPointI

检索指定字符串中将适合指定空间的字符数，并为每个字符填充文本范围的数组。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*pgiIn*<br/>
指向要检索范围的字形索引数组的指针。

*Cgi*<br/>
指定*pgiIn*指向的数组中的字形数。

*nMax*<br/>
指定格式化字符串的最大允许宽度（逻辑单位）。

*lpnFit*<br/>
指向整数的指针，该整数接收将适合*nMaxA.* 指定的空间的最大字符数计数。 当*lpnFit*为 NULL 时 *，nMax 范围*将被忽略。

*阿尔普德克斯*<br/>
指向接收部分字形范围的整数数组的指针。 数组中的每个元素以逻辑单位为单位，提供字形索引数组的开头与适合*nMaxA.* 指定的空间的字形之一之间的距离。 尽管此数组应至少具有*与 cgi*指定的字形索引相同的元素，但函数仅为*lpnFit*指定的字形索引填充范围。 如果*lpnDx*为 NULL，则函数不计算部分字符串宽度。

*lpSize*<br/>
指向以逻辑单位接收字形索引数组尺寸的[SIZE](/windows/win32/api/windef/ns-windef-size)结构的指针。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetText范围ExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)的功能，如 Windows SDK 中所述。

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC：获取文本范围点I

检索指定字形索引数组的宽度和高度。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*pgiIn*<br/>
指向要检索范围的字形索引数组的指针。

*Cgi*<br/>
指定*pgiIn*指向的数组中的字形数。

*lpSize*<br/>
指向以逻辑单位接收字形索引数组尺寸的[SIZE](/windows/win32/api/windef/ns-windef-size)结构的指针。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetText范围PointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi)的功能，如 Windows SDK 中所述。

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC：：获取文本面

调用此成员函数将当前字体的字体名称复制到缓冲区中。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>参数

*nCount*<br/>
指定缓冲区的大小（以字节为单位）。 如果字体名称长于此参数指定的字节数，则该名称将被截断。

*lpszFace名称*<br/>
指向字体名称的缓冲区。

*rString*<br/>
对[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象的引用。

### <a name="return-value"></a>返回值

复制到缓冲区的字节数，不包括终止空字符。 如果发生错误，为 0。

### <a name="remarks"></a>备注

字体名称复制为 null 终止字符串。

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC：：获取文本指标

使用属性设备上下文检索当前字体的指标。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>参数

*lpMetrics*<br/>
指向接收指标的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC：：获取查看端口Ext

检索设备上下文视口的 x 和 y 范围。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>返回值

x 和 y 范围（以设备单位为单位）作为`CSize`对象。

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC：：获取查看端口组织

检索与设备上下文关联的视口源的 x 和 y 坐标。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>返回值

视口（在设备坐标中）作为`CPoint`对象的起源。

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC：：获取窗口

返回与显示设备上下文关联的窗口。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>返回值

指针指向`CWnd`对象（如果成功）;否则 NULL。

### <a name="remarks"></a>备注

这是一个高级函数。 例如，此成员函数在打印或打印预览时可能无法返回视图窗口。 它始终返回与输出关联的窗口。 使用给定 DC 的输出函数绘制到此窗口。

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC：：获取窗口Ext

检索与设备上下文关联的窗口的 x 和 y 范围。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>返回值

x-和 y-范围（以逻辑单位为单位）作为`CSize`对象。

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC：：获取窗口组织

检索与设备上下文关联的窗口源的 x 和 y 坐标。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>返回值

窗口（在逻辑坐标中）作为`CPoint`对象的原点。

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC：：获取世界转型

检索当前世界空间到页面空间转换。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>参数

*rXform*<br/>
引用接收当前世界空间到页面空间转换的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构。

### <a name="return-value"></a>返回值

返回成功时的非零值。

失败后返回 0。

要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)。

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC：：梯度填充

调用此成员函数以填充矩形和三角形结构，其颜色从一侧平滑淡入另一侧。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>参数

*pVertices*<br/>
指向[TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex)结构数组的指针，每个结构定义三角形顶点。

*nVertices*<br/>
顶点数。

*pMesh*<br/>
三角形模式下[GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle)结构数组，或矩形模式下[GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect)结构数组。

*nMesh元素*<br/>
*pMesh*中的元素数（三角形或矩形）

*dwMode*<br/>
指定渐变填充模式。 有关可能值的列表，请参阅 Windows SDK 中的[渐变填充](/windows/win32/api/wingdi/nf-wingdi-gradientfill)。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅`GradientFill`Windows SDK。

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC：：灰色字符串

通过在内存位图中写入文本、调暗位图，然后将位图复制到显示屏，在给定位置绘制变暗（灰色）文本。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*pBrush*<br/>
标识用于调光（灰色）的画笔。

*lpfn输出*<br/>
指定将绘制字符串的应用程序提供的回调函数的过程实例地址。 有关详细信息，请参阅 Windows `OutputFunc` [回调函数](callback-functions-used-by-mfc.md#graystring)的说明。 如果此参数为 NULL，则系统使用`TextOut`Windows 函数绘制字符串，并且*假定 lpData*是指向要输出的字符串的长指针。

*lpData*<br/>
指定要传递给输出函数的数据的远指针。 如果*lpfnOutput*为 NULL，*则 lpData*必须是指向要输出的字符串的长指针。

*nCount*<br/>
指定要输出的字符数。 如果此参数为 0，`GrayString`则计算字符串的长度（假设*lpData*是指向字符串的指针）。 如果*nCount*为 1，并且*lpfnOutput*指向的功能返回 0，则显示图像但不变暗。

*x*<br/>
指定包含字符串的矩形起始位置的逻辑 x 坐标。

*Y*<br/>
指定包含字符串的矩形起始位置的逻辑 y 坐标。

*n 宽度*<br/>
指定包含字符串的矩形的宽度（以逻辑单位为单位）。 如果*nWidth*为`GrayString`0，则计算区域的宽度，假设*lpData*是指向字符串的指针。

*nHeight*<br/>
指定包含字符串的矩形的高度（以逻辑单位为单位）。 如果*nHeight*为`GrayString`0，则计算区域的高度，假设*lpData*是指向字符串的指针。

### <a name="return-value"></a>返回值

如果绘制字符串，则为非零;如果`TextOut`函数或应用程序提供的输出函数返回 0，或者内存不足以创建用于调光的内存位图，则为 0。

### <a name="remarks"></a>备注

无论所选画笔和背景如何，该函数都会使文本变暗。 成员`GrayString`函数使用当前选定的字体。 在使用此函数之前，必须选择MM_TEXT映射模式。

应用程序可以在支持纯灰色设备上绘制灰色（灰色）字符串，而无需调用`GrayString`成员函数。 系统颜色COLOR_GRAYTEXT是用于绘制禁用文本的纯灰色系统颜色。 应用程序可以调用`GetSysColor`Windows 函数来检索COLOR_GRAYTEXT的颜色值。 如果颜色为 0（黑色），则应用程序可以调用`SetTextColor`成员函数将文本颜色设置为颜色值，然后直接绘制字符串。 如果检索到的颜色为黑色，则应用程序必须调用`GrayString`淡（灰色）文本。

如果*lpfnOutput*为 NULL，则 GDI 使用 Windows [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw)函数，并且*假定 lpData*是指向要输出的字符的远指针。 如果`TextOut`要输出的字符不能由成员函数处理（例如，字符串存储为位图），则应用程序必须提供其自己的输出函数。

另请注意，所有回调函数在返回到 Windows 之前都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章["例外](../../mfc/exception-handling-in-mfc.md)"。

传递给 的回调函数`GrayString`必须使用`__stdcall`调用约定，并且必须随`__declspec`导出。

当框架处于预览模式时，对成员函数的`GrayString`调用将转换为`TextOut`调用，并且不调用回调函数。

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC：：HIMETRITtoDP

将 HIMETRIC 大小从 OLE 转换为像素时，请使用此功能。

```cpp
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[SIZE](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC或MM_HIMETRIC，则转换基于物理英寸中的像素数。 如果映射模式是其他非约束模式之一（例如，MM_TEXT），则转换基于逻辑英寸中的像素数。

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC：：HIMETRICTOLP

调用此函数可将 HIMETRIC 单元转换为逻辑单位。

```cpp
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向[SIZE](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

当您从 OLE 获取 HIMETRIC 大小并希望将它们转换为应用程序的自然映射模式时，请使用此功能。

转换首先将 HIMETRIC 单位转换为像素，然后使用这些单元转换为逻辑单位，使用设备上下文的当前映射单元来实现。 请注意，设备窗口和视口的范围将影响结果。

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC：：相交剪辑

通过形成当前区域的交集和*x1、y1、x2*和*y2*指定的*x2*矩形，创建新的裁剪区域。 *y1*

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形右下角的逻辑 y 坐标。

*lpRect*<br/>
指定矩形。 可以传递`CRect`对象或指针到此参数`RECT`的结构。

### <a name="return-value"></a>返回值

新裁剪区域的类型。 它可以是以下任一值：

- 复杂区域 新裁剪区域具有重叠边框。

- 错误设备上下文无效。

- NULL 区域 新剪切区域为空。

- SIMPLE区域 新剪切区域没有重叠边框。

### <a name="remarks"></a>备注

GDI 夹夹所有后续输出以适合新边界。 宽度和高度不得超过 32，767。

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC：：反逆转

反转给定矩形的内容。

```cpp
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向 包含`RECT`要反转的矩形的逻辑坐标的 。 您还可以传递此参数`CRect`的对象。

### <a name="remarks"></a>备注

反转是一个逻辑的 NOT 操作，并翻转每个像素的位。 在单色显示屏上，该功能使白色像素为黑色和黑色像素为白色。 在颜色显示上，反转取决于如何为显示器生成颜色。 使用`InvertRect`同一矩形调用两次会将显示还原到其以前的颜色。

如果矩形为空，则不绘制任何内容。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC：：反逆

反转*pRgn*指定的区域中的颜色。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要反转的区域。 区域的坐标以逻辑单位指定。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

在单色显示屏上，该功能使白色像素为黑色和黑色像素为白色。 在颜色显示上，反转取决于如何为显示器生成颜色。

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC：：正在打印

确定设备上下文是否用于打印。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>返回值

如果对象是打印机`CDC`DC，则非零;否则 0。

## <a name="cdclineto"></a><a name="lineto"></a>CDC：：线到

从当前位置绘制一条线，然后绘制*x*和*y（* 或点）指定的点，但不包括该*点*。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定行的终结点的逻辑 x 坐标。

*Y*<br/>
指定行端点的逻辑 y 坐标。

*点*<br/>
指定行的终结点。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

绘制线时非零;否则 0。

### <a name="remarks"></a>备注

线条使用所选笔绘制。 当前位置设置为*x* *、y*或*指向*。

### <a name="example"></a>示例

  请参阅[CRect：：中心点](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的示例。

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC：LPtoDP

将逻辑单位转换为设备单元。

```cpp
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向一组点。 数组中的每个点是[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*nCount*<br/>
数组中的点数。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于将矩形从逻辑单位映射到设备单元的常见情况。

*lpSize*<br/>
指向[SIZE](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

该函数将每个点的坐标或大小的尺寸从 GDI 的逻辑坐标系映射到设备坐标系。 转换取决于当前映射模式以及设备窗口和视口的源和范围的设置。

点的 x 坐标和 y 坐标是 -32，768 到 32，767 范围内的 2 字节签名整数。 如果映射模式将导致大于这些限制的值，系统将值分别设置为 -32，768 和 32，767。

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC：LPtoHIMETRIC

调用此函数可将逻辑单位转换为 HIMETRIC 单位。

```cpp
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>参数

*lpSize*<br/>
指向`SIZE`结构或`CSize`对象。

### <a name="remarks"></a>备注

将 HIMETRIC 大小转换为 OLE 时，请使用此功能，该大小将从应用程序的自然映射模式进行转换。 请注意，设备窗口和视口的范围将影响结果。

转换首先使用设备上下文的当前映射单元将逻辑单位转换为像素，然后将这些单元转换为 HIMETRIC 单位来实现。

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC：：m_hAttribDC

此`CDC`对象的属性设备上下文。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>备注

默认情况下，此设备上下文等于`m_hDC`。 通常，`CDC`请求设备上下文中信息的 GDI 调用将定向到`m_hAttribDC`。 有关使用这两个设备上下文的更多内容，请参阅[CDC](../../mfc/reference/cdc-class.md)类说明。

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC：：m_hDC

此`CDC`对象的输出设备上下文。

```
HDC m_hDC;
```

### <a name="remarks"></a>备注

默认情况下，`m_hDC`等于`m_hAttribDC``CDC` 通常，`CDC`创建输出的 GDI 调用转到`m_hDC`设备上下文。 您可以初始化和`m_hDC``m_hAttribDC`指向不同的设备。 有关使用这两个设备上下文的更多内容，请参阅[CDC](../../mfc/reference/cdc-class.md)类说明。

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC：：MaskBlt

使用给定蒙版和栅格操作组合源和目标位图的颜色数据。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*Y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*n 宽度*<br/>
指定目标矩形和源位图的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定目标矩形和源位图的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
标识从中复制位图的设备上下文。 如果*dwRop*参数指定不包含源的栅格操作，则它必须为零。

*xSrc*<br/>
指定源位图左上角的逻辑 x 坐标。

*伊斯尔克*<br/>
指定源位图左上角的逻辑 y 坐标。

*掩码位图*<br/>
标识单色蒙版位图与源设备上下文中的颜色位图相结合。

*x蒙斯*<br/>
指定*蒙版Bitmap*参数指定的蒙版位图的水平像素偏移量。

*yMask*<br/>
指定*蒙版Bitmap*参数指定的蒙版位图的垂直像素偏移量。

*dwRop*<br/>
指定前景和后台三元栅格操作代码，该代码用于控制源和目标数据的组合。 后台栅格操作代码存储在此值的高字的高字节中;前景栅格操作代码存储在此值的高字的低字节中;此值的低字将被忽略，并且应为零。 宏 MAKEROP4 创建前景和后台栅格操作代码的组合。 有关此功能上下文中的前景和背景的讨论，请参阅备注部分。 有关常见`BitBlt`栅格操作代码的列表，请参阅成员函数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*掩码Bitmap*指定的掩码中的值 1 表示*dwRop*指定的前景栅格操作代码应应用于该位置。 掩码中的值为 0 表示*dwRop*指定的后台栅格操作代码应应用于该位置。 如果栅格操作需要源，蒙版矩形必须覆盖源矩形。 如果没有，则函数将失败。 如果栅格操作不需要源，则蒙版矩形必须覆盖目标矩形。 如果没有，则函数将失败。

如果在调用此函数时源设备上下文的旋转或剪切转换有效，则会发生错误。 但是，允许其他类型的转换。

如果源、图案和目标位图的颜色格式不同，此函数将转换模式或源格式，或两者匹配目标格式。 如果蒙版位图不是单色位图，则会发生错误。 记录增强的元文件时，如果源设备上下文标识增强元文件设备上下文，则会发生错误（函数返回 0）。 并非所有设备都支持`MaskBlt`。 应用程序应调用`GetDeviceCaps`以确定设备是否支持此功能。 如果未提供掩码位图，则此函数的行为与 使用前景`BitBlt`栅格操作代码完全一样。 蒙版位图中的像素偏移映射到源设备上下文位图中的点 （0，0）。 这对于蒙版位图包含一组掩码的情况很有用;应用程序可以通过调整发送到`MaskBlt`的像素偏移量和矩形大小，轻松地将其中任何一个应用于蒙版扫描任务。

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC：：修改世界变换

使用指定的模式更改设备上下文的世界转换。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>参数

*rXform*<br/>
引用用于修改给定设备上下文的世界转换的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构。

*iMode*<br/>
指定转换数据如何修改当前世界变换。 有关此参数可以获取的值的列表，请参阅[修改世界转换](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

### <a name="return-value"></a>返回值

返回成功时的非零值。

失败后返回 0。

要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[修改世界转换](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC：：移动到

将当前位置移动到*x*和*y*指定的点（或*点*）。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定新位置的逻辑 x 坐标。

*Y*<br/>
指定新位置的逻辑 y 坐标。

*点*<br/>
指定新位置。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

前一`CPoint`个位置作为对象的 x 和 y 坐标。

### <a name="example"></a>示例

  请参阅[CRect：：中心点](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的示例。

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC：：偏移夹子

按指定的偏移量移动设备上下文的剪切区域。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要向左或向右移动的逻辑单位数。

*Y*<br/>
指定要向上或向下移动的逻辑单位数。

size <br/>
指定要偏移的金额。

### <a name="return-value"></a>返回值

新区域的类型。 它可以是以下任一值：

- 复杂区域剪切区域具有重叠边框。

- 错误设备上下文无效。

- NULL 区域剪切区域为空。

- SIMPLE 区域剪切区域没有重叠边框。

### <a name="remarks"></a>备注

该函数沿 x 轴移动区域*x*单位，沿 y 轴*移动 y*单位。

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC：：偏移视口组织

相对于当前视口原点的坐标，修改视口原点的坐标。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*n 宽度*<br/>
指定要添加到当前原点的 x 坐标的设备单位数。

*nHeight*<br/>
指定要添加到当前源的 y 坐标的设备单位数。

### <a name="return-value"></a>返回值

作为对象的上一个`CPoint`视口源（在设备坐标中）。

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC：：偏移窗口组织

相对于当前窗口原点的坐标，修改窗口原点的坐标。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>参数

*n 宽度*<br/>
指定要添加到当前原点的 x 坐标的逻辑单位数。

*nHeight*<br/>
指定要添加到当前源的 y 坐标的逻辑单位数。

### <a name="return-value"></a>返回值

作为对象的上一个`CPoint`窗口原点（在逻辑坐标中）。

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC：：操作员 HDC

使用此运算符检索`CDC`对象的设备上下文句柄。

```
operator HDC() const;
```

### <a name="return-value"></a>返回值

如果成功，则处理设备上下文对象的句柄;否则，NULL。

### <a name="remarks"></a>备注

您可以使用该句柄直接调用 Windows API。

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC：:P

使用当前画笔填充*pRgn*指定的区域。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要填充的区域。 给定区域的坐标以逻辑单位指定。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC：:PatBlt

在设备上创建位模式。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要接收图案的矩形左上角的逻辑 x 坐标。

*Y*<br/>
指定要接收模式的矩形左上角的逻辑 y 坐标。

*n 宽度*<br/>
指定要接收图案的矩形的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定要接收图案的矩形的高度（以逻辑单位为单位）。

*dwRop*<br/>
指定栅格操作代码。 栅格操作代码 （ROP） 定义 GDI 如何将颜色合并到涉及当前画笔、可能的源位图和目标位图的输出操作中。 此参数可以是以下值之一：

- PATCOPY 将模式复制到目标位图。

- PATINVERT 使用布尔 XOR 运算符将目标位图与模式相结合。

- DSTINVERT 反转目标位图。

- 黑色将所有输出变为黑色。

- 白色将所有输出变为白色。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该模式是所选画笔和设备上已有的模式的组合。 *dwRop*指定的栅格操作代码定义了如何组合模式。 为此函数列出的栅格操作是完整 256 个三元栅格操作代码的有限子集;特别是，不能使用引用源的栅格操作代码。

并非所有设备上下文都支持该`PatBlt`功能。 要确定设备上下文是否支持`PatBlt`，请使用`GetDeviceCaps`RASTERCAPS 索引调用成员函数，并检查RC_BITBLT标志的返回值。

## <a name="cdcpie"></a><a name="pie"></a>CDC：:Pie

绘制一个椭圆弧，其中心和两个端点由线连接，绘制饼形楔形楔形。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定边界矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边界矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边界矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边界矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定圆弧起点的 x 坐标（以逻辑单位表示）。 此点不必完全位于圆弧上。

*y3*<br/>
指定圆弧起点的 y 坐标（以逻辑单位表示）。 此点不必完全位于圆弧上。

*x4*<br/>
指定圆弧端点（以逻辑单位表示）的 x 坐标。 此点不必完全位于圆弧上。

*y4*<br/>
指定圆弧端点（以逻辑单位表示）的 y 坐标。 此点不必完全位于圆弧上。

*lpRect*<br/>
指定边界矩形。 可以传递`CRect`对象或指针到此参数`RECT`的结构。

*pt 开始*<br/>
指定圆弧的起点。此点不必完全位于圆弧上。您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定圆弧的端点。此点不必完全位于圆弧上。可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

圆弧的中心是由*x1、y1、x2*和*y2（* 或*x2* *lpRect）* 指定的边界矩形的中心。 *y1* 弧的起始点和结束点由 x3、y3、x4*x4*和*y4（* 或 ptStart 和*x3**y3**ptEnd）* 指定。 *ptStart*

弧线使用选定的笔绘制，沿逆时针方向移动。 从每个端点绘制两条其他线到圆弧的中心。 饼图形状的区域用当前画笔填充。 如果*x3*等于*x4，y3*等于*y4，* 则结果是一个椭圆，从椭圆中心到点 *（x3，* *y3）* 或 *（x4*， *y4*） 具有一条线。 *y3*

此函数绘制的图形最多可扩展到但不包括右坐标和底部坐标。 这意味着图形的高度为*y2* - *y1，* 图形的宽度为*x2* - *x1*。 边界矩形的宽度和高度必须大于 2 个单位，小于 32，767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC：:PlayMetaFile

在设备上下文中播放指定的元文件的内容。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>参数

*hMF*<br/>
标识要播放的元文件。

*hEnhMetaFile*<br/>
标识增强的元文件。

*lpBounds*<br/>
指向包含用于`RECT`显示图片的边界`CRect`矩形的坐标的结构或对象。 坐标以逻辑单位指定。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

元文件可以播放任意次数。

的第`PlayMetaFile`二个版本显示存储在给定增强格式元文件中的图片。 当应用程序调用 的第二个版本`PlayMetaFile`时，Windows 使用增强元文件标题中的图片框架将图片映射到*lpBounds*参数指向的矩形上。 （在调用`PlayMetaFile`之前，通过在输出设备中设置世界变换，可以对此图片进行轮用或旋转。沿矩形边缘的点包含在图片中。 在播放增强的元文件之前，可以通过在输出设备中定义剪切区域来剪切增强的元文件图片。

如果增强的元文件包含可选调色板，则应用程序可以通过在调用`PlayMetaFile`的第二个版本 之前在输出设备上设置调色板来实现一致的颜色。 若要检索可选调色板，`GetEnhMetaFilePaletteEntries`请使用 Windows 函数。 通过将第二个版本调用 的`PlayMetaFile`增强元文件并将其的源增强元文件添加到新的增强元文件的设备上下文中，可以嵌入新创建的增强元文件。

此函数将保留输出设备上下文状态。 此函数将删除在增强的元文件中创建但未删除的任何对象。 要停止此功能，应用程序可以从另一个线程`CancelDC`调用 Windows 函数以终止该操作。 在这种情况下，函数返回零。

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC：:PlgBlt

执行位块传输颜色数据位从源设备上下文中的指定矩形到给定设备上下文中的指定并行四字形。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
指向逻辑空间中三个点数组，该数组标识目标平行四边形的三个角。 源矩形的左上角映射到此数组中的第一个点，右上角映射到此数组中的第二个点，将左下角映射到第三个点。 源矩形的右下角映射到平行四边形中的隐式第四点。

*pSrcDC*<br/>
标识源设备上下文。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（以逻辑单位表示）。

*伊斯尔克*<br/>
指定源矩形左上角的 y 坐标（以逻辑单位表示）。

*n 宽度*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*掩码位图*<br/>
标识用于遮盖源矩形颜色的可选单色位图。

*x蒙斯*<br/>
指定单色位图左上角的 x 坐标。

*yMask*<br/>
指定单色位图左上角的 y 坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果给定的位掩码句柄标识有效的单色位图，则函数使用此位图来遮盖源矩形中的颜色数据位。

平行四边形 （D） 的第四个顶点是通过将前三个点（A、B 和 C）作为矢量和计算 D = B + C - A来定义的。

如果存在位掩码，蒙版中的值为 1 表示应将源像素颜色复制到目标。 蒙版中的值为 0 表示不更改目标像素颜色。

如果蒙版矩形小于源矩形和目标矩形，则函数将复制蒙版图案。

源设备上下文中允许缩放、转换和反射转换;但是，旋转和剪切变换不是。 如果蒙版位图不是单色位图，则会发生错误。 目标设备上下文的拉伸模式用于确定如何拉伸或压缩像素（如有必要）。 记录增强的元文件时，如果源设备上下文标识增强的元文件设备上下文，则会发生错误。

目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。 如果源转换具有旋转或剪切，则返回错误。 如果目标矩形和源矩形的颜色格式不同，则`PlgBlt`转换源矩形以匹配目标矩形。 并非所有设备都支持`PlgBlt`。 有关详细信息，请参阅`CDC::GetDeviceCaps`成员函数中RC_BITBLT栅格功能的说明。

如果源设备和目标设备上下文表示不兼容的设备，则`PlgBlt`返回错误。

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC：:P诺利·贝塞尔

绘制一个或多个 Bzier 样条线。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向包含样条线的端点和控制点的[POINT](/windows/win32/api/windef/ns-windef-point)数据结构数组。

*nCount*<br/>
指定*lpPoints*数组中的点数。 此值必须为要绘制的样条线数的三倍以上，因为每个 Bzier 样条线需要两个控制点和一个终结点，并且初始样条线需要一个额外的起始点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数使用*lpPoints*参数指定的端点和控制点绘制立方 Bzier 样条线。 使用第二和第三点作为控制点，从第一个点绘制第一个样条线到第四个点。 序列中的每个后续样条线都需要另外三个点：将前一个样条线的终点用作起点，序列中的后续两个点是控制点，第三个点是终点。

函数既不使用也不更新`PolyBezier`当前位置。 图形未填充。 此函数使用当前笔绘制线条。

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC：:P奥利贝塞尔托

绘制一个或多个 Bzier 样条线。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向包含端点和控制点的[POINT](/windows/win32/api/windef/ns-windef-point)数据结构数组。

*nCount*<br/>
指定*lpPoints*数组中的点数。 此值必须为要绘制的样条线数的三倍，因为每个 Bzier 样条线需要两个控制点和一个终点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数使用*lpPoints*参数指定的控制点绘制立方 Bzier 样条线。 使用前两个点作为控制点，将第一条线从当前位置绘制到第三个点。 对于每个后续样条线，函数只需要另外三个点，并使用前一个样条线的端点作为下一个样条线的起点。 `PolyBezierTo`将当前位置移动到最后一个 Bzier 样条线的终点。 图形未填充。 此函数使用当前笔绘制线条。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：开始路径](#beginpath)。

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC：:P

绘制一组线段和 Bzier 样条线。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向[POINT](/windows/win32/api/windef/ns-windef-point)数据结构数组，其中包含每个线段的端点以及每个 Bzier 样条线的端点和控制点。

*lpType*<br/>
指向指定*如何使用 lpPoints*数组中的每个点的数组。 可以是下列值之一：

- PT_MOVETO 指定此点启动不相交的数字。 此点将成为新的当前位置。

- PT_LINETO 指定从当前位置绘制一条线到此点，然后该点将成为新的当前位置。

- PT_BEZIERTO 指定此点是 Bzier 样条线的控制点或终点。

PT_BEZIERTO类型始终以三组的形式出现。 当前位置定义 Bzier 样条线的起点。 前两个PT_BEZIERTO点是控制点，第三个PT_BEZIERTO点是终点。 结束点将成为新的当前位置。 如果没有连续三个PT_BEZIERTO点，则会导致错误。

   PT_LINETO或PT_BEZIERTO类型可以使用位运算符或指示相应的点是图形中的最后一个点并关闭图形，从而与以下常量组合：

- PT_CLOSEFIGURE 指定完成此点PT_LINETO或PT_BEZIERTO类型后，图形将自动关闭。 从这一点绘制一条线到最新的PT_MOVETO或`MoveTo`点。

   此标志与行的PT_LINETO类型或 Bzier 样条线的PT_BEZIERTO类型结合使用位**或**运算符。 当前位置设置为结束线的终点。

*nCount*<br/>
指定*lpPoints*数组中的点总数，与*lpType*数组中的字节数相同。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此功能可用于绘制不交交的数字，以代替对`CDC::MoveTo`的连续调用 和`CDC::LineTo``CDC::PolyBezierTo`成员函数。 线条和样条线使用当前笔绘制，并且不会填充图形。 如果有一个活动路径由调用成员函数启动`CDC::BeginPath`，则`PolyDraw`添加到路径。 *lpPoints*数组和*lpType*中包含的点指示每个点是`CDC::MoveTo`、 或`CDC::LineTo`操作的一`CDC::BezierTo`部分。 也可以关闭数字。 此函数更新当前位置。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：开始路径](#beginpath)。

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC：:P

使用当前笔绘制由两个或多个点（顶点）组成的多边形。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向指定多边形顶点的点数组。 数组中的每个点是结构`POINT`或`CPoint`对象。

*nCount*<br/>
指定数组中的顶点数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如有必要，系统通过绘制从最后一个顶点到第一个顶点的线自动关闭面。

可以使用`GetPolyFillMode`和`SetPolyFillMode`成员函数检索或设置当前多边形填充模式。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC：:Polyline

绘制一组线段，连接*lpPoints*指定的点。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向要连接的结构或`POINT``CPoint`对象数组。

*nCount*<br/>
指定数组中的点数。 此值必须至少为 2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前笔从第一个点到后续点绘制线条。 与`LineTo`成员函数不同，该`Polyline`函数既不使用也不更新当前位置。

有关详细信息，请参阅 Windows SDK 中的[PolyLine。](/windows/win32/api/wingdi/nf-wingdi-polyline)

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC：:Polylylylyto

绘制一条或多条直线。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向包含行顶点的[POINT](/windows/win32/api/windef/ns-windef-point)数据结构数组。

*nCount*<br/>
指定数组中的点数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前笔从当前位置绘制一条线到*lpPoints*参数指定的第一个点。 对于每一附加行，函数从上一行的结束点绘制到*lpPoints*指定的下一个点。 `PolylineTo`将当前位置移动到最后一行的结束点。 如果此函数绘制的线段形成闭合图，则不会填充该图。

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC：:P多利多贡

创建使用当前多边形填充模式填充的两个或多个面。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向定义多边形顶`POINT`点的结构`CPoint`或对象的数组。

*lpPolyCounts*<br/>
指向整数数组，每个整数指定*lpPoints*数组中一个多边形中的点数。

*nCount*<br/>
*lpPolyCounts 数组*中的条目数。 此数字指定要绘制的面数。 此值必须至少为 2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

多边形可能是不交或重叠的。

必须关闭对`PolyPolygon`函数的调用中指定的每个多边形。 与`Polygon`成员函数创建的多边形不同，由 创建的`PolyPolygon`多边形不会自动闭合。

该函数创建两个或多个多边形。 要创建单个多边形，应用程序应使用`Polygon`成员函数。

可以使用`GetPolyFillMode`和`SetPolyFillMode`成员函数检索或设置当前多边形填充模式。

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC：:P多利线

绘制多个串联线段系列。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>参数

*lpPoints*<br/>
指向包含折线顶点的结构数组。 连续指定多条线。

*lpPolyPoints*<br/>
指向指定相应多边形*的 lpPoints*数组中的点数的变量数组。 每个条目必须大于或等于 2。

*nCount*<br/>
指定*lpPolyPoints*数组中的计数总数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

线段使用当前笔绘制。 段形成的数字不填充。 此函数既不使用也不更新当前位置。

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC：:P可见

确定给定点是否位于设备上下文的剪切区域内。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>参数

*x*<br/>
指定点的逻辑 x 坐标。

*Y*<br/>
指定点的逻辑 y 坐标。

*点*<br/>
指定要签入逻辑坐标的点。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

如果指定的点位于剪切区域内，则非零;否则 0。

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC：：查询中止

调用[SetAbortProc](#setabortproc)成员为打印应用程序安装的中止函数，并查询是否应终止打印。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>返回值

如果打印应继续或没有中止过程，则返回值为非零。 如果应终止打印作业，则为 0。 返回值由中止函数提供。

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC：实现调色板

将条目从当前逻辑调色板映射到系统调色板。

```
UINT RealizePalette();
```

### <a name="return-value"></a>返回值

指示逻辑调色板中映射到系统调色板中不同条目的条目数。 这表示此函数重新映射的条目数，以适应自上次实现逻辑调色板以来系统调色板中的更改。

### <a name="remarks"></a>备注

逻辑调色板充当色彩密集型应用程序和系统之间的缓冲区，允许应用程序根据需要使用尽可能多的颜色，而不会干扰其自己显示的颜色或其他窗口显示的颜色。

当窗口具有输入焦点和调用`RealizePalette`时，Windows 可确保窗口将显示所有请求的颜色，最多显示屏幕上同时可用的最大数量。 Windows 还会通过将颜色与可用颜色匹配来显示窗口调色板中找不到的颜色。

此外，Windows 将调用函数的非活动窗口请求的颜色与可用颜色相匹配。 这大大减少了非活动窗口中显示的颜色的不良更改。

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC：矩形

使用当前笔绘制矩形。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定矩形右下角的 y 坐标（以逻辑单位表示）。

*lpRect*<br/>
以逻辑单位指定矩形。 可以传递`CRect`对象或指针到此参数`RECT`的结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

矩形的内部使用当前画笔填充。

矩形向上延伸，但不包括右坐标和底部坐标。 这意味着矩形的高度为*y2* - *y1，* 矩形的宽度为*x2* - *x1*。 矩形的宽度和高度必须大于 2 个单位，小于 32，767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC：：可分割

确定给定矩形的任何部分是否位于显示上下文的剪切区域内。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
指向包含指定`RECT`矩形的逻辑坐标`CRect`的结构或对象。

### <a name="return-value"></a>返回值

如果给定矩形的任何部分位于裁剪区域内，则非零;否则 0。

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC：：释放AtribDC

调用此成员函数以设置为`m_hAttribDC`NULL。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>备注

这不会`Detach`导致发生 。 只有输出设备上下文附加到对象，`CDC`并且只能将其分离。

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC：：释放输出DC

调用此成员函数将`m_hDC`成员设置为 NULL。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>备注

当输出设备上下文附加到`CDC`对象时，无法调用此成员函数。 使用`Detach`成员函数分离输出设备上下文。

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC：：ResetDC

调用此成员函数以更新由`CDC`对象包装的设备上下文。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>参数

*lpDevMode*<br/>
指向 Windows`DEVMODE`结构的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文将从 Windows`DEVMODE`结构中指定的信息更新。 此成员函数仅重置属性设备上下文。

当窗口处理`WM_DEVMODECHANGE`消息时，`ResetDC`应用程序通常会使用成员函数。 您还可以使用此成员函数在打印文档时更改纸张方向或纸盒。

不能使用此成员函数更改驱动程序名称、设备名称或输出端口。 当用户更改端口连接或设备名称时，必须删除原始设备上下文，并使用新信息创建新的设备上下文。

在调用此成员函数之前，必须确保已选择到设备上下文中的所有对象（库存对象以外的对象）。

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC：：恢复DC

将设备上下文还原到*nSavedDC*标识的上一个状态。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>参数

*n保存DC*<br/>
指定要还原的设备上下文。 它可以是上`SaveDC`一个函数调用返回的值。 如果*nSavedDC*为 -1，则还原最近保存的设备上下文。

### <a name="return-value"></a>返回值

如果还原指定的上下文，则非零;否则 0。

### <a name="remarks"></a>备注

`RestoreDC`通过从以前对成员函数的调用创建的堆栈中弹出状态信息来`SaveDC`还原设备上下文。

堆栈可以包含多个设备上下文的状态信息。 如果*nSavedDC*指定的上下文不在堆栈的顶部，请`RestoreDC`删除*nSavedDC*指定的设备上下文和堆栈顶部之间的所有状态信息。 已删除的信息将丢失。

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC：：圆形Rect

使用当前笔绘制圆角的矩形。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>参数

*x1*<br/>
指定矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定用于绘制圆角（以逻辑单位）的椭圆的宽度。

*y3*<br/>
指定用于绘制圆角（以逻辑单位）的椭圆的高度。

*lpRect*<br/>
指定逻辑单位中的边界矩形。 可以传递`CRect`对象或指针到此参数`RECT`的结构。

*点*<br/>
*点的*x 坐标指定椭圆的宽度以绘制圆角（以逻辑单位为单位）。 *点的*y 坐标指定椭圆的高度以绘制圆角（以逻辑单位为单位）。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

矩形的内部使用当前画笔填充。

此函数绘制的图形可扩展到但不包括右坐标和底部坐标。 这意味着图形的高度为*y2* - *y1，* 图形的宽度为*x2* - *x1*。 边界矩形的高度和宽度必须大于 2 个单位，小于 32，767 个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC：：保存DC

通过将状态信息（如剪切区域、选定对象和映射模式）复制到 Windows 维护的上下文堆栈，从而保存设备上下文的当前状态。

```
virtual int SaveDC();
```

### <a name="return-value"></a>返回值

标识保存的设备上下文的整数。 如果发生错误，为 0。 此返回值可用于通过调用`RestoreDC`来还原设备上下文。

### <a name="remarks"></a>备注

以后可以使用 还原的设备上下文`RestoreDC`。

`SaveDC`可以使用任意数量的时间保存任意数量的设备上下文状态。

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC：：规模视口Ext

修改相对于当前值的视口范围。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>参数

*xNum*<br/>
指定乘以当前 x 范围的数量。

*x德诺姆*<br/>
指定将当前 x 范围乘以*xNum*参数的值的结果除以的量。

*yNum*<br/>
指定乘以当前 y 范围的金额。

*伊德诺姆*<br/>
指定将当前 y 范围乘以*yNum*参数的值的结果的量。

### <a name="return-value"></a>返回值

以前的视口扩展区（以设备单位为单位）作为`CSize`对象。

### <a name="remarks"></a>备注

公式编写如下：

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

新的视口范围的计算方法是将当前范围乘以给定的分子，然后除以给定分母。

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC：：缩放窗口Ext

修改相对于当前值的窗口范围。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>参数

*xNum*<br/>
指定乘以当前 x 范围的数量。

*x德诺姆*<br/>
指定将当前 x 范围乘以*xNum*参数的值的结果除以的量。

*yNum*<br/>
指定乘以当前 y 范围的金额。

*伊德诺姆*<br/>
指定将当前 y 范围乘以*yNum*参数的值的结果的量。

### <a name="return-value"></a>返回值

前面的窗口范围（以逻辑单位为单位）作为`CSize`对象。

### <a name="remarks"></a>备注

公式编写如下：

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新的窗口范围的计算方法是将当前范围乘以给定的分子，然后除以给定分母。

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC：：ScrollDC

水平和垂直滚动位矩形。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>参数

*Dx*<br/>
指定水平滚动单位的数量。

*Dy*<br/>
指定垂直滚动单位的数量。

*lpRectScroll*<br/>
指向包含滚动`RECT`矩形坐标`CRect`的结构或对象。

*lprectClip*<br/>
指向包含裁剪`RECT`矩形坐标`CRect`的结构或对象。 当此矩形小于*lpRectScroll*指向的原始矩形时，滚动仅在较小的矩形中发生。

*pRgn 更新*<br/>
标识滚动过程发现的区域。 函数`ScrollDC`定义此区域;因此，函数定义此区域。它不一定是一个矩形。

*lprect更新*<br/>
指向接收绑定`RECT`滚动更新`CRect`区域的矩形坐标的结构或对象。 这是需要重新绘制的最大矩形区域。 函数返回时结构或对象中的值位于客户端坐标中，而不考虑给定设备上下文的映射模式。

### <a name="return-value"></a>返回值

如果执行滚动，则非零;否则 0。

### <a name="remarks"></a>备注

如果*lpRect 更新*为 NULL，则 Windows 不会计算更新矩形。 如果*pRgnUpdate*和*lpRect 更新*均为 NULL，则 Windows 不会计算更新区域。 如果*pRgnUpdate*不是 NULL，Windows 假定它包含指向滚动过程（由`ScrollDC`成员函数定义）覆盖的区域的有效指针。 `CWnd::InvalidateRgn`如果需要，可以在*lpRectUpdate*中返回的更新区域传递给。

当需要滚动窗口的整个`ScrollWindow`工作区时，应用程序`CWnd`应使用类的成员函数。 否则，它应该使用`ScrollDC`。

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC：：选择剪辑路径

选择当前路径作为设备上下文的剪切区域，使用指定的模式将新区域与任何现有剪切区域合并。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>参数

*nMode*<br/>
指定使用路径的方法。 允许以下值：

- RGN_AND 新的裁剪区域包括当前剪切区域和当前路径的交点（重叠区域）。

- RGN_COPY 新的裁剪区域是当前路径。

- RGN_DIFF新剪切区域包括当前剪切区域的区域，并且排除当前路径的区域。

- RGN_OR 新裁剪区域包括当前剪切区域和当前路径的联合（组合区域）。

- RGN_XOR 新的裁剪区域包括当前剪切区域和当前路径的合并，但没有重叠区域。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

标识的设备上下文必须包含闭合路径。

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC：：选择ClipRgn

选择给定区域作为设备上下文的当前剪切区域。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>参数

*pRgn*<br/>
标识要选择的区域。

- 对于此函数的第一个版本，如果此值为 NULL，则选择整个工作区，并且输出仍被剪切到窗口。

- 对于此函数的第二个版本，仅当指定RGN_COPY模式时，此句柄才能为 NULL。

*nMode*<br/>
指定要执行的操作。 它必须是以下值之一：

- RGN_AND 新的裁剪区域结合了当前裁剪区域的重叠区域和*pRgn*标识的区域。

- RGN_COPY 新的裁剪区域是*pRgn*标识的区域的副本。 这是功能与 的第一个版本相同`SelectClipRgn`。 如果*pRgn*标识的区域为 NULL，则新的剪切区域将成为默认剪切区域（空区域）。

- RGN_DIFF 新的裁剪区域将当前裁剪区域的区域与*pRgn*标识的区域中排除的区域合并。

- RGN_OR 新的裁剪区域结合了当前裁剪区域和*pRgn*标识的区域。

- RGN_XOR 新裁剪区域合并当前剪切区域和*pRgn*标识的区域，但不包括任何重叠区域。

### <a name="return-value"></a>返回值

区域的类型。 可以是以下任一值：

- 复杂区域 新裁剪区域具有重叠边框。

- 错误设备上下文或区域无效。

- NULL 区域 新剪切区域为空。

- SIMPLE区域 新剪切区域没有重叠边框。

### <a name="remarks"></a>备注

仅使用所选区域的副本。 区域本身可以为任意数量的其他设备上下文选择，也可以将其删除。

该函数假定给定区域的坐标以设备单位指定。 某些打印机设备支持文本输出，其分辨率高于图形输出，以保持表达文本指标所需的精度。 这些设备以更高的分辨率（即文本单位）报告设备单位。 然后，这些设备缩放图形坐标，以便多个报告的设备单元映射到只有 1 个图形单元。 应始终使用文本单位调用`SelectClipRgn`函数。

必须在 GDI 中缩放图形对象的应用程序可以使用 GETSCALINGFACTOR 打印机转义来确定缩放因子。 此缩放因子会影响剪切。 如果区域用于剪辑图形，GDI 会按缩放因子划分坐标。 如果区域用于剪辑文本，GDI 不进行缩放调整。 缩放因子 1 会导致坐标除以 2;缩放因子 2 导致坐标除以 4;等等。

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC：：选择对象

在设备上下文中选择对象。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>参数

*pPen*<br/>
指向要选择的[CPen](../../mfc/reference/cpen-class.md)对象的指针。

*pBrush*<br/>
指向要选择的[CBrush](../../mfc/reference/cbrush-class.md)对象的指针。

*pFont*<br/>
指向要选择的[CFont](../../mfc/reference/cfont-class.md)对象的指针。

*pBitmap*<br/>
指向要选择的[CBitmap](../../mfc/reference/cbitmap-class.md)对象的指针。

*pRgn*<br/>
指向要选择的[CRgn](../../mfc/reference/crgn-class.md)对象的指针。

*pObject*<br/>
指向要选择的[CGdiObject 对象的](../../mfc/reference/cgdiobject-class.md)指针。

### <a name="return-value"></a>返回值

指向要替换的对象的指针。 这是指向派生自 的`CGdiObject`类之一的对象（如`CPen`）的指针，具体取决于所使用的函数的版本。 如果出现错误，返回值为 NULL。 此函数可以返回指向临时对象的指针。 此临时对象仅在处理一个 Windows 消息期间有效。 有关详细信息，请参阅 `CGdiObject::FromHandle`。

采用区域参数的成员函数的版本执行与`SelectClipRgn`成员函数相同的任务。 其返回值可以是以下任一值：

- 复杂区域 新裁剪区域具有重叠边框。

- 错误设备上下文或区域无效。

- NULL 区域 新剪切区域为空。

- SIMPLE区域 新剪切区域没有重叠边框。

### <a name="remarks"></a>备注

类`CDC`提供专门用于特定类型 GDI 对象的五个版本，包括笔、画笔、字体、位图和区域。 新选择的对象将替换同一类型的上一个对象。 例如，如果`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)对象的一般版本的*pObject，* 则函数将当前笔替换为*pObject*指定的笔。

应用程序只能选择位图到内存设备上下文中，并且一次只能选择一个内存设备上下文。 位图的格式必须是单色的，或者与设备上下文兼容;如果不是，`SelectObject`则返回错误。

对于 Windows 3.1 及`SelectObject`更高版本，无论函数是否用于元文件，该函数都返回相同的值。 在以前的 Windows 版本中`SelectObject`，返回一个非零值作为成功值，在元文件中使用失败返回 0。

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC：：选择调色板

选择*pPalette*指定的逻辑调色板作为设备上下文的选定调色板对象。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>参数

*pPalette*<br/>
标识要选择的逻辑调色板。 此调色板必须已经使用`CPalette`成员函数[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)创建。

*bForce背景*<br/>
指定逻辑调色板是否被迫为背景调色板。 如果*bForce背景*是非零，则所选调色板始终是背景调色板，而不考虑窗口是否具有输入焦点。 如果*bForce背景*为 0，并且设备上下文附加到窗口，则当窗口具有输入焦点时，逻辑调色板是前景调色板。

### <a name="return-value"></a>返回值

指向对象，`CPalette`标识由*pPalette*指定的调色板替换的逻辑调色板。 如果出现错误，则为 NULL。

### <a name="remarks"></a>备注

新调色板将成为 GDI 用于控制设备上下文中显示的颜色并替换上一个调色板的调色板对象。

应用程序可以选择逻辑调色板到多个设备上下文中。 但是，对逻辑调色板的更改将影响为其选择的逻辑上下文。 如果应用程序在多个设备上下文中选择调色板，则设备上下文必须都属于同一物理设备。

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC：：选择股票对象

选择对应于预定义的库存笔、画笔或字体之一的[CGdiObject 对象](../../mfc/reference/cgdiobject-class.md)。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>参数

*nIndex*<br/>
指定所需的库存对象类型。 可以为下列值之一：

- BLACK_BRUSH黑色刷子。

- DKGRAY_BRUSH深灰色画笔。

- GRAY_BRUSH灰色画笔。

- HOLLOW_BRUSH空心刷。

- LTGRAY_BRUSH浅灰色画笔。

- NULL_BRUSH空画笔。

- WHITE_BRUSH白刷。

- BLACK_PEN黑笔

- NULL_PEN空笔。

- WHITE_PEN白笔。

- ANSI_FIXED_FONT ANSI 固定系统字体。

- ANSI_VAR_FONT ANSI 可变系统字体。

- DEVICE_DEFAULT_FONT 与设备相关的字体。

- OEM_FIXED_FONT OEM 相关的固定字体。

- SYSTEM_FONT 系统字体。 默认情况下，Windows 使用系统字体绘制菜单、对话框控件和其他文本。 但是，最好不要依赖SYSTEM_FONT来获取对话框和窗口使用的字体。 而是使用SPI_GETNONCLIENTMETRICS`SystemParametersInfo`参数的 函数来检索当前字体。 `SystemParametersInfo`考虑当前主题，并提供标题、菜单和消息对话框的字体信息。

- SYSTEM_FIXED_FONT 版本 3.0 之前 Windows 中使用的固定宽度系统字体。 此对象可用于与早期版本的 Windows 兼容。

- DEFAULT_PALETTE默认调色板。 此调色板由系统调色板中的 20 种静态颜色组成。

### <a name="return-value"></a>返回值

如果函数成功，`CGdiObject`则指向被替换的对象的指针。 指向的实际对象是[CPen、CBrush](../../mfc/reference/cpen-class.md)或[CFont](../../mfc/reference/cfont-class.md)对象。 [CBrush](../../mfc/reference/cbrush-class.md) 如果调用不成功，则返回值为 NULL。

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC：：SetAbortProc

安装打印作业的中止过程。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>参数

*利夫芬*<br/>
指向中止函数的指针，用于作为中止过程安装。 有关回调函数，请参阅[CDC 的回调函数：：SetAbortProc](callback-functions-used-by-mfc.md#setabortproc)。

### <a name="return-value"></a>返回值

指定函数的结果`SetAbortProc`。 以下某些值比其他值更可能，但所有值都是可能的。

- SP_ERROR一般错误。

- SP_OUTOFDISK当前没有足够的磁盘空间可用于后台打印，并且不再有可用空间。

- SP_OUTOFMEMORY没有足够的内存可用于后台。

- SP_USERABORT用户通过打印管理器结束了作业。

### <a name="remarks"></a>备注

如果应用程序要允许在后台打印作业期间取消，则必须在使用[StartDoc](#startdoc)成员函数启动打印作业之前设置中止函数。 打印管理器在后台打印期间调用中止功能，以允许应用程序取消打印作业或处理磁盘外空间条件。 如果未设置中止功能，则如果没有足够的磁盘空间进行后台打印，打印作业将失败。

请注意，Microsoft VisualC++功能简化了传递给`SetAbortProc`的回调函数的创建。 传递给`EnumObjects`成员函数的地址是指向随`__declspec(dllexport)`调用约定导出的函数的`__stdcall`指针。

您也不必在应用程序的模块定义文件中的**EXPORTS**语句中导出函数名称。 您可以改为使用**EXPORT**函数修改器，如

**BOOL 回调导出**功能 **（HDC），）;** `int` **);**

使编译器发出正确的导出记录，以便按名称导出，而无需别名。 这适用于大多数需求。 对于某些特殊情况，例如通过单位导出或别名导出函数，您仍然需要在模块定义文件中使用**EXPORT**语句。

回调注册接口现在属于类型安全（您必须传递一个函数指针，该函数指针指向特定回调的正确类型的函数）。

另请注意，所有回调函数在返回到 Windows 之前都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章["例外](../../mfc/exception-handling-in-mfc.md)"。

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC：：SetArc方向

设置用于圆弧和矩形函数的绘图方向。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>参数

*nArc方向*<br/>
指定新的弧方向。 此参数可以是以下值之一：

- AD_COUNTERCLOCKWISE逆时针绘制的数字。

- AD_CLOCKWISE顺时针绘制的数字。

### <a name="return-value"></a>返回值

指定旧弧方向（如果成功）;否则 0。

### <a name="remarks"></a>备注

默认方向是逆时针方向。 该`SetArcDirection`函数指定以下函数绘制的方向：

|Arc|饼图|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>疾控中心：：塞特特里布

调用此函数以设置属性设备上下文`m_hAttribDC`。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

此成员函数不将设备上下文附加到`CDC`对象。 只有输出设备上下文附加到`CDC`对象。

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC：：SetBkColor

将当前背景颜色设置为指定颜色。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新的背景颜色。

### <a name="return-value"></a>返回值

以前的背景颜色作为 RGB 颜色值。 如果发生错误，返回值为 0x8000000。

### <a name="remarks"></a>备注

如果背景模式为 OPAQUE，则系统使用背景颜色来填充样式线中的间隙、画笔中阴影线和字符单元格中的背景之间的间隙。 在颜色和单色设备上下文之间转换位图时，系统还使用背景颜色。

如果设备无法显示指定的颜色，系统将背景颜色设置为最接近的物理颜色。

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC：：SetBkMode

设置背景模式。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>参数

*nBkMode*<br/>
指定要设置的模式。 此参数可以是以下值之一：

- 在绘制文本、阴影画笔或笔之前，OPAQUE 背景用当前背景颜色填充。 这是默认后台模式。

- 在绘制之前，不会更改"透明背景"。

### <a name="return-value"></a>返回值

以前的后台模式。

### <a name="remarks"></a>备注

背景模式定义在绘制文本、阴影画笔或不是实线的任何笔样式之前，系统是否删除绘图图面上的现有背景颜色。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC：：SetBundsRect

控制指定设备上下文的边界矩形信息的累积。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>参数

*lpRectBounds*<br/>
指向用于设置`RECT`边界矩形`CRect`的结构或对象。 矩形尺寸以逻辑坐标给出。 此参数可以是 NULL。

*flag*<br/>
指定新矩形与累积矩形的组合方式。 此参数可以是以下值的组合：

- DCB_ACCUMULATE 将*lpRectBounds*指定的矩形添加到边界矩形（使用矩形联合操作）。

- DCB_DISABLE 关闭边界累积。

- DCB_ENABLE 打开边界累积。 （禁用边界累积的默认设置。

### <a name="return-value"></a>返回值

如果函数成功，则边界矩形的当前状态。 与*标志*一样，返回值可以是**DCB_** 值的组合：

- DCB_ACCUMULATE 边界矩形不为空。 此值将始终被设置。

- DCB_DISABLE边界累积已关闭。

- DCB_ENABLE边界累积打开。

### <a name="remarks"></a>备注

Windows 可以维护所有绘图操作的边界矩形。 此矩形可以由应用程序查询和重置。 绘图边界可用于使位图缓存无效。

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC：：SetBrushOrg

指定 GDI 将分配给应用程序在设备上下文中选择的下一个画笔的原点。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定新原点的 x 坐标（以设备单位为单位）。 此值必须位于 0-7 范围内。

*Y*<br/>
指定新原点的 y 坐标（以设备单位为单位）。 此值必须位于 0-7 范围内。

*点*<br/>
指定新原点的 x 坐标和 y 坐标。 每个值必须位于 0-7 范围内。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

以设备单位表示画笔的上一个原点。

### <a name="remarks"></a>备注

画笔原点的默认坐标为 （0， 0）。 要更改画笔的原点`UnrealizeObject`，请调用`CBrush`对象的函数，调用`SetBrushOrg`，然后调用`SelectObject`成员函数以选择画笔到设备上下文中。

请勿与库存`SetBrushOrg``CBrush`对象一起使用。

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC：：设置颜色调整

使用指定值设置设备上下文的颜色调整值。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>参数

*lpColorAdjust*<br/>
指向包含颜色[调整](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)值的 COLOR 调整数据结构。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

颜色调整值用于在设置 HALFTONE 模式时调整对`CDC::StretchBlt`成员函数调用的源位图的输入颜色。

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC：：SetDCBrush颜色

将当前设备上下文 （DC） 画笔颜色设置为指定的颜色值。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新的画笔颜色。

### <a name="return-value"></a>返回值

如果函数成功，返回值将以前的 DC 画笔颜色指定为 COLORREF 值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此方法模拟函数[SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor)的功能，如 Windows SDK 中所述。

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC：：SetDCPenColor

将当前设备上下文 （DC） 笔颜色设置为指定的颜色值。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定新的笔颜色。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[SetDCPenColor，](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)如 Windows SDK 中所述。

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC：：设置图形模式

设置指定设备上下文的图形模式。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>参数

*iMode*<br/>
指定图形模式。 有关此参数可以获取的值的列表，请参阅[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

### <a name="return-value"></a>返回值

成功时返回旧的图形模式。

失败后返回 0。 要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC：：设置布局

调用此成员函数将设备上下文的文本和图形布局从右向左更改为左侧，这是阿拉伯语和希伯来语等区域性的标准布局。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>参数

*德布局*<br/>
设备上下文布局和位图控制标志。 它可以是以下值的组合。

|“值”|含义|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|禁用对 CDC 调用的任何反射[：：BitBlt](#bitblt)和[CDC：：拉伸 Blt](#stretchblt)。|
|LAYOUT_RTL|将默认水平布局设置为从右到左。|
|LAYOUT_LTR|将默认布局设置为从左到右。|

### <a name="return-value"></a>返回值

如果成功，则设备上下文的上一个布局。

如果不成功，GDI_ERROR。 要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

通常，您不会调用`SetLayout`窗口。 相反，您可以通过设置[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)（如WS_EX_RTLREADING）来控制窗口中的从右到左布局。 设备上下文（如打印机或元文件）不继承此布局。 为从右到左布局设置设备上下文的唯一方法是调用`SetLayout`。

如果调用**SetLayout（LAYOUT_RTL** `SetLayout` ），则会自动将映射模式更改为MM_ISOTROPIC。 因此，后续对[GetMapMode](#getmapmode)的调用将返回MM_ISOTROPIC而不是MM_TEXT。

在某些情况下，例如使用许多位图，您可能希望保留从左到右的布局。 在这些情况下，通过调用`BitBlt`或`StretchBlt`渲染图像，然后将*dwLayout*的位图控制标志设置为LAYOUT_BITMAPORIENTATIONPRESERVED。

使用LAYOUT_RTL标志更改布局后，通常指定右或左的标志将反转。 为了避免混淆，您可能需要为标准标志定义备用名称。 有关建议的备用标志名称的列表，请参阅 Windows SDK 中的["设置布局](/windows/win32/api/wingdi/nf-wingdi-setlayout)"。

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC：：设置地图模式

设置映射模式。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>参数

*nMapMode*<br/>
指定新的映射模式。 它可以是以下任一值：

- MM_ANISOTROPIC逻辑单位转换为具有任意缩放轴的任意单位。 将映射模式设置为MM_ANISOTROPIC不会更改当前窗口或视口设置。 要更改单位、方向和缩放，请致电[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成员函数。

- MM_HIENGLISH 每个逻辑单元转换为 0.001 英寸。 正 x 位于右侧;正 y 是向上。

- MM_HIMETRIC每个逻辑单位转换为 0.01 毫米。 正 x 位于右侧;正 y 是向上。

- MM_ISOTROPIC逻辑单位转换为具有同样缩放轴的任意单位;即，沿 x 轴的 1 个单位等于沿 y 轴的 1 个单位。 使用`SetWindowExt`和`SetViewportExt`成员函数指定所需的单位和轴的方向。 GDI 根据需要进行调整，以确保 x 和 y 单位保持相同的大小。

- MM_LOENGLISH每个逻辑单元转换为 0.01 英寸。 正 x 位于右侧;正 y 是向上。

- MM_LOMETRIC每个逻辑单位转换为 0.1 毫米。 正 x 位于右侧;正 y 是向上。

- MM_TEXT每个逻辑单元转换为 1 个设备像素。 正 x 位于右侧;正 y 是向下。

- MM_TWIPS每个逻辑单元转换为点的 1/20。 （因为点是 1/72 英寸，因此 twip 是 1/1440 英寸。正 x 位于右侧;正 y 是向上。

### <a name="return-value"></a>返回值

以前的映射模式。

### <a name="remarks"></a>备注

映射模式定义用于将逻辑单位转换为设备单位的度量单位;它还定义设备的 x 轴和 y 轴的方向。 GDI 使用映射模式将逻辑坐标转换为相应的设备坐标。 MM_TEXT模式允许应用程序在设备像素中工作，其中 1 个单位等于 1 像素。 像素的物理大小因设备而异。

MM_HIENGLISH、MM_HIMETRIC、MM_LOENGLISH、MM_LOMETRIC和MM_TWIPS模式对于必须以物理有意义的单位（如英寸或毫米）绘制的应用程序很有用。 MM_ISOTROPIC模式可确保 1：1 纵横比，这在保持图像的确切形状很重要时非常有用。 MM_ANISOTROPIC模式允许独立调整 x 坐标和 y 坐标。

> [!NOTE]
> 如果调用[SetLayout](#setlayout)将 DC（设备上下文）更改为从右到左布局，则`SetLayout`自动将映射模式更改为MM_ISOTROPIC。

### <a name="example"></a>示例

  请参阅[CView 的示例：：在准备DC](../../mfc/reference/cview-class.md#onpreparedc)上。

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC：：设置映射标记

将逻辑字体转换为物理字体时，将字体映射器使用的方法更改为方法。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>参数

*dwFlag*<br/>
指定字体映射器是否尝试将字体的纵横高度和宽度与设备匹配。 当此值ASPECT_FILTERING时，映射器仅选择其 x 方面和 y 方面与指定设备完全匹配的字体。

### <a name="return-value"></a>返回值

字体映射器标志的上一个值。

### <a name="remarks"></a>备注

应用程序可用于`SetMapperFlags`使字体映射器尝试仅选择与指定设备的纵横比完全匹配的物理字体。

仅使用栅格字体的应用程序可以使用 函数`SetMapperFlags`来确保字体映射器选择的字体在指定的设备上具有吸引力且可读。 使用可缩放 （TrueType） 字体的应用程序通常不使用`SetMapperFlags`。

如果没有物理字体的纵横比与逻辑字体中的规范匹配，GDI 会选择新的纵横比并选择与此新纵横比匹配的字体。

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC：：设置Miter限制

设置设备上下文的斜接联接长度限制。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>参数

*fMiter Limit*<br/>
指定设备上下文的新斜接限制。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

斜接长度定义为从连接内部线壁的交点到连接外部线壁的交点的距离。 斜接限制是斜接长度与线宽的最大允许比率。 默认斜接限制为 10.0。

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC：：设置输出DC

调用此成员函数以设置输出设备上下文`m_hDC`。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>参数

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

仅当设备上下文尚未附加到`CDC`对象时，才能调用此成员函数。 此成员函数集`m_hDC`但不将设备上下文附加到`CDC`对象。

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC：：设置像素

将像素设置在指定的点，以*最接近 crColor*指定的颜色近似。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要设置的点的逻辑 x 坐标。

*Y*<br/>
指定要设置的点的逻辑 y 坐标。

*crColor*<br/>
指定用于绘制点的颜色的 COLORREF RGB 值。 有关此值的说明，请参阅 Windows SDK 中的[COLORREF。](/windows/win32/gdi/colorref)

*点*<br/>
指定要设置的点的逻辑 x 坐标。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

点实际绘制的颜色的 RGB 值。 如果使用该颜色的近似值，则此值可能不同于*crColor*指定的值。 如果函数失败（如果点位于剪切区域之外），则返回值为 -1。

### <a name="remarks"></a>备注

该点必须位于剪切区域中。 如果点不在剪切区域中，则函数不执行任何操作。

不是所有的设备都支持 `SetPixel` 函数。 要确定设备是否支持`SetPixel`，请使用`GetDeviceCaps`RASTERCAPS 索引调用成员函数，并检查RC_BITBLT标志的返回值。

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC：：SetPixelV

将指定坐标处的像素设置为指定颜色的最接近近似值。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>参数

*x*<br/>
指定要设置的点的 x 坐标（以逻辑单位表示）。

*Y*<br/>
指定要设置的点的 y 坐标（以逻辑单位表示）。

*crColor*<br/>
指定用于绘制点的颜色。

*点*<br/>
指定要设置的点的逻辑 x 坐标。 您可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该点必须位于剪切区域和设备表面的可见部分中。 并非所有设备都支持成员功能。 有关详细信息，请参阅成员函数中的`CDC::GetDeviceCaps`RC_BITBLT功能。 `SetPixelV`比`SetPixel`它不需要返回实际绘制的点的颜色值更快。

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC：：设置Poly填充模式

设置多边形填充模式。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>参数

*nPolyFill模式下*<br/>
指定新的填充模式。 此值可以是 ALTERNATE 或 WINDING。 Windows 中的默认模式设置为 ALTERNATE。

### <a name="return-value"></a>返回值

以前的填充模式（如果成功）;否则 0。

### <a name="remarks"></a>备注

当多边形填充模式为 ALTERNATE 时，系统将填充每个扫描行上的奇数和偶数多边形边之间的区域。 也就是说，系统填充第一和第二侧之间的区域，在第三和第四侧之间，等等。 这是默认模式。

当多边形填充模式为 WINDING 时，系统使用绘制图形的方向来确定是否填充区域。 多边形中的每个线段都以顺时针或逆时针方向绘制。 每当从封闭区域绘制到图形外部的虚线经过顺时针线段时，计数就会递增。 当线通过逆时针线段时，计数将递减。 如果计数在行到达图形外部时计数为非零，则填充该区域。

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC：：SetROP2

设置当前绘图模式。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>参数

*nDrawMode*<br/>
指定新的绘图模式。 可以是以下任一值：

- R2_BLACK 像素始终为黑色。

- R2_WHITE 像素始终为白色。

- R2_NOP像素保持不变。

- R2_NOT像素是屏幕颜色的反面。

- R2_COPYPEN像素是笔的颜色。

- R2_NOTCOPYPEN像素是笔颜色的反面。

- R2_MERGEPENNOT像素是笔颜色和屏幕颜色的反向（最终像素 = （屏幕像素） 或笔）的组合。

- R2_MASKPENNOT像素是笔和屏幕的反向（最终像素 = （屏幕像素） 和笔）共有的颜色的组合。

- R2_MERGENOTPEN像素是屏幕颜色和笔颜色的反向（最终像素 = （不是笔） 或屏幕像素的组合。

- R2_MASKNOTPEN像素是屏幕和笔的反向（最终像素 = （NOT 笔）和屏幕像素）共有颜色的组合。

- R2_MERGEPEN像素是笔颜色和屏幕颜色（最终像素 + 笔或屏幕像素）的组合。

- R2_NOTMERGEPEN像素是R2_MERGEPEN颜色的反面（最终像素 = NOT（笔或屏幕像素）。

- R2_MASKPEN像素是笔和屏幕共有颜色的组合（最终像素 = 笔和屏幕像素）。

- R2_NOTMASKPEN像素是R2_MASKPEN颜色的反面（最终像素 = NOT（笔和屏幕像素）。

- R2_XORPEN像素是笔中或屏幕中的颜色的组合，但不是两者（最终像素 = 笔 XOR 屏幕像素）。

- R2_NOTXORPEN像素是R2_XORPEN颜色的反面（最终像素 = NOT（笔 XOR 屏幕像素）。

### <a name="return-value"></a>返回值

上一个绘图模式。

它可以是 Windows SDK 中给出的任何值。

### <a name="remarks"></a>备注

绘图模式指定笔的颜色和填充对象的内部如何与显示表面上已有的颜色组合。

绘图模式仅适用于栅格设备;它不适用于矢量设备。 绘图模式是二进制栅格操作代码，表示两个变量的所有可能的布尔组合，使用二进制运算符 AND、OR 和 XOR（独占 OR）和一元操作 NOT。

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC：：设置拉伸模式

设置成员函数的`StretchBlt`位图拉伸模式。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>参数

*n 拉伸模式*<br/>
指定拉伸模式。 可以是以下任一值：

|“值”|说明|
|-----------|-----------------|
|布莱克翁白|使用消除像素和现有像素的颜色值执行布尔和操作。 如果位图是单色位图，则此模式将保留黑色像素，而牺牲了白色像素。|
|彩色彩色|删除像素。 此模式删除所有已消除的像素行，而无需尝试保留其信息。|
|半 色调|将源矩形中的像素映射到目标矩形中的像素块。 目标像素块上的平均颜色近似于源像素的颜色。|
||设置 HALFTONE 拉伸模式后，应用程序必须调用 Win32 函数[SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex)来设置画笔原点。 如果未能这样做，则会发生画笔失调。|
|STRETCH_ANDSCANS|**视窗 95/98**： 与布莱克白相同|
|STRETCH_DELETESCANS|**视窗 95/98**： 与彩色|
|STRETCH_HALFTONE|**视窗95/98**：与HALFTONE相同。|
|STRETCH_ORSCANS|**视窗 95/98**： 与怀特黑|
|怀特顿布莱克|使用消除像素和现有像素的颜色值执行布尔或操作。 如果位图是单色位图，则此模式将保留白色像素，而牺牲了黑色像素。|

### <a name="return-value"></a>返回值

上一个拉伸模式。 它可以是STRETCH_ANDSCANS、STRETCH_DELETESCANS或STRETCH_ORSCANS。

### <a name="remarks"></a>备注

位图拉伸模式定义如何使用 函数从压缩的位图中删除信息。

黑白（STRETCH_ANDSCANS）和白（STRETCH_ORSCANS）模式通常用于在单色位图中保留前景像素。 COLORONCOLOR （STRETCH_DELETESCANS） 模式通常用于在颜色位图中保留颜色。

HALFTONE 模式比其他三种模式需要更多的源图像处理;它比其他图像慢，但会产生更高质量的图像。 另请注意，`SetBrushOrgEx`在设置 HALFTONE 模式后必须调用，以避免画笔失调。

根据设备驱动程序的功能，其他拉伸模式也可能可用。

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC：：设置文本对齐

设置文本对齐标志。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
指定文本对齐标志。 标志指定点和限制文本的矩形之间的关系。 该点可以是文本输出函数指定的当前位置或坐标。 限定文本的矩形由文本字符串中的相邻字符单元格定义。 *nFlags*参数可以是以下三个类别中的一个或多个标志。 每个类别中仅选择一个标志。 第一个类别影响 x 方向上的文本对齐：

- TA_CENTER将点与边界矩形的水平中心对齐。

- TA_LEFT 将点与边界矩形的左侧对齐。 这是默认设置。

- TA_RIGHT 将点与边界矩形的右侧对齐。

第二个类别影响 y 方向的文本对齐：

- TA_BASELINE 将点与所选字体的基线对齐。

- TA_BOTTOM 将点与边界矩形的底部对齐。

- TA_TOP 将点与边界矩形的顶部对齐。 这是默认设置。

第三个类别确定在编写文本时是否更新当前位置：

- TA_NOUPDATECP每次调用文本输出函数后不更新当前位置。 这是默认设置。

- TA_UPDATECP 每次调用文本输出函数后更新当前 x 位置。 新位置位于文本边界矩形的右侧。 设置此标志时，将忽略对成员函数的调用中`TextOut`指定的坐标。

### <a name="return-value"></a>返回值

以前的文本对齐设置（如果成功）。 低阶字节包含水平设置，高阶字节包含垂直设置;否则 0。

### <a name="remarks"></a>备注

在`TextOut`显示器`ExtTextOut`或设备上定位文本字符串时，和成员函数使用这些标志。 标志指定特定点与限制文本的矩形之间的关系。 此点的坐标作为参数传递给`TextOut`成员函数。 绑定文本的矩形由文本字符串中的相邻字符单元格组成。

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC：：设置文本字符额外

设置字符间间距的量。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>参数

*n查尔特*<br/>
指定要添加到每个字符的额外空间量（以逻辑单位为单位）。 如果当前映射模式不是`MM_TEXT`，则*nCharExtra*将变换并舍入到最近的像素。

### <a name="return-value"></a>返回值

上一个字符间距的量。

### <a name="remarks"></a>备注

GDI 向每个字符（包括中断字符）向设备上下文写入文本行时，都会将此间距添加到其中。 字符间间距量的默认值为 0。

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC：：设置文本颜色

将文本颜色设置为指定颜色。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>参数

*crColor*<br/>
指定文本的颜色为 RGB 颜色值。

### <a name="return-value"></a>返回值

上一个文本颜色的 RGB 值。

### <a name="remarks"></a>备注

系统在将文本写入此设备上下文时以及在颜色和单色设备上下文之间转换位图时将使用此文本颜色。

如果设备无法表示指定颜色，系统将文本颜色设置为最接近的物理颜色。 字符的背景颜色由`SetBkColor`和`SetBkMode`成员函数指定。

### <a name="example"></a>示例

  请参阅[CWnd 的示例：OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC：：设置文本对齐

向字符串中的分隔符添加空间。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>参数

*nBreakExtra*<br/>
指定要添加到文本行的总额外空间（以逻辑单位表示）。 如果当前映射模式不是`MM_TEXT`，则此参数给出的值将转换为当前映射模式，并舍入到最近的设备单元。

*n突破计数*<br/>
指定行中的中断字符数。

### <a name="return-value"></a>返回值

如果函数成功，则为否则 0。

### <a name="remarks"></a>备注

应用程序可以使用`GetTextMetrics`成员函数检索字体的中断字符。

调用`SetTextJustification`成员函数后，对文本输出函数的调用（如`TextOut`） 在指定的中断字符数之间均匀分布指定的额外空格。 分隔符通常是空格字符 （ASCII 32），但可以通过字体定义为其他字符。

成员函数`GetTextExtent`通常与 一起使用`SetTextJustification`。 `GetTextExtent`在对齐之前计算给定线的宽度。 应用程序可以通过在对齐后`GetTextExtent`从字符串宽度中减去返回的值来确定在*nBreakExtra*参数中指定的空间量。

该`SetTextJustification`函数可用于对齐包含不同字体的多个运行的行。 在这种情况下，必须通过单独对齐和写入每个运行来零敲碎打地创建行。

由于在对齐过程中可能发生舍入错误，因此系统保留定义当前错误的运行错误术语。 对齐包含多个运行的行时，`GetTextExtent`在计算下一次运行的范围时，会自动使用此错误术语。 这允许文本输出函数将错误混合到新运行中。

每行对齐后，必须清除此错误术语，以防止将其合并到下一行中。 可以通过调用`SetTextJustification` *nBreakExtra*设置为 0 来清除该术语。

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC：：SetViewportExt

设置设备上下文视口的 x 和 y 范围。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>参数

*残雪*<br/>
指定视口的 x 范围（以设备单位为单位）。

*cy*<br/>
指定视口的 y 范围（以设备单位为单位）。

size <br/>
指定视口的 x 和 y 范围（以设备单位为单位）。

### <a name="return-value"></a>返回值

视口作为[CSize](../../atl-mfc-shared/reference/csize-class.md)对象的上一个扩展盘区。 发生错误时，返回`CSize`对象的 x 坐标和 y 坐标都设置为 0。

### <a name="remarks"></a>备注

视口以及设备上下文窗口定义 GDI 如何将逻辑坐标系中的点映射到实际设备坐标系中的点。 换句话说，它们定义了 GDI 如何将逻辑坐标转换为设备坐标。

设置以下映射模式时，将忽略调用`SetWindowExt`和`SetViewportExt`：

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

设置MM_ISOTROPIC模式时，应用程序必须在调用`SetWindowExt``SetViewportExt`之前调用成员函数。

### <a name="example"></a>示例

  请参阅[CView 的示例：：在准备DC](../../mfc/reference/cview-class.md#onpreparedc)上。

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC：：SetViewportOrg

设置设备上下文的视口源。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定视口原点的 x 坐标（以设备单位为单位）。 该值必须在设备坐标系的范围内。

*Y*<br/>
指定视口原点的 y 坐标（以设备单位为单位）。 该值必须在设备坐标系的范围内。

*点*<br/>
指定视口的原点。 这些值必须在设备坐标系的范围内。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

视口（在设备坐标中）作为对象的上一个`CPoint`原点。

### <a name="remarks"></a>备注

视口以及设备上下文窗口定义 GDI 如何将逻辑坐标系中的点映射到实际设备坐标系中的点。 换句话说，它们定义了 GDI 如何将逻辑坐标转换为设备坐标。

视点原点标记 GDI 映射到窗口原点的设备坐标系中的点，该点是成员函数指定的逻辑坐标系中的`SetWindowOrg`一个点。 GDI 遵循将窗口原点映射到视口原点所需的相同过程来映射所有其他点。 例如，围绕窗口原点的圆中的所有点都将在视口原点的圆中。 同样，通过窗口原点行中的所有点都将位于穿过视口原点的行中。

### <a name="example"></a>示例

  请参阅[CView 的示例：：在准备DC](../../mfc/reference/cview-class.md#onpreparedc)上。

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC：：设置窗口Ext

设置与设备上下文关联的窗口的 x 和 y 范围。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>参数

*残雪*<br/>
指定窗口的 x 范围（以逻辑单位为单位）。

*cy*<br/>
指定窗口的 y 范围（以逻辑单位为单位）。

size <br/>
指定窗口的 x 和 y 范围（以逻辑单位表示）。

### <a name="return-value"></a>返回值

窗口（逻辑单位）作为对象的上一个`CSize`范围。 如果发生错误，则返回`CSize`对象的 x 坐标和 y 坐标都设置为 0。

### <a name="remarks"></a>备注

该窗口以及设备上下文视口定义 GDI 如何将逻辑坐标系中的点映射到设备坐标系中的点。

设置以下映射模式时，将忽略对`SetWindowExt`和`SetViewportExt`函数的调用：

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

设置MM_ISOTROPIC模式时，应用程序必须在调用`SetWindowExt``SetViewportExt`之前调用成员函数。

### <a name="example"></a>示例

  请参阅[CView 的示例：：在准备DC](../../mfc/reference/cview-class.md#onpreparedc)上。

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC：：设置窗口组织

设置设备上下文的窗口源。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>参数

*x*<br/>
指定窗口新源的逻辑 x 坐标。

*Y*<br/>
指定窗口新源的逻辑 y 坐标。

*点*<br/>
指定窗口新源的逻辑坐标。 可以传递此参数`POINT`的结构或`CPoint`对象。

### <a name="return-value"></a>返回值

窗口作为对象的上一个`CPoint`原点。

### <a name="remarks"></a>备注

该窗口以及设备上下文视口定义 GDI 如何将逻辑坐标系中的点映射到设备坐标系中的点。

窗口原点标记逻辑坐标系中的点，GDI 从该点映射视点原点，即`SetWindowOrg`函数指定的设备坐标系中的点。 GDI 遵循将窗口原点映射到视口原点所需的相同过程来映射所有其他点。 例如，围绕窗口原点的圆中的所有点都将在视口原点的圆中。 同样，通过窗口原点行中的所有点都将位于穿过视口原点的行中。

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC：：设置世界转换

设置指定设备上下文的世界空间和页面空间之间的二维线性变换。 此转换可用于缩放、旋转、剪切或转换图形输出。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>参数

*rXform*<br/>
对包含转换数据的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构的引用。

### <a name="return-value"></a>返回值

返回成功时的非零值。

失败后返回 0。

要获取扩展的错误信息，请致电[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)。

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC：：启动文档

通知设备驱动程序新的打印作业正在启动，并且所有后续`StartPage`调用和`EndPage`调用都应在同一`EndDoc`作业下进行后台化，直到发生调用。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>参数

*lpDocInfo*<br/>
指向包含文档文件名称和输出文件名称的[DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow)结构。

*lpszDoc名称*<br/>
指向包含文档文件名称的字符串的指针。

### <a name="return-value"></a>返回值

如果函数成功，则返回值大于零。 此值是文档的打印作业标识符。

如果函数失败，则返回值小于或等于零。

### <a name="remarks"></a>备注

这可确保文档超过一页的时间不会与其他作业穿插。

对于 Windows 版本 3.1 及更高版本，此功能将替换 STARTDOC 打印机转义。 使用此函数可确保包含多个页面的文档不会与其他打印作业穿插。

`StartDoc`不应在元文件中使用。

### <a name="example"></a>示例

此代码片段获取默认打印机，打开打印作业，并用"你好，世界！ 上它。 由于此代码打印的文本未缩放到打印机的逻辑单位，因此输出文本可能以小写字母表示无法读取的结果。 CDC 缩放函数（如`SetMapMode`、`SetViewportOrg`和`SetWindowExt`） 可用于修复缩放。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC：：起始页

调用此成员函数以准备打印机驱动程序以接收数据。

```
int StartPage();
```

### <a name="return-value"></a>返回值

如果函数成功，大于或等于 0;如果发生错误，则为负值。

### <a name="remarks"></a>备注

`StartPage`取代新帧和班德福逃生。

有关打印调用序列的概述，请参阅[StartDoc](#startdoc)成员函数。

系统禁用对 和`ResetDC``StartPage``EndPage`调用 之间的成员功能。

### <a name="example"></a>示例

  请参阅 CDC[的示例：：StartDoc](#startdoc)。

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC：：拉伸Blt

将位图从源矩形复制到目标矩形，必要时可拉伸或压缩位图以符合目标矩形的尺寸。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>参数

*x*<br/>
指定目标矩形左上角的 x 坐标（使用逻辑单位）。

*Y*<br/>
指定目标矩形左上角的 y 坐标（使用逻辑单位）。

*n 宽度*<br/>
指定目标矩形的宽度（使用逻辑单位）。

*nHeight*<br/>
指定目标矩形的高度（使用逻辑单位）。

*pSrcDC*<br/>
指定源设备上下文。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（使用逻辑单位）。

*伊斯尔克*<br/>
指定源矩形左上角的 y 坐标（使用逻辑单位）。

*nSrcWidth*<br/>
指定源矩形的宽度（使用逻辑单位）。

*nSrcHeight*<br/>
指定源矩形的高度（使用逻辑单位）。

*dwRop*<br/>
指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、可能的源位图和目标位图的输出操作中的颜色。 该参数可能是下列值之一：

- 黑色将所有输出变为黑色。

- DSTINVERT 反转目标位图。

- MERGECOPY 使用布尔和运算符组合模式和源位图。

- MERGEPAINT 使用布尔或运算符将倒源位图与目标位图合并。

- NOTSRCCOPY 将倒源位图复制到目标。

- NOTSRCERASE 反转使用布尔或运算符组合目标位图和源位图的结果。

- PATCOPY 将模式复制到目标位图。

- PATINVERT 使用布尔 XOR 运算符将目标位图与模式相结合。

- PATPAINT 使用布尔或运算符将倒源位图与模式相结合。 使用布尔 OR 运算符合并该操作的结果与目标位图。

- SRCAND 使用布尔和运算符组合目标像素和源位图。

- SRCCOPY 将源位图复制到目标位图。

- SRCERASE 反转目标位图，并使用布尔和运算符将结果与源位图合并。

- SRCINVERT 使用布尔 XOR 运算符合并目标像素和源位图。

- SRCPAINT 使用布尔或运算符合并目标像素和源位图。

- 白色将所有输出变为白色。

### <a name="return-value"></a>返回值

如果绘制出位图，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该函数使用目标设备上下文的拉伸模式（由 `SetStretchBltMode` 设置）确定如何拉伸或压缩位图。

该`StretchBlt`函数将位图从*pSrcDC*给出的源设备移动到由正在调用其成员函数的设备上下文对象表示的目标设备。 xSrc、ySrc、nSrcWidth 和*nSrcHeight*参数定义源矩形的左上角和尺寸。 *xSrc* *ySrc* *nSrcWidth* *x、y、nWidth*和*nHeight*参数提供目标矩形的左上角和尺寸。 *x* *nWidth* *dwRop*指定的栅格操作定义如何组合源位图和目标设备上已有的位图。

如果`StretchBlt` *nSrcWidth*和 nWidth 或*nSrcHeight 和 nSrcHeight*参数的*nHeight*符号不同，则函数将创建位图的镜像。 *nWidth* 如果*nSrcWidth*和*nWidth*具有不同的符号，则函数会沿 x 轴创建位图的镜像。 如果*nSrcHeight*和*nHeight*具有不同的符号，则函数会沿 y 轴创建位图的镜像。

`StretchBlt` 函数将在内存中拉伸或压缩源位图，然后将结果复制到目标。 如果一个模式将与该结果合并，则合并操作会等到拉伸的源位图复制到目标后执行。 如果使用画笔，则为在目标设备上下文中选择的画笔。 目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。

如果目标位图、源位图和模式位图没有相同的颜色格式，`StretchBlt` 将转换源位图和模式位图，以与目标位图匹配。 在转换中将使用目标设备上下文的前景色和背景色。

如果 `StretchBlt` 必须将单色位图转换为彩色，则会将白色位 (1) 设置为背景色，黑色位 (0) 设置为前景色。 若要将彩色位图转换为单色，它会将与背景色匹配的像素设置为白色 (1)，其他所有像素设置为黑色 (0)。 在转换中将使用彩色设备上下文的前景色和背景色。

不是所有的设备都支持 `StretchBlt` 函数。 要确定设备是否支持`StretchBlt`，请使用`GetDeviceCaps`RASTERCAPS 索引调用成员函数，并检查RC_STRETCHBLT标志的返回值。

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC：：中风和填充路径

关闭路径中的任何打开图形，使用当前笔绘制路径轮廓，并使用当前画笔填充其内部。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含闭合路径。 `StrokeAndFillPath`成员函数的效果与关闭路径中的所有打开图形以及单独抚摸和填充路径的效果相同，只不过即使笔宽，填充区域也不会与描边区域重叠。

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC：中风路径

使用当前笔渲染指定的路径。

```
BOOL StrokePath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含闭合路径。

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC：：Tabbed文本出

调用此成员函数在指定位置写入字符串，将选项卡扩展到制表停止位置数组中指定的值。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>参数

*x*<br/>
指定字符串起始点的逻辑 x 坐标。

*Y*<br/>
指定字符串起始点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。 可以传递指向字符数组的指针或此参数的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向[的字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTab*<br/>
指定制表位数组中的值数。

*lpnTabStop位置*<br/>
指向包含制表位（以逻辑单位）的数组。 必须按增加的顺序对制表位进行排序;最小的 x 值应该是数组中的第一个项。

*nTab原*<br/>
指定展开制表符的起始位置的 x 坐标（以逻辑单位表示）。

*Str*<br/>
包含`CString`指定字符的对象。

### <a name="return-value"></a>返回值

字符串的尺寸（以逻辑单位为单位）作为`CSize`对象。

### <a name="remarks"></a>备注

文本以当前选定的字体书写。 如果*nTabPositions*为 0，*并且 lpnTabStopPositions*为 NULL，则选项卡将扩展到平均字符宽度的八倍。

如果*nTabPositions*为 1，则制表位由*lpnTabStopPositions*数组中第一个值指定的距离分隔。 如果*lpnTabStopPositions*数组包含多个值，则为数组中的每个值设置一个制表位，最多为*nTabPositions*指定的数字。 *nTabOrigin*参数允许应用程序多次为一行`TabbedTextOut`调用函数。 如果应用程序多次调用函数，每次将*nTabOrigin*设置为相同的值，则函数将相对于*nTabOrigin*指定的位置展开所有选项卡。

默认情况下，函数不使用或更新当前位置。 如果应用程序在调用函数时需要更新当前位置，则应用程序可以调用[SetTextAlign](#settextalign)成员函数 *，nFlags*设置为TA_UPDATECP。 设置此标志时，Windows 会忽略后续调用`TabbedTextOut`的*x*和*y*参数，而是使用当前位置。

## <a name="cdctextout"></a><a name="textout"></a>CDC：：文本出

使用当前选定的字体在指定位置写入字符串。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>参数

*x*<br/>
指定文本起点的逻辑 x 坐标。

*Y*<br/>
指定文本起点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。

*nCount*<br/>
指定字符串中的字符数。

*Str*<br/>
包含要绘制的字符的 `CString` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

字符原点位于字符单元格的左上角。 默认情况下，函数不使用或更新当前位置。

如果应用程序在调用`TextOut`时需要更新当前位置，则应用程序可以调用成员函数`SetTextAlign`*，nFlags*设置为TA_UPDATECP。 设置此标志时，Windows 会忽略后续调用`TextOut`的*x*和*y*参数，而是使用当前位置。

### <a name="example"></a>示例

  请参阅 CDC 的示例[：：开始路径](#beginpath)。

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC：：透明布拉特

调用此成员函数以将颜色数据的位块（对应于指定源设备上下文的像素矩形）传输到目标设备上下文。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>参数

*xDest*<br/>
指定目标矩形左上角的 x 坐标（以逻辑单位表示）。

*yDest*<br/>
指定目标矩形左上角的 y 坐标（以逻辑单位表示）。

*nD最大宽度*<br/>
指定目标矩形的宽度（以逻辑单位为单位）。

*nDestHeight*<br/>
指定目标矩形的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向源设备上下文的指针。

*xSrc*<br/>
指定源矩形的 x 坐标（以逻辑单位表示）。

*伊斯尔克*<br/>
指定源矩形的 y 坐标（以逻辑单位表示）。

*nSrcWidth*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nSrcHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*clr透明*<br/>
源位图中的 RGB 颜色，视为透明。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

`TransparentBlt`允许透明度;也就是说 *，clrTransparent*指示的 RGB 颜色对于传输呈现为透明。

有关详细信息，请参阅 Windows SDK 中的[透明 Blt。](/windows/win32/api/wingdi/nf-wingdi-transparentblt)

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC：：更新颜色

通过将工作区中的当前颜色逐像素匹配到系统调色板，更新设备上下文的工作区。

```cpp
void UpdateColors();
```

### <a name="remarks"></a>备注

当系统调色板发生更改时，具有已实现逻辑`UpdateColors`调色板的非活动窗口可能会调用作为重新绘制其工作区的替代方法。

有关使用调色板的详细信息，请参阅 Windows SDK 中的["更新颜色](/windows/win32/api/wingdi/nf-wingdi-updatecolors)"。

成员`UpdateColors`函数通常更新工作区的速度通常比重新绘制区域快。 但是，由于函数在系统调色板更改之前根据每个像素的颜色执行颜色转换，因此每次调用此函数都会丢失一些颜色精度。

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC：：宽道

将当前路径重新定义为，如果使用当前选择的笔在设备上下文中绘制路径，则将绘制路径的区域。

```
BOOL WidenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

仅当当前笔是`CreatePen`成员函数的第二个版本创建的几何笔，或者笔是使用 的第`CreatePen`一个版本创建的，并且宽度（以设备单位为单位）大于 1 时，此功能才成功。 设备上下文必须包含闭合路径。 路径中的任何 Bzier 曲线都将转换为接近加宽曲线的直线序列。 因此，调用后`WidenPath`路径中没有 Bzier 曲线。

## <a name="see-also"></a>请参阅

[CObject 类](../../mfc/reference/cobject-class.md)<br/>
[层次结构图表](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC 类](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC 类](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC 类](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC 类](../../mfc/reference/cmetafiledc-class.md)
