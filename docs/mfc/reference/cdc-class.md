---
title: CDC 类
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: bae2f9a5a4f39c4eeffe68cc33e744e44c6800c8
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78855440"
---
# <a name="cdc-class"></a>CDC 类

定义设备上下文对象的类。

## <a name="syntax"></a>语法

```
class CDC : public CObject
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|[CDC：： CDC](#cdc)|构造 `CDC` 对象。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CDC：： AbortDoc](#abortdoc)|终止当前的打印作业，删除自上次调用 `StartDoc` 成员函数以来应用程序写入到设备的所有内容。|
|[CDC：： AbortPath](#abortpath)|关闭并放弃设备上下文中的任何路径。|
|[CDC：： AddMetaFileComment](#addmetafilecomment)|将注释从缓冲区复制到指定的增强格式图元文件。|
|[CDC：： AlphaBlend](#alphablend)|显示具有透明或半透明像素的位图。|
|[CDC：： AngleArc](#anglearc)|绘制直线线段和弧线，并将当前位置移到弧线的结束点。|
|[CDC：： Arc](#arc)|绘制椭圆弧。|
|[CDC：： ArcTo](#arcto)|绘制椭圆弧。除了更新当前位置外，此函数与 `Arc`类似。|
|[CDC：： Attach](#attach)|将 Windows 设备上下文附加到此 `CDC` 对象。|
|[CDC：： BeginPath](#beginpath)|在设备上下文中打开路径方括号。|
|[CDC：： BitBlt](#bitblt)|从指定的设备上下文中复制位图。|
|[CDC：：弦](#chord)|绘制弦形（一种闭合图形，由椭圆和直线段的交集边界边界）。|
|[CDC：： CloseFigure](#closefigure)|关闭路径中的开放图形。|
|[CDC：： CreateCompatibleDC](#createcompatibledc)|创建与其他设备上下文兼容的内存设备上下文。 可以使用它在内存中准备映像。|
|[CDC：： CreateDC](#createdc)|创建特定设备的设备上下文。|
|[CDC：： CreateIC](#createic)|创建特定设备的信息上下文。 这提供了一种快速方法来获取设备信息，而无需创建设备上下文。|
|[CDC：:D eleteDC](#deletedc)|删除与此 `CDC` 对象相关联的 Windows 设备上下文。|
|[CDC：:D eleteTempMap](#deletetempmap)|由 `CWinApp` 空闲时间处理程序调用，以删除 `FromHandle`创建的任何临时 `CDC` 对象。 还会分离设备上下文。|
|[CDC：:D etach](#detach)|从此 `CDC` 对象分离 Windows 设备上下文。|
|[CDC：:D PtoHIMETRIC](#dptohimetric)|将设备单位转换为 HIMETRIC 单元。|
|[CDC：:D PtoLP](#dptolp)|将设备单位转换为逻辑单元。|
|[CDC：:D raw3dRect](#draw3drect)|绘制三维矩形。|
|[CDC：:D rawDragRect](#drawdragrect)|在拖动矩形时擦除并重绘该矩形。|
|[CDC：:D rawEdge](#drawedge)|绘制矩形的边缘。|
|[CDC：:D rawEscape](#drawescape)|访问不能通过图形设备接口（GDI）直接提供的视频显示器的绘图功能。|
|[CDC：:D rawFocusRect](#drawfocusrect)|用用于指示焦点的样式绘制矩形。|
|[CDC：:D rawFrameControl](#drawframecontrol)|绘制框架控件。|
|[CDC：:D rawIcon](#drawicon)|绘制图标。|
|[CDC：:D rawState](#drawstate)|显示图像并应用视觉效果以指示状态。|
|[CDC：:D rawText](#drawtext)|在指定的矩形中绘制格式化文本。|
|[CDC：:D rawTextEx](#drawtextex)|使用其他格式在指定的矩形中绘制格式化文本。|
|[CDC：：椭圆形](#ellipse)|绘制椭圆形。|
|[CDC：： EndDoc](#enddoc)|结束由 `StartDoc` 成员函数启动的打印作业。|
|[CDC：： EndPage](#endpage)|通知设备驱动程序页面即将结束。|
|[CDC：： EndPath](#endpath)|关闭路径方括号，并选择由括号定义的设备上下文中的路径。|
|[CDC：： EnumObjects](#enumobjects)|枚举设备上下文中可用的笔和画笔。|
|[CDC：： Escape](#escape)|允许应用程序通过 GDI 访问不能从特定设备直接访问的设备。 还允许访问 Windows escape 函数。 转换应用程序发出的转义调用，并将其发送到设备驱动程序。|
|[CDC：： ExcludeClipRect](#excludecliprect)|创建一个新的剪辑区域，其中包含的现有剪辑区域减去指定的矩形。|
|[CDC：： ExcludeUpdateRgn](#excludeupdatergn)|通过从剪辑区域中排除窗口中的更新区域，防止在窗口的无效区域中进行绘制。|
|[CDC：： ExtFloodFill](#extfloodfill)|使用当前画笔填充区域。 比[CDC：： FloodFill](#floodfill)成员函数具有更大的灵活性。|
|[CDC：： ExtTextOut](#exttextout)|使用当前选定的字体在矩形区域中写入一个字符串。|
|[CDC：： FillPath](#fillpath)|关闭当前路径中的所有打开的图形，并使用当前画笔和多边形填充模式填充路径内部。|
|[CDC：： FillRect](#fillrect)|使用特定画笔填充给定矩形。|
|[CDC：： FillRgn](#fillrgn)|使用指定的画笔填充特定区域。|
|[CDC：： FillSolidRect](#fillsolidrect)|用纯色填充矩形。|
|[CDC：： FlattenPath](#flattenpath)|将所选路径中的任意曲线转换为当前设备上下文，并将每条曲线变为一系列线条。|
|[CDC：： FloodFill](#floodfill)|使用当前画笔填充区域。|
|[CDC：： FrameRect](#framerect)|在矩形周围绘制边框。|
|[CDC：： FrameRgn](#framergn)|使用画笔在特定区域周围绘制边框。|
|[CDC：： FromHandle](#fromhandle)|当给定设备上下文的句柄时，返回指向 `CDC` 对象的指针。 如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。|
|[CDC：： GetArcDirection](#getarcdirection)|返回设备上下文的当前弧线方向。|
|[CDC：： GetAspectRatioFilter](#getaspectratiofilter)|检索当前纵横比筛选器的设置。|
|[CDC：： GetBkColor](#getbkcolor)|检索当前背景色。|
|[CDC：： GetBkMode](#getbkmode)|检索后台模式。|
|[CDC：： GetBoundsRect](#getboundsrect)|返回指定设备上下文的当前累积边界矩形。|
|[CDC：： GetBrushOrg](#getbrushorg)|检索当前画笔的原点。|
|[CDC：： GetCharABCWidths](#getcharabcwidths)|从当前字体检索给定范围内的连续字符的宽度（以逻辑单位为单位）。|
|[CDC：： GetCharABCWidthsI](#getcharabcwidthsi)|从当前 TrueType 字体检索指定范围内连续标志符号索引的宽度（以逻辑单位表示）。|
|[CDC：： GetCharacterPlacement](#getcharacterplacement)|检索字符串上的各种类型的信息。|
|[CDC：： GetCharWidth](#getcharwidth)|从当前字体检索给定范围内连续字符的小数宽度。|
|[CDC：： GetCharWidthI](#getcharwidthi)|从当前字体检索指定范围内连续标志符号索引的宽度（以逻辑坐标表示）。|
|[CDC：： GetClipBox](#getclipbox)|检索围绕当前剪辑边界的紧密边框的尺寸。|
|[CDC：： GetColorAdjustment](#getcoloradjustment)|检索设备上下文的颜色调整值。|
|[CDC：： GetCurrentBitmap](#getcurrentbitmap)|返回指向当前选定 `CBitmap` 对象的指针。|
|[CDC：： GetCurrentBrush](#getcurrentbrush)|返回指向当前选定 `CBrush` 对象的指针。|
|[CDC：： GetCurrentFont](#getcurrentfont)|返回指向当前选定 `CFont` 对象的指针。|
|[CDC：： GetCurrentPalette](#getcurrentpalette)|返回指向当前选定 `CPalette` 对象的指针。|
|[CDC：： GetCurrentPen](#getcurrentpen)|返回指向当前选定 `CPen` 对象的指针。|
|[CDC：： GetCurrentPosition](#getcurrentposition)|检索笔的当前位置（以逻辑坐标表示）。|
|[CDC：： GetDCBrushColor](#getdcbrushcolor)|检索当前画笔的颜色。|
|[CDC：： GetDCPenColor](#getdcpencolor)|检索当前的钢笔颜色。|
|[CDC：： GetDeviceCaps](#getdevicecaps)|检索特定类型的设备特定的有关特定显示设备功能的信息。|
|[CDC：： GetFontData](#getfontdata)|从可缩放的字体文件中检索字体指标信息。 通过指定字体文件中的偏移量和要返回的信息的长度来标识要检索的信息。|
|[CDC：： GetFontLanguageInfo](#getfontlanguageinfo)|返回指定显示上下文的当前选定字体的相关信息。|
|[CDC：： GetGlyphOutline](#getglyphoutline)|检索当前字体中的轮廓字符的轮廓曲线或位图。|
|[CDC：： GetGraphicsMode](#getgraphicsmode)|检索指定设备上下文的当前图形模式。|
|[CDC：： GetHalftoneBrush](#gethalftonebrush)|检索半色调画笔。|
|[CDC：： GetKerningPairs](#getkerningpairs)|检索指定设备上下文中当前选定字体的字符字偶间距对。|
|[CDC：： GetLayout](#getlayout)|检索设备上下文（DC）的布局。 布局可以是从左到右（默认值），也可以是从右到左（镜像）。|
|[CDC：： GetMapMode](#getmapmode)|检索当前映射模式。|
|[CDC：： GetMiterLimit](#getmiterlimit)|返回设备上下文的斜接限制。|
|[CDC：： GetNearestColor](#getnearestcolor)|检索与给定设备可表示的指定逻辑颜色最接近的逻辑颜色。|
|[CDC：： GetOutlineTextMetrics](#getoutlinetextmetrics)|检索 TrueType 字体的字体指标信息。|
|[CDC：： GetOutputCharWidth](#getoutputcharwidth)|使用输出设备上下文从当前字体中检索连续字符组中各个字符的宽度。|
|[CDC：： GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|计算输出设备上下文中字符串的宽度和高度。|
|[CDC：： GetOutputTextExtent](#getoutputtextextent)|使用当前字体确定维度，计算输出设备上下文上某个文本行的宽度和高度。|
|[CDC：： GetOutputTextMetrics](#getoutputtextmetrics)|从输出设备上下文中检索当前字体的指标。|
|[CDC：： GetPath](#getpath)|检索定义线条终结点和在设备上下文中选择的路径中找到的曲线的控制点的坐标。|
|[CDC：： Picture.getpixel](#getpixel)|检索位于指定点处的像素的 RGB 颜色值。|
|[CDC：： GetPolyFillMode](#getpolyfillmode)|检索当前多边形填充模式。|
|[CDC：： GetROP2](#getrop2)|检索当前的绘制模式。|
|[CDC：： GetSafeHdc](#getsafehdc)|返回[CDC：： m_hDC](#m_hdc)，输出设备上下文。|
|[CDC：： GetStretchBltMode](#getstretchbltmode)|检索当前位图拉伸模式。|
|[CDC：： GetTabbedTextExtent](#gettabbedtextextent)|计算属性设备上下文上字符串的宽度和高度。|
|[CDC：： GetTextAlign](#gettextalign)|检索文本对齐标志。|
|[CDC：： GetTextCharacterExtra](#gettextcharacterextra)|检索 intercharacter 间距量的当前设置。|
|[CDC：： GetTextColor](#gettextcolor)|检索当前文本颜色。|
|[CDC：： GetTextExtent](#gettextextent)|使用当前字体确定维度，计算属性设备上下文上某个文本行的宽度和高度。|
|[CDC：： GetTextExtentExPointI](#gettextextentexpointi)|检索指定字符串中将适合指定空间的字符数，并用其中每个字符的文本范围填充数组。|
|[CDC：： GetTextExtentPointI](#gettextextentpointi)|检索指定标志符号索引数组的宽度和高度。|
|[CDC：： GetTextFace](#gettextface)|将当前字体的字样名称作为以 null 结尾的字符串复制到缓冲区中。|
|[CDC：： GetTextMetrics](#gettextmetrics)|从属性设备上下文中检索当前字体的指标。|
|[CDC：： GetViewportExt](#getviewportext)|检索视区的 x 和 y 范围。|
|[CDC：： GetViewportOrg](#getviewportorg)|检索视区原点的 x 坐标和 y 坐标。|
|[CDC：： GetWindow](#getwindow)|返回与显示设备上下文关联的窗口。|
|[CDC：： GetWindowExt](#getwindowext)|检索关联窗口的 x 和 y 范围。|
|[CDC：： GetWindowOrg](#getwindoworg)|检索关联窗口原点的 x 坐标和 y 坐标。|
|[CDC：： GetWorldTransform](#getworldtransform)|检索当前世界空间到页面空间的转换。|
|[CDC：： GradientFill](#gradientfill)|用 gradating 颜色填充矩形和三角形结构。|
|[CDC：： GrayString](#graystring)|在给定位置绘制灰显（灰显）文本。|
|[CDC：： HIMETRICtoDP](#himetrictodp)|将 HIMETRIC 单位转换为设备单位。|
|[CDC：： HIMETRICtoLP](#himetrictolp)|将 HIMETRIC 单位转换为逻辑单元。|
|[CDC：： IntersectClipRect](#intersectcliprect)|通过形成当前区域和矩形的交集，来创建一个新的剪辑区域。|
|[CDC：： InvertRect](#invertrect)|反转矩形的内容。|
|[CDC：： InvertRgn](#invertrgn)|反转区域中的颜色。|
|[CDC：： IsPrinting](#isprinting)|确定是否正在使用设备上下文进行打印。|
|[CDC：： LineTo](#lineto)|绘制从当前位置到点（但不包括）点的直线。|
|[CDC：： LPtoDP](#lptodp)|将逻辑单元转换为设备单位。|
|[CDC：： LPtoHIMETRIC](#lptohimetric)|将逻辑单元转换为 HIMETRIC 单元。|
|[CDC：： MaskBlt](#maskblt)|使用给定的掩码和光栅操作合并源和目标位图的颜色数据。|
|[CDC：： ModifyWorldTransform](#modifyworldtransform)|使用指定模式更改设备上下文的世界转换。|
|[CDC：： MoveTo](#moveto)|移动当前位置。|
|[CDC：： OffsetClipRgn](#offsetcliprgn)|移动给定设备的剪辑区域。|
|[CDC：： OffsetViewportOrg](#offsetviewportorg)|相对于当前视区原点的坐标修改视区原点。|
|[CDC：： OffsetWindowOrg](#offsetwindoworg)|相对于当前窗口原点的坐标修改窗口原点。|
|[CDC：:P aintRgn](#paintrgn)|使用所选画笔填充区域。|
|[CDC：:P atBlt](#patblt)|创建位模式。|
|[CDC：:P ie](#pie)|绘制扇形形楔形。|
|[CDC：:P layMetaFile](#playmetafile)|在给定设备上播放指定的元文件的内容。 `PlayMetaFile` 的增强版将显示存储在给定的增强格式图元文件中的图片。 可以任意次播放图元文件。|
|[CDC：:P lgBlt](#plgblt)|执行从源设备上下文中指定的矩形到给定设备上下文中指定的平行四边形的颜色数据位的位块传输。|
|[CDC：:P olyBezier](#polybezier)|绘制一个或多个 Bzier 样条。 当前位置既未使用也未更新。|
|[CDC：:P olyBezierTo](#polybezierto)|绘制一个或多个 Bzier 样条，并将当前位置移到最后一个 Bzier 样条的终点。|
|[CDC：:P olyDraw](#polydraw)|绘制一组直线段和 Bzier 样条。 此函数更新当前位置。|
|[CDC：:P olygon](#polygon)|绘制由两个或多个由线条连接的点（顶点）组成的多边形。|
|[CDC：:P olyline](#polyline)|绘制一组连接指定点的线段。|
|[CDC：:P olylineTo](#polylineto)|绘制一条或多条直线，并将当前位置移到最后一行的结束点。|
|[CDC：:P olyPolygon](#polypolygon)|创建两个或多个使用当前多边形填充模式填充的多边形。 多边形可能是不连续的，也可能是重叠的。|
|[CDC：:P olyPolyline](#polypolyline)|绘制多个连接的线段序列。 当前位置不被此函数使用或更新。|
|[CDC：:P tVisible](#ptvisible)|指定给定点是否在剪辑区域内。|
|[CDC：： RealizePalette](#realizepalette)|将当前逻辑调色板中的调色板项映射到系统调色板。|
|[CDC：： Rectangle](#rectangle)|使用当前笔绘制矩形，并使用当前画笔来填充它。|
|[CDC：： RectVisible](#rectvisible)|确定给定矩形的任何部分是否位于剪辑区域内。|
|[CDC：： ReleaseAttribDC](#releaseattribdc)|释放 `m_hAttribDC`，即特性设备上下文。|
|[CDC：： ReleaseOutputDC](#releaseoutputdc)|发布 `m_hDC`，输出设备上下文。|
|[CDC：： ResetDC](#resetdc)|更新 `m_hAttribDC` 设备上下文。|
|[CDC：： RestoreDC](#restoredc)|将设备上下文还原到以前与 `SaveDC`一起保存的状态。|
|[CDC：： RoundRect](#roundrect)|使用当前笔绘制带有圆角的矩形，并使用当前画笔填充。|
|[CDC：： SaveDC](#savedc)|保存设备上下文的当前状态。|
|[CDC：： ScaleViewportExt](#scaleviewportext)|相对于当前值修改视区区。|
|[CDC：： ScaleWindowExt](#scalewindowext)|修改相对于当前值的窗口区区。|
|[CDC：： ScrollDC](#scrolldc)|水平和垂直滚动位矩形。|
|[CDC：： SelectClipPath](#selectclippath)|选择当前路径作为设备上下文的剪辑区域，使用指定的模式将新的区域与任何现有的剪辑区域相结合。|
|[CDC：： SelectClipRgn](#selectcliprgn)|使用指定的模式将给定区域与当前剪辑区域组合在一起。|
|[CDC：： SelectObject](#selectobject)|选择 GDI 绘图对象，如笔。|
|[CDC：： SelectPalette](#selectpalette)|选择逻辑调色板。|
|[CDC：： SelectStockObject](#selectstockobject)|选择由 Windows 提供的预定义的毛坯笔、画笔或字体之一。|
|[CDC：： SetAbortProc](#setabortproc)|设置由程序员提供的回调函数，如果必须中止打印作业，Windows 将调用此函数。|
|[CDC：： SetArcDirection](#setarcdirection)|设置要用于弧线和矩形函数的绘制方向。|
|[CDC：： SetAttribDC](#setattribdc)|设置 `m_hAttribDC`属性设备上下文。|
|[CDC：： SetBkColor](#setbkcolor)|设置当前背景色。|
|[CDC：： SetBkMode](#setbkmode)|设置后台模式。|
|[CDC：： SetBoundsRect](#setboundsrect)|控制指定设备上下文的边界矩形信息的累计。|
|[CDC：： SetBrushOrg](#setbrushorg)|指定在设备上下文中选择的下一个画笔的原点。|
|[CDC：： SetColorAdjustment](#setcoloradjustment)|使用指定的值设置设备上下文的颜色调整值。|
|[CDC：： SetDCBrushColor](#setdcbrushcolor)|设置当前画笔颜色。|
|[CDC：： SetDCPenColor](#setdcpencolor)|设置当前笔颜色。|
|[CDC：： SetGraphicsMode](#setgraphicsmode)|为指定的设备上下文设置当前图形模式。|
|[CDC：： SetLayout](#setlayout)|更改设备上下文（DC）的布局。|
|[CDC：： SetMapMode](#setmapmode)|设置当前映射模式。|
|[CDC：： SetMapperFlags](#setmapperflags)|更改字体映射器在将逻辑字体映射到物理字体时使用的算法。|
|[CDC：： SetMiterLimit](#setmiterlimit)|设置设备上下文的斜切联接长度的限制。|
|[CDC：： SetOutputDC](#setoutputdc)|设置 `m_hDC`、输出设备上下文。|
|[CDC：： SetPixel](#setpixel)|将位于指定点处的像素设置为指定颜色最近的近似值。|
|[CDC：： SetPixelV](#setpixelv)|将指定坐标处的像素设置为指定颜色最近的近似值。 `SetPixelV` 比 `SetPixel` 快，因为它不需要返回实际绘制的点的颜色值。|
|[CDC：： SetPolyFillMode](#setpolyfillmode)|设置多边形填充模式。|
|[CDC：： SetROP2](#setrop2)|设置当前的绘制模式。|
|[CDC：： SetStretchBltMode](#setstretchbltmode)|设置位图拉伸模式。|
|[CDC：： SetTextAlign](#settextalign)|设置文本对齐标志。|
|[CDC：： SetTextCharacterExtra](#settextcharacterextra)|设置 intercharacter 间距量。|
|[CDC：： SetTextColor](#settextcolor)|设置文本颜色。|
|[CDC：： SetTextJustification](#settextjustification)|向字符串中的分隔字符添加空格。|
|[CDC：： SetViewportExt](#setviewportext)|设置视区的 x 和 y 范围。|
|[CDC：： SetViewportOrg](#setviewportorg)|设置视区为原点。|
|[CDC：： SetWindowExt](#setwindowext)|设置关联窗口的 x 和 y 范围。|
|[CDC：： SetWindowOrg](#setwindoworg)|设置设备上下文的窗口源。|
|[CDC：： SetWorldTransform](#setworldtransform)|将当前世界空间设置为页面空间转换。|
|[CDC：： StartDoc](#startdoc)|通知设备驱动程序，新的打印作业正在启动。|
|[CDC：： StartPage](#startpage)|通知设备驱动程序，新页面正在启动。|
|[CDC：： StretchBlt](#stretchblt)|将位图从源矩形和设备移动到目标矩形，如有必要，拉伸或压缩位图以适合目标矩形的尺寸。|
|[CDC：： StrokeAndFillPath](#strokeandfillpath)|关闭路径中的任何打开的图形，使用当前笔通过该路径的轮廓，并使用当前画笔填充其内部。|
|[CDC：： StrokePath](#strokepath)|使用当前笔呈现指定的路径。|
|[CDC：： TabbedTextOut](#tabbedtextout)|将字符串写入指定位置，并将选项卡展开为在制表位的数组中指定的值。|
|[CDC：： TextOut](#textout)|使用当前选定的字体在指定位置写入字符串。|
|[CDC：： TransparentBlt](#transparentblt)|将颜色数据的一个位块从指定的源设备上下文传输到目标设备上下文中，并在传输中呈现指定的透明颜色。|
|[CDC：： UpdateColors](#updatecolors)|通过将工作区中的当前颜色与系统调色板逐像素匹配，更新设备上下文的工作区。|
|[CDC：： WidenPath](#widenpath)|如果使用当前选择的笔在设备上下文中绘制路径，则将当前路径重新定义为要绘制的区域。|

### <a name="public-operators"></a>公共运算符

|名称|说明|
|----------|-----------------|
|[CDC：： operator HDC](#operator_hdc)|检索设备上下文的句柄。|

### <a name="public-data-members"></a>公共数据成员

|名称|说明|
|----------|-----------------|
|[CDC：： m_hAttribDC](#m_hattribdc)|此 `CDC` 对象使用的特性-设备上下文。|
|[CDC：： m_hDC](#m_hdc)|此 `CDC` 对象使用的输出设备上下文。|

## <a name="remarks"></a>备注

`CDC` 对象提供了用于处理设备上下文的成员函数（如显示或打印机），以及用于处理与窗口的工作区关联的显示上下文的成员。

通过 `CDC` 对象的成员函数执行所有绘制操作。 类为设备上下文操作提供成员函数，使用绘图工具、类型安全图形设备接口（GDI）对象选择以及使用颜色和调色板。 它还提供了成员函数，用于获取和设置绘图属性、映射、使用视区、处理窗口区、转换坐标、使用区域、剪辑、绘制线条以及绘制简单形状、省略号和多边形. 还提供了成员函数用于绘制文本、使用字体、使用打印机转义、滚动和播放图元文件。

若要使用 `CDC` 对象，请对其进行构造，然后调用其成员函数，这些函数将使用设备上下文的并行 Windows 函数。

> [!NOTE]
>  在 Windows 95/98 下，所有屏幕坐标限制为16位。 因此，传递到 `CDC` 成员函数的**int**必须位于32768到32767的范围内。

对于特定用途，Microsoft 基础类库提供了多个派生自 `CDC` 的类。 `CPaintDC` 封装对 `BeginPaint` 和 `EndPaint`的调用。 `CClientDC` 管理与窗口的工作区关联的显示上下文。 `CWindowDC` 管理与整个窗口（包括框架和控件）关联的显示上下文。 `CMetaFileDC` 将设备上下文与图元文件相关联。

`CDC` 提供了两个成员函数[GetLayout](#getlayout)和[SetLayout](#setlayout)，用于反转设备上下文的布局，而不从窗口继承其布局。 对于为区域性编写的应用程序（例如阿拉伯语或希伯来语），这种从右到左的方向是必需的，其中字符布局不是欧洲标准。

`CDC` 包含两个设备上下文： [m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，在创建 `CDC` 对象时，请引用同一设备。 `CDC` 将所有的输出 GDI 调用定向到 `m_hDC`，并且大多数属性的 GDI 调用都是 `m_hAttribDC`。 （`GetTextColor`属性调用的示例，`SetTextColor` 是一个输出调用。）

例如，框架使用这两个设备上下文来实现一个 `CMetaFileDC` 对象，该对象在从物理设备读取属性时将输出发送到图元文件。 在框架中采用类似的方式实现打印预览。 你还可以在特定于应用程序的代码中采用类似方式使用两个设备上下文。

有时可能需要来自 `m_hDC` 和 `m_hAttribDC` 设备上下文的文本指标信息。 下面对函数提供了此功能：

|使用 m_hAttribDC|使用 m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

有关 `CDC`的详细信息，请参阅[设备上下文](../../mfc/device-contexts.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>要求

**标头:** afxwin.h

##  <a name="abortdoc"></a>CDC：： AbortDoc

终止当前的打印作业，并在自上次调用[StartDoc](#startdoc)成员函数后清除应用程序写入设备的所有内容。

```
int AbortDoc();
```

### <a name="return-value"></a>返回值

如果成功，则为大于或等于0的值; 如果发生错误，则值为负值。 以下列表显示了常见错误值及其含义：

- SP_ERROR 常规错误。

- SP_OUTOFDISK 没有足够的磁盘空间可用于后台处理，且没有更多的可用空间。

- SP_OUTOFMEMORY 没有足够的内存可用于后台处理。

- SP_USERABORT 用户通过打印管理器终止了作业。

### <a name="remarks"></a>备注

此成员函数替换 ABORTDOC 打印机转义。

应使用 `AbortDoc` 来终止以下操作：

- 使用[SetAbortProc](#setabortproc)指定中止函数的打印操作。

- 尚未到达其第一个 NEWFRAME 或 NEXTBAND 转义调用的打印操作。

如果应用程序遇到打印错误或已取消的打印操作，则不能尝试使用类 `CDC`的[EndDoc](#enddoc)或 `AbortDoc` 成员函数终止操作。 GDI 在返回错误值之前会自动终止操作。

如果应用程序显示一个对话框，允许用户取消打印操作，则必须在销毁对话框之前调用 `AbortDoc`。

如果使用打印管理器来启动打印作业，则调用 `AbortDoc` 会擦除整个后台打印作业-打印机不接收任何内容。 如果打印管理器未用于启动打印作业，则在调用 `AbortDoc` 之前，可能已将数据发送到打印机。 在这种情况下，打印机驱动程序会重置打印机（如有可能）并关闭打印作业。

### <a name="example"></a>示例

  请参阅[CDC：： StartDoc](#startdoc)的示例。

##  <a name="abortpath"></a>CDC：： AbortPath

关闭并放弃设备上下文中的任何路径。

```
BOOL AbortPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果设备上下文中有一个开放路径方括号，路径方括号会关闭，路径将被丢弃。 如果设备上下文中有一个封闭路径，则会丢弃该路径。

##  <a name="addmetafilecomment"></a>CDC：： AddMetaFileComment

将注释从缓冲区复制到指定的增强格式图元文件。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>parameters

*nDataSize*<br/>
指定注释缓冲区的长度（以字节为单位）。

*pCommentData*<br/>
指向包含注释的缓冲区。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

注释可以包含任何专用信息，例如图片源和创建日期。 注释应以应用程序签名开头，后跟数据。 注释不应包含特定于位置的数据。 特定于位置的数据指定了记录的位置，并且不应包括该记录，因为一个元文件可以嵌入到另一个元文件中。 此函数只能用于增强型图元文件。

##  <a name="alphablend"></a>CDC：： AlphaBlend

调用此成员函数可显示具有透明或半透明像素的位图。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>parameters

*xDest*<br/>
指定目标矩形左上角的 x 坐标（以逻辑单位表示）。

*yDest*<br/>
指定目标矩形左上角的 y 坐标（以逻辑单位表示）。

*nDestWidth*<br/>
指定目标矩形的宽度（以逻辑单位为单位）。

*nDestHeight*<br/>
指定目标矩形的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向源设备上下文的指针。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（以逻辑单位为单位）。

*ySrc*<br/>
指定源矩形左上角的 y 坐标（以逻辑单位表示）。

*nSrcWidth*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nSrcHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*blend*<br/>
指定[BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction)结构。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅 Windows SDK 中的[AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) 。

##  <a name="anglearc"></a>CDC：： AngleArc

绘制直线线段和弧线。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定圆的中心的逻辑 x 坐标。

*y*<br/>
指定圆的中心的逻辑 y 坐标。

*nRadius*<br/>
指定以逻辑单元表示的圆的半径。 该值必须是正数。

*fStartAngle*<br/>
指定相对于 x 轴的起始角度（以度数为单位）。

*fSweepAngle*<br/>
指定相对于起始角度的扫描角度（以度为单位）。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

直线段从当前位置到弧线开头的位置绘制。圆弧沿具有给定半径和中心的圆的周长绘制。 圆弧的长度由给定的开始和扫描角度来定义。

`AngleArc` 将当前位置移到弧线的结束点。此函数绘制的弧形可能看上去是椭圆形的，具体取决于当前的转换模式和映射模式。 在绘制圆弧之前，此函数将从当前位置到弧线开头绘制直线段。通过用围绕指定中心点的指定半径构造虚圆圈来绘制圆弧。 圆弧的起点是通过从圆形的 x 轴逆时针测量起始角度的度数来确定的。 结束点的位置类似于从起始点逆时针测量扫描角度的度数。

如果扫描角度大于360度，则圆弧会多次扫描。 此函数使用当前笔绘制线条。 图形未填充。

##  <a name="arc"></a>CDC：： Arc

绘制椭圆弧。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定边框的左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边框的左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边框右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边框右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义弧线起点的点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y3*<br/>
指定定义弧线起点的点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*四*<br/>
指定定义弧线的端点的点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y4*<br/>
指定定义弧线的端点的点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*lpRect*<br/>
指定边框（以逻辑单位表示）。 可以为此参数传递 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*ptStart*<br/>
指定定义弧线起点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。可以为此参数传递[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定定义弧线结束点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用函数绘制的弧形是由指定边框定义的椭圆段。

弧形的实际起点是从边框中心绘制的射线到指定起点的点与椭圆相交的点。 弧形的实际结束点是从边框中心绘制的射线到指定结束点的点与椭圆相交的点。 以逆时针方向绘制弧。 由于圆弧不是闭合图形，因此不会填充它。 矩形的宽度和高度必须大于2个单位且小于32767个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>CDC：： ArcTo

绘制椭圆弧。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定边框的左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边框的左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边框右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边框右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义弧线起点的点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y3*<br/>
指定定义弧线起点的点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*四*<br/>
指定定义弧线的端点的点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y4*<br/>
指定定义弧线的端点的点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*lpRect*<br/>
指定边框（以逻辑单位表示）。 可以为此参数传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)数据结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象的指针。

*ptStart*<br/>
指定定义弧线起点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定定义弧线结束点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。可以为此参数传递 `POINT` 的数据结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

除了更新当前位置外，此函数与 `CDC::Arc`类似。 点（ *x1*， *y1*）和（ *x2*， *y2*）指定边框。 由给定边框形成的椭圆形定义弧线的曲线。圆弧从边框中心开始沿逆时针方向（默认弧线方向）向下（ *x3*， *y3*）相交。 该弧形结束时，从边框中心到（ *x4*， *y4*）的射线相交的位置。 如果起始点和终点相同，则绘制一个完整的椭圆。

将从当前位置到弧线起始点绘制线条。如果未发生错误，则将当前位置设置为弧线的结束点。使用当前笔绘制弧线;不会填充它。

##  <a name="attach"></a>CDC：： Attach

使用此成员函数将*hDC*附加到 `CDC` 的对象。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>parameters

*hDC*<br/>
Windows 设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*HDC*同时存储在 `m_hDC`、输出设备上下文和属性设备上下文 `m_hAttribDC`中。

##  <a name="beginpath"></a>CDC：： BeginPath

在设备上下文中打开路径方括号。

```
BOOL BeginPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

打开路径方括号后，应用程序可以开始调用 GDI 绘图函数以定义位于该路径中的点。 应用程序可以通过调用 `EndPath` 成员函数来关闭开放路径方括号。 当应用程序调用 `BeginPath`时，将丢弃以前的任何路径。

有关定义路径中的点的绘图函数的列表，请参阅 Windows SDK 中的[BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) 。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>CDC：： BitBlt

将位图从源设备上下文复制到此当前设备上下文。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*nWidth*<br/>
指定目标矩形和源位图的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定目标矩形和源位图的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向 `CDC` 对象的指针，该对象标识将从中复制位图的设备上下文。 如果*dwRop*指定不包括源的光栅操作，则必须为 NULL。

*xSrc*<br/>
指定源位图左上角的逻辑 x 坐标。

*ySrc*<br/>
指定源位图左上角的逻辑 y 坐标。

*dwRop*<br/>
指定要执行的光栅操作。 光栅操作代码定义 GDI 如何在输出操作中组合涉及当前画笔、可能的源位图和目标位图的颜色。 请参阅 Windows SDK 中的[BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) ，以获取*dwRop*的光栅操作代码的列表及其说明

有关光栅操作代码的完整列表，请参阅关于 Windows SDK 中的[光栅操作代码](/windows/win32/gdi/raster-operation-codes)。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

应用程序可以对齐字节边界上的窗口或客户端区域，以确保 `BitBlt` 操作在字节对齐的矩形上发生。 （在注册窗口类时设置 CS_BYTEALIGNWINDOW 或 CS_BYTEALIGNCLIENT 标志。）

与字节对齐的矩形上 `BitBlt` 操作的速度要快于对不是字节对齐的矩形 `BitBlt` 操作的速度。 如果要为自己的设备上下文指定类样式（如字节对齐），则必须注册窗口类，而不是依赖 Microsoft 基础类来执行此操作。 使用 global 函数[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

GDI 转换*nWidth*和*nHeight*，一次使用目标设备上下文，一次使用源设备上下文。 如果生成的范围不匹配，则 GDI 将使用 Windows `StretchBlt` 函数根据需要压缩或拉伸源位图。

如果目标、源和模式位图不具有相同的颜色格式，则 `BitBlt` 函数会转换源和模式位图，使其与目标相匹配。 转换中将使用目标位图的前景色和背景色。

当 `BitBlt` 函数将单色位图转换为彩色颜色时，它会将白色位（1）设置为背景色，将黑色位（0）设置为前景色。 使用目标设备上下文的前景色和背景色。 若要将颜色转换为单色，`BitBlt` 将与背景色匹配的像素设置为白色，并将所有其他像素设置为黑色。 `BitBlt` 使用颜色设备上下文的前景色和背景色从颜色转换为单色。

请注意，并非所有设备上下文都支持 `BitBlt`。 若要检查给定的设备上下文是否支持 `BitBlt`，请使用 `GetDeviceCaps` 成员函数并指定 RASTERCAPS 索引。

### <a name="example"></a>示例

  请参阅[CDC：： CreateCompatibleDC](#createcompatibledc)的示例。

##  <a name="cdc"></a>CDC：： CDC

构造 `CDC` 对象。

```
CDC();
```

##  <a name="chord"></a>CDC：：弦

绘制弦形（一种闭合图形，由椭圆和直线段的交集边界边界）。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定弦形边框的左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定弦形边框的左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定弦形边框右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定弦形边框右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定定义弦的起点的点的 x 坐标（以逻辑单位表示）。

*y3*<br/>
指定定义弦的起点的点的 y 坐标（以逻辑单位表示）。

*四*<br/>
指定定义弦号端点的点的 x 坐标（以逻辑单位表示）。

*y4*<br/>
指定定义弦端点的点的 y 坐标（以逻辑单位表示）。

*lpRect*<br/>
指定边框（以逻辑单位表示）。 可以为此参数传递 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*ptStart*<br/>
指定定义弦的起点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弦上。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

*ptEnd*<br/>
指定定义弦的结束点的点的 x 和 y 坐标（以逻辑单位表示）。 此点不必完全位于弦上。 可以为此参数传递[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

（ *X1*， *y1*）和（ *x2*， *y2*）参数分别指定了一个矩形的左上角和右下角，这些矩形限定了弦形的椭圆。 （ *X3*， *y3*）和（ *x4*， *y4*）参数指定与椭圆相交的线条的端点。 使用所选笔绘制弦形，并使用所选画笔进行填充。

`Chord` 函数绘制的图形最多可扩展到，但不包括右坐标和下坐标。 这意味着，图形的高度为*y2* - *y1* ，而该图形的宽度是*x2* - *x1*。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>CDC：： CloseFigure

关闭路径中的开放图形。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

函数通过绘制从当前位置到图形的第一个点的直线（通常为对 `MoveTo` 成员函数的最近一次调用指定的点）来关闭该图形，并使用 "线条联接" 样式连接这些直线。 如果通过使用 `LineTo` 成员函数而不是 `CloseFigure`关闭了某一图形，则使用 end cap 来创建角，而不是联接。 仅当设备上下文中有一个开放路径方括号时，才应调用 `CloseFigure`。

除非使用此函数显式关闭，否则路径中的图形处于打开状态。 （即使当前点和图形的起点相同也可以打开图形。）`CloseFigure` 开始新图形后添加到路径中的任何直线或曲线。

##  <a name="createcompatibledc"></a>CDC：： CreateCompatibleDC

创建与*pDC*指定的设备兼容的内存设备上下文。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>parameters

*pDC*<br/>
一个指向设备上下文的指针。 如果*pDC*为 NULL，则该函数将创建与系统显示兼容的内存设备上下文。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

内存设备上下文是表示显示图面的内存块。 它可用于在内存中准备映像，然后将其复制到兼容设备的实际设备表面。

创建内存设备上下文时，GDI 会自动为其选择一个 1 x 1 个单色股票位图。 只有在创建了位图并将其选定到该上下文中时，才可以将 GDI 输出函数用于内存设备上下文。

此函数只能用于为支持光栅操作的设备创建兼容的设备上下文。 有关设备上下文之间的位块传输的信息，请参阅[CDC：： BitBlt](#bitblt)成员函数。 若要确定设备上下文是否支持光栅操作，请参阅成员函数 `CDC::GetDeviceCaps`中的 RC_BITBLT 光栅功能。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>CDC：： CreateDC

为指定的设备创建设备上下文。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>parameters

*lpszDriverName*<br/>
指向以 null 结尾的字符串，该字符串指定设备驱动程序的文件名（不带扩展名）（例如，"EPSON"）。 还可以传递此参数的 `CString` 对象。

*lpszDeviceName*<br/>
指向以 null 结尾的字符串，该字符串指定要支持的特定设备的名称（例如，"EPSON FX-80"）。 如果模块支持多个设备，则使用*lpszDeviceName*参数。 还可以传递此参数的 `CString` 对象。

*lpszOutput*<br/>
指向以 null 结尾的字符串，该字符串指定物理输出介质（文件或输出端口）的文件或设备名称。 还可以传递此参数的 `CString` 对象。

*lpInitData*<br/>
指向包含设备驱动程序的特定于设备的初始化数据的 `DEVMODE` 结构。 Windows `DocumentProperties` 函数检索在给定设备中填充的此结构。 如果设备驱动程序要使用用户通过 "控制面板" 指定的默认初始化（如果有），则*lpInitData*参数必须为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

打印。如果使用[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)结构，则需要使用 H 头文件。

设备名称遵循以下约定：结束冒号（:)建议，但可选。 Windows 将使用终止冒号，以便将以冒号结尾的设备名称映射到相同的端口，而不需要使用冒号。 驱动程序和端口名称不能包含前导空格或尾随空格。 GDI 输出函数不能与信息上下文一起使用。

##  <a name="createic"></a>CDC：： CreateIC

创建指定设备的信息上下文。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>parameters

*lpszDriverName*<br/>
指向以 null 结尾的字符串，该字符串指定设备驱动程序的文件名（不带扩展名）（例如，"EPSON"）。 可以传递此参数的 `CString` 对象。

*lpszDeviceName*<br/>
指向以 null 结尾的字符串，该字符串指定要支持的特定设备的名称（例如，"EPSON FX-80"）。 如果模块支持多个设备，则使用*lpszDeviceName*参数。 可以传递此参数的 `CString` 对象。

*lpszOutput*<br/>
指向以 null 结尾的字符串，该字符串指定物理输出介质（文件或端口）的文件或设备名称。 可以传递此参数的 `CString` 对象。

*lpInitData*<br/>
指向设备驱动程序的特定于设备的初始化数据。 如果设备驱动程序要使用用户通过 "控制面板" 指定的默认初始化（如果有），则*lpInitData*参数必须为 NULL。 有关特定于设备的初始化，请参阅数据格式 `CreateDC`。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

信息上下文提供了获取设备信息的快速方法，无需创建设备上下文。

设备名称遵循以下约定：结束冒号（:)建议，但可选。 Windows 将使用终止冒号，以便将以冒号结尾的设备名称映射到相同的端口，而不需要使用冒号。 驱动程序和端口名称不能包含前导空格或尾随空格。 GDI 输出函数不能与信息上下文一起使用。

##  <a name="deletedc"></a>CDC：:D eleteDC

通常，不要调用此函数;析构函数将为你执行此操作。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>返回值

如果函数成功完成，则为非零值;否则为0。

### <a name="remarks"></a>备注

`DeleteDC` 成员函数删除与当前 `CDC` 对象中的 `m_hDC` 相关联的 Windows 设备上下文。 如果此 `CDC` 对象是给定设备的最后一个活动设备上下文，则会通知设备，并释放设备使用的所有存储和系统资源。

如果已在设备上下文中选择对象，应用程序不应调用 `DeleteDC`。 在删除对象之前，必须先从设备上下文中选择对象。

应用程序不能删除其句柄是通过调用[CWnd：： GetDC](../../mfc/reference/cwnd-class.md#getdc)获取的设备上下文。 相反，它必须调用[CWnd：： ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc)以释放设备上下文。 提供了[CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)类来包装此功能。

`DeleteDC` 函数通常用于删除使用[CreateDC](#createdc)、 [CreateIC](#createic)或[CreateCompatibleDC](#createcompatibledc)创建的设备上下文。

### <a name="example"></a>示例

  请参阅[CPrintDialog：： GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)的示例。

##  <a name="deletetempmap"></a>CDC：:D eleteTempMap

由 `CWinApp` 空闲时间处理程序自动调用，`DeleteTempMap` 删除 `FromHandle`创建的所有临时 `CDC` 对象，但不会销毁与 `hDC`对象临时关联的设备上下文句柄（`CDC`）。

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>CDC：:D etach

调用此函数可从 `CDC` 对象分离 `m_hDC` （输出设备上下文），并将 `m_hDC` 和 `m_hAttribDC` 均设置为 NULL。

```
HDC Detach();
```

### <a name="return-value"></a>返回值

Windows 设备上下文。

##  <a name="dptohimetric"></a>CDC：:D PtoHIMETRIC

将 HIMETRIC 大小赋给 OLE，将像素转换为 HIMETRIC 时，请使用此函数。

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式为 MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC 或 MM_HIMETRIC，则转换将基于物理英寸的像素数。 如果映射模式是其他非约束模式（例如 MM_TEXT）之一，则转换基于逻辑英寸中的像素数。

##  <a name="dptolp"></a>CDC：:D PtoLP

将设备单位转换为逻辑单元。

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象的数组。

*nCount*<br/>
数组中的点数。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于将一个矩形从设备点转换为逻辑点的简单情况。

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

函数将每个点的坐标或大小的维度从设备坐标系统映射到 GDI 的逻辑坐标系统。 转换取决于当前的映射模式，以及设备的窗口和视区的源和区的设置。

##  <a name="draw3drect"></a>CDC：:D raw3dRect

调用此成员函数以绘制三维矩形。

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指定边框（以逻辑单位表示）。 可以为此参数传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象的指针。

*clrTopLeft*<br/>
指定三维矩形的顶部和左侧的颜色。

*clrBottomRight*<br/>
指定三维矩形的下边缘和右边缘的颜色。

*x*<br/>
指定三维矩形的左上角的逻辑 x 坐标。

*y*<br/>
指定三维矩形的左上角的逻辑 y 坐标。

*cx*<br/>
指定三维矩形的宽度。

*cy*<br/>
指定三维矩形的高度。

### <a name="remarks"></a>备注

将使用由*clrTopLeft*指定的颜色以及由*clrBottomRight*指定的颜色的下边缘和右边缘绘制矩形。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>CDC：:D rawDragRect

重复调用此成员函数以重新绘制拖动矩形。

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定矩形的逻辑坐标（在本例中为要重新绘制的矩形的结束位置）。

size<br/>
指定从外边框的左上角到矩形边框的左上角的偏移量（即边框的宽度）的偏移量。

*lpRectLast*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定矩形位置的逻辑坐标（在本例中为要重新绘制的矩形的原始位置）。

*sizeLast*<br/>
指定从外边框的左上角到要重新绘制的原始矩形的左上角（即，边框的宽度）的偏移量。

*pBrush*<br/>
指向画笔对象的指针。 如果设置为 NULL，则使用默认半色调画笔。

*pBrushLast*<br/>
指向所使用的最后一个画笔对象的指针。 如果设置为 NULL，则使用默认半色调画笔。

### <a name="remarks"></a>备注

在采样鼠标位置时以循环方式调用它，以便提供可视反馈。 调用 `DrawDragRect`时，将清除上一个矩形，并绘制一个新矩形。 例如，当用户在屏幕上拖动矩形时，`DrawDragRect` 将擦除原始矩形，并在新位置重绘新矩形。 默认情况下，`DrawDragRect` 使用半色调画笔来绘制矩形，以消除闪烁并创建平滑运动矩形的外观。

第一次调用 `DrawDragRect`时， *lpRectLast*参数应为 NULL。

##  <a name="drawedge"></a>CDC：:D rawEdge

调用此成员函数以绘制指定类型和样式的矩形的边缘。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向 `RECT` 结构的指针，该结构包含矩形的逻辑坐标。

*nEdge*<br/>
指定要绘制的内部和外部边缘的类型。 此参数必须是一个内边框标志和一个外边框标志的组合。 有关参数类型的表，请参阅 Windows SDK 中的[DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) 。

*nFlags*<br/>
用于指定要绘制的边框类型的标志。 有关参数值的表，请参阅 Windows SDK 中的 `DrawEdge`。 对于对角线，BF_RECT 标志指定由矩形参数限定的矢量的终点。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

##  <a name="drawescape"></a>CDC：:D rawEscape

访问不能通过图形设备接口（GDI）直接提供的视频显示器的绘图功能。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>parameters

*nEscape*<br/>
指定要执行的转义函数。

*nInputSize*<br/>
指定*lpszInputData*参数指向的数据的字节数。

*lpszInputData*<br/>
指向指定转义所需的输入结构。

### <a name="return-value"></a>返回值

指定函数的结果。 如果成功，则大于零，仅检查实现的 QUERYESCSUPPORT 绘图转义除外;如果未实现转义，则为零; 否则为零。如果发生错误，则为或小于零。

### <a name="remarks"></a>备注

当应用程序调用 `DrawEscape`时，由*nInputSize*和*lpszInputData*标识的数据将直接传递到指定的显示驱动程序。

##  <a name="drawfocusrect"></a>CDC：:D rawFocusRect

在样式中绘制一个矩形，用来指示矩形具有焦点。

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，该对象指定要绘制的矩形的逻辑坐标。

### <a name="remarks"></a>备注

由于这是一个布尔 XOR 函数，因此第二次使用同一矩形调用此函数将从显示中删除该矩形。 此函数绘制的矩形无法滚动。 若要滚动包含此函数绘制的矩形的区域，请先调用 `DrawFocusRect` 以从显示中删除该矩形，然后滚动该区域，然后再次调用 `DrawFocusRect` 以在新位置绘制该矩形。

> [!CAUTION]
> `DrawFocusRect` 仅在 MM_TEXT 模式下工作。 在其他模式下，此函数不会正确绘制聚焦框，但它不返回错误值。

##  <a name="drawframecontrol"></a>CDC：:D rawFrameControl

调用此成员函数以绘制指定类型和样式的框架控件。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向 `RECT` 结构的指针，该结构包含矩形的逻辑坐标。

nType<br/>
指定要绘制的框架控件的类型。 有关此参数的可能值的列表，请参阅 Windows SDK 中[DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol)的*uType*参数。

*nState*<br/>
指定框架控件的初始状态。 可以是在 Windows SDK `DrawFrameControl` 中为*uState*参数描述的一个或多个值。 使用*nState*值 DFCS_ADJUSTRECT 调整边界矩形，使其不包含 "push" 按钮的周围边缘。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

在某些情况下， *nState*依赖于*n*参数。 以下列表显示了四个*n*值和*nState*之间的关系：

- DFC_BUTTON

    - DFCS_BUTTON3STATE 三态按钮

    - DFCS_BUTTONCHECK 复选框

    - DFCS_BUTTONPUSH "推送" 按钮

    - DFCS_BUTTONRADIO 单选按钮

    - 单选按钮的 DFCS_BUTTONRADIOIMAGE 图像（非方形需求图像）

    - 单选按钮的 DFCS_BUTTONRADIOMASK 掩码（非方形需求掩码）

- DFC_CAPTION

    - DFCS_CAPTIONCLOSE "关闭" 按钮

    - DFCS_CAPTIONHELP "帮助" 按钮

    - DFCS_CAPTIONMAX 最大化 "按钮

    - DFCS_CAPTIONMIN "最小化" 按钮

    - DFCS_CAPTIONRESTORE 还原按钮

- DFC_MENU

    - DFCS_MENUARROW 子菜单箭头

    - DFCS_MENUBULLET 项目符号

    - DFCS_MENUCHECK 选中标记

- DFC_SCROLL

    - DFCS_SCROLLCOMBOBOX 组合框滚动条

    - 滚动条的 DFCS_SCROLLDOWN 向下箭头

    - 滚动条的 DFCS_SCROLLLEFT 向左键

    - 滚动条 DFCS_SCROLLRIGHT 向右箭头

    - 窗口右下角 DFCS_SCROLLSIZEGRIP 大小手柄

    - 滚动条的 DFCS_SCROLLUP 向上箭头

### <a name="example"></a>示例

此代码在窗口右下角绘制大小控制手柄。 它适用于对话框的 `OnPaint` 处理程序，该对话框没有样式，并且通常不包含可为其提供大小控制的其他控件（如状态栏）。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>CDC：:D rawIcon

在设备上绘制一个图标，该图标由当前 `CDC` 对象表示。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定图标左上角的逻辑 x 坐标。

*y*<br/>
指定图标左上角的逻辑 y 坐标。

*hIcon*<br/>
标识要绘制的图标的句柄。

*情况*<br/>
指定图标左上角的逻辑 x 和 y 坐标。 可以为此参数传递[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果函数成功完成，则为非零值;否则为0。

### <a name="remarks"></a>备注

函数将图标的左上角放置在*x*和*y*指定的位置。 此位置受设备上下文的当前映射模式的限制。

此图标资源之前必须已使用 `CWinApp::LoadIcon`、`CWinApp::LoadStandardIcon`或 `CWinApp::LoadOEMIcon`的函数加载。 使用此函数之前，必须选择 `MM_TEXT` 映射模式。

### <a name="example"></a>示例

  请参阅[CWnd：： IsIconic](../../mfc/reference/cwnd-class.md#isiconic)的示例。

##  <a name="drawstate"></a>CDC：:D rawState

调用此成员函数以显示图像，并应用视觉效果以指示状态，如 "已禁用" 或 "默认" 状态。

> [!NOTE]
>  对于除 DSS_NORMAL 之外的所有*nFlag*状态，在应用视觉效果之前，将图像转换为单色。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>parameters

*pt*<br/>
指定图像的位置。

size<br/>
指定图像的大小。

*hBitmap*<br/>
位图的句柄。

*nFlags*<br/>
指定映像类型和状态的标志。 有关可能的*nFlags*类型和状态，请参阅 Windows SDK 中的[DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) 。

*hBrush*<br/>
画笔的句柄。

*pBitmap*<br/>
指向 CBitmap 对象的指针。

*pBrush*<br/>
指向 CBrush 对象的指针。

*hIcon*<br/>
图标的图柄。

*lpszText*<br/>
指向文本的指针。

*bPrefixText*<br/>
可能包含加速器助记键的文本。 *LData*参数指定字符串的地址， *nTextLen*参数指定长度。 如果*nTextLen*为0，则假定该字符串以 null 结尾。

*nTextLen*<br/>
*LpszText*指向的文本字符串的长度。 如果*nTextLen*为0，则假定该字符串以 null 结尾。

*lpDrawProc*<br/>
指向用于呈现图像的回调函数的指针。 如果*nFlags*中的图像类型 DST_COMPLEX，则此参数是必需的。 它是可选的，如果图像类型为 DST_TEXT，则可以为 NULL。 对于所有其他图像类型，忽略此参数。 有关回调函数的详细信息，请参阅 Windows SDK 中的[DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc)函数。

*lData*<br/>
指定有关映像的信息。 此参数的含义取决于映像类型。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

##  <a name="drawtext"></a>CDC：:D rawText

调用此成员函数可设置给定矩形中文本的格式。 若要指定其他格式设置选项，请使用[CDC：:D rawtextex](#drawtextex)。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为-1，则字符串必须以 null 结尾。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，则假定*lpszString*为指向以 null 结尾的字符串的长指针，并且 `DrawText` 自动计算字符计数。

*lpRect*<br/>
指向一个[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含用于设置文本格式的矩形（以逻辑坐标表示）。

*str*<br/>
一个[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定字符。

*nFormat*<br/>
指定格式化文本的方法。 它可以是在 Windows SDK 中为[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中的*uFormat*参数描述的任何值组合。 （使用按位 OR 运算符合并）：

> [!NOTE]
>  某些*uFormat*标志组合可能会导致修改传递的字符串。 将 DT_MODIFYSTRING 与 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 结合使用可能会导致修改字符串，从而导致 `CString` 重写中的断言。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP 和 DT_NOPREFIX 的值不能与 DT_TABSTOP 值一起使用。

### <a name="return-value"></a>返回值

如果函数成功，则为文本的高度。

### <a name="remarks"></a>备注

它通过将选项卡展开为适当的空间来设置文本格式，将文本与给定矩形的左、右或中心对齐，将文本分解为适合给定矩形的行。 格式设置类型由*nFormat*指定。

此成员函数使用设备上下文的选定字体、文本颜色和背景颜色来绘制文本。 除非使用 DT_NOCLIP 格式，否则 `DrawText` 会剪辑文本，使文本不会出现在给定矩形的外部。 除非给定 DT_SINGLELINE 格式，否则所有格式设置都将具有多个行。

如果所选字体对于指定的矩形太大，则 `DrawText` 成员函数不会尝试使用较小的字体。

如果指定了 DT_CALCRECT 标志，则将更新*lpRect*指定的矩形，以反映绘制文本所需的宽度和高度。

如果已设置了 TA_UPDATECP 文本对齐标志（请参阅[CDC：： SetTextAlign](#settextalign)），`DrawText` 将显示从当前位置开始，而不是在给定矩形的左侧显示的文本。 设置 TA_UPDATECP 标志（即，DT_WORDBREAK 标志将不起作用）时，`DrawText` 将不会换行。

可以通过[CDC：： SetTextColor](#settextcolor)设置文本颜色。

##  <a name="drawtextex"></a>CDC：:D rawTextEx

设置给定矩形中的文本格式。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向要绘制的字符串。 如果*nCount*为-1，则该字符串必须以 null 结尾。

*nCount*<br/>
指定字符串中的字符数。 如果*nCount*为-1，则假定*lpszString*为指向以 null 结尾的字符串的长指针，并且 `DrawText` 自动计算字符计数。

*lpRect*<br/>
指向一个[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含用于设置文本格式的矩形（以逻辑坐标表示）。

*str*<br/>
一个[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定字符。

*nFormat*<br/>
指定格式化文本的方法。 它可以是在 Windows SDK 中为[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中的*uFormat*参数描述的任何值组合。 （使用按位**or**运算符合并）：

> [!NOTE]
>  某些*uFormat*标志组合可能会导致修改传递的字符串。 将 DT_MODIFYSTRING 与 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 结合使用可能会导致修改字符串，从而导致 `CString` 重写中的断言。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP 和 DT_NOPREFIX 的值不能与 DT_TABSTOP 值一起使用。

*lpDTParams*<br/>
指向[DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams)结构的指针，该结构指定其他格式设置选项。 此参数可以为 NULL。

### <a name="remarks"></a>备注

它通过将选项卡展开为适当的空间来设置文本格式，将文本与给定矩形的左、右或中心对齐，将文本分解为适合给定矩形的行。 格式设置类型由*nFormat*和*lpDTParams*指定。 有关详细信息，请参阅 Windows SDK 中的[CDC：:D rawtext](#drawtext)和[DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) 。

可以通过[CDC：： SetTextColor](#settextcolor)设置文本颜色。

##  <a name="ellipse"></a>CDC：：椭圆形

绘制椭圆形。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定椭圆的边框的左上角的逻辑 x 坐标。

*y1*<br/>
指定椭圆的边框的左上角的逻辑 y 坐标。

*x2*<br/>
指定椭圆的边框右下角的逻辑 x 坐标。

*y2*<br/>
指定椭圆的边框右下角的逻辑 y 坐标。

*lpRect*<br/>
指定椭圆的边框。 还可以传递此参数的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

椭圆的中心是由*x1*， *y1*， *x2* *，，或* *lpRect*指定的边框的中心。 该椭圆用当前笔绘制，并且其内部填充了当前画笔。

此函数绘制的图形最多可扩展到，但不包括右坐标和下坐标。 这意味着，图形的高度为*y2* - *y1* ，而该图形的宽度是*x2* - *x1*。

如果边框的宽度或高度均为0，则不绘制任何椭圆。

##  <a name="enddoc"></a>CDC：： EndDoc

结束通过调用[StartDoc](#startdoc)成员函数启动的打印作业。

```
int EndDoc();
```

### <a name="return-value"></a>返回值

如果函数成功，则大于或等于 0; 如果发生错误，则大于等于0。

### <a name="remarks"></a>备注

此成员函数将替换 ENDDOC 打印机转义，并应在完成成功的打印作业后立即调用。

如果应用程序遇到打印错误或已取消的打印操作，则不能尝试使用 `EndDoc` 或[AbortDoc](#abortdoc)终止操作。 GDI 在返回错误值之前会自动终止操作。

不应在图元文件中使用此函数。

### <a name="example"></a>示例

  请参阅[CDC：： StartDoc](#startdoc)的示例。

##  <a name="endpage"></a>CDC：： EndPage

通知设备应用程序已完成写入页面。

```
int EndPage();
```

### <a name="return-value"></a>返回值

如果函数成功，则大于或等于 0; 如果发生错误，则大于等于0。

### <a name="remarks"></a>备注

此成员函数通常用于指示设备驱动程序前进到新页面。

此成员函数替换 NEWFRAME 打印机转义。 与 NEWFRAME 不同，此函数始终在打印页后调用。

### <a name="example"></a>示例

  请参阅[CDC：： StartDoc](#startdoc)的示例。

##  <a name="endpath"></a>CDC：： EndPath

关闭路径方括号，并选择由括号定义的设备上下文中的路径。

```
BOOL EndPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  请参阅[CDC：： BeginPath](#beginpath)的示例。

##  <a name="enumobjects"></a>CDC：： EnumObjects

枚举设备上下文中可用的笔和画笔。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>parameters

*nObjectType*<br/>
指定对象类型。 它的值可以是 OBJ_BRUSH 或 OBJ_PEN。

*lpfn*<br/>
是应用程序提供的回调函数的过程实例地址。 请参阅下面的 "备注" 部分。

*lpData*<br/>
指向应用程序提供的数据。 数据与对象信息一起传递到回调函数。

### <a name="return-value"></a>返回值

指定[回调函数](callback-functions-used-by-mfc.md#enum_objects)返回的最后一个值。 其意义是用户定义的。

### <a name="remarks"></a>备注

对于给定类型的每个对象，将使用该对象的信息调用传递的回调函数。 系统调用回调函数，直到没有其他对象或回调函数返回0。

请注意，Microsoft 视觉对象C++的新功能允许使用普通函数作为传递给 `EnumObjects`的函数。 传递给 `EnumObjects` 的地址是一个指针，指向使用**EXPORT**导出的函数和 Pascal 调用约定。 在保护模式的应用程序中，不必使用 Windows MakeProcInstance 函数创建此函数，或在将其用于 FreeProcInstance Windows 函数后释放该函数。

你还不必在应用程序的模块定义文件的**导出**语句中导出函数名称。 可以改用**导出**函数修饰符，如下所示

**INT 回调导出**AFunction **（LPSTR**， **LPSTR）;**

如果为，则导致编译器发出适当的导出记录以便按名称导出，而无需使用别名。 这适用于大多数需求。 对于某些特殊情况，如按序号导出函数或为导出提供别名时，仍需要在模块定义文件中使用**导出**语句。

对于编译 Microsoft Foundation 程序，你通常将使用/GA 和/GEs 编译器选项。 /Gw 编译器选项不与 Microsoft 基础类一起使用。 （如果使用 Windows 函数 `MakeProcInstance`，则需要将返回的函数指针从 FARPROC 显式转换为此 API 所需的类型。）回调注册接口现在是类型安全的（必须传入一个函数指针，该指针指向特定回调的正确函数类型）。

另请注意，在返回 Windows 之前，所有回调函数都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>CDC：： Escape

对于 Win32 编程，此成员函数几乎已过时。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>parameters

*nEscape*<br/>
指定要执行的转义函数。

有关转义函数的完整列表，请参阅 Windows SDK 中的[转义](/windows/win32/api/wingdi/nf-wingdi-escape)。

*nCount*<br/>
指定*lpszInData*指向的数据字节数。

*lpszInData*<br/>
指向此转义所需的输入数据结构。

*lpOutData*<br/>
指向要从此转义接收输出的结构。 如果未返回任何数据，则*lpOutData*参数为 NULL。

*nInputSize*<br/>
指定*lpszInputData*参数指向的数据的字节数。

*lpszInputData*<br/>
指向指定转义所需的输入结构。

*nOutputSize*<br/>
指定*lpszOutputData*参数指向的数据的字节数。

*lpszOutputData*<br/>
指向从此转义接收输出的结构。 如果未返回任何数据，则此参数应为 NULL。

### <a name="return-value"></a>返回值

如果函数成功，则返回正值，只会检查实现的 QUERYESCSUPPORT 转义。 如果未实现转义，则返回零。 如果发生错误，则返回负值。 以下是常见的错误值：

- SP_ERROR 常规错误。

- SP_OUTOFDISK 没有足够的磁盘空间可用于后台处理，且没有更多的可用空间。

- SP_OUTOFMEMORY 没有足够的内存可用于后台处理。

- SP_USERABORT 用户通过打印管理器结束了作业。

### <a name="remarks"></a>备注

对于原始打印机转义，Win32 应用程序仅支持 QUERYESCSUPPORT。 所有其他打印机转义都已过时，并且仅支持与16位应用程序兼容。

对于 Win32 编程，`CDC` 现在提供了六个替代其相应的打印机转义的成员函数：

- [CDC：： AbortDoc](#abortdoc)

- [CDC：： EndDoc](#enddoc)

- [CDC：： EndPage](#endpage)

- [CDC：： SetAbortProc](#setabortproc)

- [CDC：： StartDoc](#startdoc)

- [CDC：： StartPage](#startpage)

此外， [CDC：： GetDeviceCaps](#getdevicecaps)支持取代其他打印机转义的 Win32 索引。 有关详细信息，请参阅 Windows SDK 中的[GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) 。

此成员函数允许应用程序访问不能通过 GDI 直接提供的特定设备的工具。

如果你的应用程序使用预定义的转义值，请使用第一个版本。 如果你的应用程序定义私有转义值，请使用第二个版本。 有关第二个版本的详细信息，请参阅 Windows SDK 中的[ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) 。

##  <a name="excludecliprect"></a>CDC：： ExcludeClipRect

创建一个新的剪辑区域，其中包含的现有剪辑区域减去指定的矩形。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定矩形左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形右下角的逻辑 y 坐标。

*lpRect*<br/>
指定矩形。 也可以是 `CRect` 对象。

### <a name="return-value"></a>返回值

指定新的剪辑区域的类型。 可以是以下任一值：

- COMPLEXREGION 区域包含重叠的边框。

- 错误：未创建区域。

- NULLREGION 区域为空。

- SIMPLEREGION 区域没有重叠的边框。

### <a name="remarks"></a>备注

矩形的宽度（由*x2* - *x1*的绝对值指定）不得超过32767个单位。 此限制也适用于矩形的高度。

##  <a name="excludeupdatergn"></a>CDC：： ExcludeUpdateRgn

通过从与 `CDC` 对象关联的剪辑区域中排除窗口中的更新区域，防止在窗口的无效区域中进行绘制。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>parameters

*pWnd*<br/>
指向要更新其窗口的窗口对象。

### <a name="return-value"></a>返回值

排除区域的类型。 它可以是下列值之一：

- COMPLEXREGION 区域包含重叠的边框。

- 错误：未创建区域。

- NULLREGION 区域为空。

- SIMPLEREGION 区域没有重叠的边框。

##  <a name="extfloodfill"></a>CDC：： ExtFloodFill

使用当前画笔填充显示图面的区域。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定填充开始处的点的逻辑 x 坐标。

*y*<br/>
指定填充开始处的点的逻辑 y 坐标。

*crColor*<br/>
指定要填充的区域的边界或区域的颜色。 *CrColor*的解释取决于*nFillType*的值。

*nFillType*<br/>
指定要执行的洪水填充的类型。 它必须是以下值之一：

- FLOODFILLBORDER 填充区域由*crColor*指定的颜色限定。 此样式与 `FloodFill`执行的填充完全相同。

- FLOODFILLSURFACE 填充区域由*crColor*指定的颜色定义。 只要遇到颜色，填充就会在所有方向上向外继续。 此样式适用于用多色边界填充区域。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值;否则为0。如果填充无法完成，则如果给定点具有*crColor*指定的边界颜色（如果请求了 FLOODFILLBORDER），则如果给定点没有*crColor*指定的颜色（如果已请求 FLOODFILLSURFACE），或者该点在剪辑区域外。

### <a name="remarks"></a>备注

与 `FloodFill` 相比，此成员函数具有更大的灵活性，因为你可以在*nFillType*中指定填充类型。

如果将*nFillType*设置为 FLOODFILLBORDER，则认为区域被*crColor*指定的颜色完全限定。 函数从*x*和*y*指定的点处开始，并将所有方向填充到颜色边界。

如果将*nFillType*设置为 FLOODFILLSURFACE，则函数将从*x*和*y*指定的点处开始，并在所有方向上继续，并填充包含*crColor*指定的颜色的所有相邻区域。

仅内存设备上下文和支持光栅显示技术支持的设备 `ExtFloodFill`。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数。

##  <a name="exttextout"></a>CDC：： ExtTextOut

调用此成员函数以使用当前选定的字体在矩形区域中写入字符串。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定指定字符串中第一个字符的字符单元的逻辑 x 坐标。

*y*<br/>
指定指定字符串中第一个字符的字符单元顶部的逻辑 y 坐标。

*nOptions*<br/>
指定矩形类型。 此参数可以是下列值之一：

- ETO_CLIPPED 指定将文本剪切到矩形。

- ETO_OPAQUE 指定当前背景色填充矩形。 （可以通过[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成员函数设置和查询当前背景色。）

*lpRect*<br/>
指向[矩形结构，](/windows/win32/api/windef/ns-windef-rect)该结构确定矩形的尺寸。 此参数可以为 NULL。 还可以传递此参数的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*lpszString*<br/>
指向要绘制的指定字符串。 还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定字符串中的字符数。

*lpDxWidths*<br/>
指向值的数组，这些值指示相邻字符单元的起源之间的距离。 例如， *lpDxWidths*[ *i*] 逻辑单元将分隔字符单元*i*和字符单元*i* + 1 的起源。 如果*lpDxWidths*为 NULL，`ExtTextOut` 将使用字符之间的默认间距。

*str*<br/>
一个 `CString` 对象，它包含要绘制的指定字符。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

矩形区域可以是不透明的（用当前背景色填充），也可以是剪辑区域。

如果*nOptions*为0， *lpRect*为 NULL，则函数将文本写入设备上下文，而不使用矩形区域。 默认情况下，函数不使用或更新当前位置。 如果应用程序在调用 `ExtTextOut`时需要更新当前位置，则应用程序可以调用 `CDC` 成员函数[SetTextAlign](#settextalign) ，并将*nFlags*设置为 TA_UPDATECP。 设置此标志后，Windows 将忽略对 `ExtTextOut` 的后续调用的*x*和*y* ，而改用当前位置。 当应用程序使用 TA_UPDATECP 更新当前位置时，`ExtTextOut` 将当前位置设置为上一行文本的末尾，或设置为*lpDxWidths*所指向的数组的最后一个元素所指定的位置（以较大者为准）。

##  <a name="fillpath"></a>CDC：： FillPath

关闭当前路径中的所有打开的图形，并使用当前画笔和多边形填充模式填充路径内部。

```
BOOL FillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

填充其内部后，将从设备上下文中丢弃该路径。

##  <a name="fillrect"></a>CDC：： FillRect

使用指定的画笔调用此成员函数以填充给定矩形。

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向包含要填充的矩形的逻辑坐标的[RECT](/windows/win32/api/windef/ns-windef-rect)结构。 还可以传递此参数的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

*pBrush*<br/>
标识用于填充矩形的画笔。

### <a name="remarks"></a>备注

函数将填充整个矩形，包括左边框和上边框，但不填充右边框和下边框。

需要使用[CBrush](../../mfc/reference/cbrush-class.md)成员函数[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)、 [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)来创建画笔，或由 `GetStockObject` Windows 函数检索。

填充指定的矩形时，`FillRect` 不包括矩形的右边缘和下边缘。 GDI 最多填充一个矩形，但不包括右边的列和下行，而与当前映射模式无关。 `FillRect` 比较指定矩形的 `top`、`bottom`、`left`和 `right` 成员的值。 如果 `bottom` 小于或等于 `top`，或者 `right` 小于或等于 `left`，则不绘制矩形。

`FillRect` 类似于[CDC：： FillSolidRect](#fillsolidrect);但 `FillRect` 会采用画笔，因此可用于使用纯色、抖动颜色、阴影画笔或图案填充矩形。 `FillSolidRect` 仅使用纯色（由 COLORREF 参数指示）。 `FillRect` 通常比 `FillSolidRect`慢。

##  <a name="fillrgn"></a>CDC：： FillRgn

使用*pBrush*指定的画笔填充*pRgn*指定的区域。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>parameters

*pRgn*<br/>
指向要填充的区域的指针。 给定区域的坐标是在逻辑单元中指定的。

*pBrush*<br/>
标识用于填充区域的画笔。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

画笔必须使用 `CBrush` 成员函数创建 `CreateHatchBrush`、`CreatePatternBrush`、`CreateSolidBrush`或通过 `GetStockObject`检索。

### <a name="example"></a>示例

  请参阅[CRgn：： CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)的示例。

##  <a name="fillsolidrect"></a>CDC：： FillSolidRect

调用此成员函数以用指定的纯色填充给定矩形。

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指定边框（以逻辑单位表示）。 可以为此参数传递指向[RECT](/windows/win32/api/windef/ns-windef-rect)数据结构或 `CRect` 对象的指针。

*clr*指定用于填充矩形的颜色。

*x*<br/>
指定矩形左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*cx*<br/>
指定矩形的宽度。

*cy*<br/>
指定矩形的高度。

### <a name="remarks"></a>备注

`FillSolidRect` 非常类似于[CDC：： FillRect](#fillrect);不过，`FillSolidRect` 仅使用纯色（由 COLORREF 参数指示），而 `FillRect` 采用画笔，因此可用于使用纯色、抖动颜色、阴影画笔或图案填充矩形。 `FillSolidRect` 通常比 `FillRect`快。

> [!NOTE]
>  调用 `FillSolidRect`时，以前使用[SetBkColor](#setbkcolor)设置的背景色设置为*clr*指示的颜色。

##  <a name="flattenpath"></a>CDC：： FlattenPath

将所选路径中的任意曲线转换为当前设备上下文，并将每条曲线变为一系列线条。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="floodfill"></a>CDC：： FloodFill

使用当前画笔填充显示图面的区域。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定填充开始处的点的逻辑 x 坐标。

*y*<br/>
指定填充开始处的点的逻辑 y 坐标。

*crColor*<br/>
指定边界的颜色。

### <a name="return-value"></a>返回值

如果函数成功，则为非零值;否则，如果无法完成填充，则返回 0; 给定点具有*crColor*指定的边界颜色，或者该点在剪辑区域外。

### <a name="remarks"></a>备注

假定区域被*crColor*指定。 `FloodFill` 函数在*x*和*y*指定的点处开始，并在所有方向上继续到颜色边界。

只有内存设备上下文和支持光栅显示技术的设备才支持 `FloodFill` 成员函数。 有关 RC_BITBLT 功能的信息，请参阅 `GetDeviceCaps` 成员函数。

`ExtFloodFill` 函数提供类似的功能，但具有更大的灵活性。

##  <a name="framerect"></a>CDC：： FrameRect

在*lpRect*指定的矩形周围绘制边框。

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含矩形的左上角和右下角的逻辑坐标。 还可以传递此参数的 `CRect` 对象。

*pBrush*<br/>
标识要用于使矩形成为组帧的画笔。

### <a name="remarks"></a>备注

函数使用给定的画笔绘制边框。 边框的宽度和高度始终为1个逻辑单元。

如果矩形的 `bottom` 坐标小于或等于 `top`，或者 `right` 小于或等于 `left`，则不绘制矩形。

`FrameRect` 绘制的边框与使用相同坐标的 `Rectangle` 成员函数绘制的边框位于同一位置（如果 `Rectangle` 使用的是1个逻辑单元宽度的笔）。 不 `FrameRect`填充矩形的内部。

##  <a name="framergn"></a>CDC：： FrameRgn

使用*pBrush*指定的画笔，在由*pRgn*指定的区域周围绘制边框。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>parameters

*pRgn*<br/>
指向用于标识要包含在边框中的区域的 `CRgn` 对象。 给定区域的坐标是在逻辑单元中指定的。

*pBrush*<br/>
指向 `CBrush` 对象，该对象标识用于绘制边框的画笔。

*nWidth*<br/>
以设备单位指定垂直画笔笔划的边框宽度。

*nHeight*<br/>
以设备单位指定水平画笔笔划中边框的高度。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="example"></a>示例

  请参阅[CRgn：： CombineRgn](../../mfc/reference/crgn-class.md#combinergn)的示例。

##  <a name="fromhandle"></a>CDC：： FromHandle

当给定设备上下文的句柄时，返回指向 `CDC` 对象的指针。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>parameters

*hDC*<br/>
包含 Windows 设备上下文的句柄。

### <a name="return-value"></a>返回值

指针可能是暂时的，不应存储在立即使用的范围之内。

### <a name="remarks"></a>备注

如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。

### <a name="example"></a>示例

  请参阅[CPrintDialog：： GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)的示例。

##  <a name="getarcdirection"></a>CDC：： GetArcDirection

返回设备上下文的当前弧线方向。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>返回值

如果成功，则指定当前弧线方向。 下面是有效的返回值：

- AD_COUNTERCLOCKWISE 圆弧和逆时针绘制的矩形。

- AD_CLOCKWISE 顺时针绘制的弧形和矩形。

如果发生错误，则返回值为零。

### <a name="remarks"></a>备注

弧线和矩形函数使用弧线方向。

##  <a name="getaspectratiofilter"></a>CDC：： GetAspectRatioFilter

检索当前纵横比筛选器的设置。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>返回值

表示当前纵横比筛选器使用的纵横比的 `CSize` 对象。

### <a name="remarks"></a>备注

纵横比是设备像素宽度和高度形成的比率。 有关设备纵横比的信息用于创建、选择和显示字体。 Windows 提供了一个特殊筛选器，即纵横比筛选器，用于从所有可用字体中选择为特定纵横比设计的字体。 筛选器使用 `SetMapperFlags` 成员函数指定的纵横比。

##  <a name="getbkcolor"></a>CDC：： GetBkColor

返回当前背景色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

RGB 颜色值。

### <a name="remarks"></a>备注

如果背景模式不透明，系统将使用背景色填充样式线中的间隙、画笔中阴影线之间的间隔以及字符单元中的背景。 在颜色和单色设备上下文之间转换位图时，系统还使用背景色。

##  <a name="getbkmode"></a>CDC：： GetBkMode

返回后台模式。

```
int GetBkMode() const;
```

### <a name="return-value"></a>返回值

当前背景模式，它可能是不透明的，也可能是透明的。

### <a name="remarks"></a>备注

背景模式定义系统是否在绘制文本、阴影画笔或不是实线的任何笔样式之前删除绘图图面上的现有背景色。

##  <a name="getboundsrect"></a>CDC：： GetBoundsRect

返回指定设备上下文的当前累积边界矩形。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>parameters

*lpRectBounds*<br/>
指向将接收当前边框的缓冲区。 该矩形以逻辑坐标的形式返回。

*flag*<br/>
指定是否在返回边框后将其清除。 此参数应为零或设置为以下值：

- DCB_RESET 强制在返回边界矩形后将其清除。

### <a name="return-value"></a>返回值

如果函数成功，则指定边框的当前状态。 它可以是下列值的组合：

- 正在累积 DCB_ACCUMULATE 边界矩形。

- DCB_RESET 的边框为空。

- DCB_SET 边框不为空。

- DCB_ENABLE 边界累积已启用。

- DCB_DISABLE 边界累积处于关闭状态。

##  <a name="getbrushorg"></a>CDC：： GetBrushOrg

检索当前为设备上下文选择的画笔的原点（以设备单位为单位）。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>返回值

作为[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象的画笔的当前原点（以设备单位为单位）。

### <a name="remarks"></a>备注

初始画笔原点位于（0，0）个工作区。 返回值指定此点在设备单位中相对于桌面窗口的原点。

##  <a name="getcharacterplacement"></a>CDC：： GetCharacterPlacement

检索字符串上的各种类型的信息。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>parameters

*lpString*<br/>
指向要处理的字符串的指针。

*nCount*<br/>
指定字符串的长度。 对于 ANSI 版本，它是一个字节计数，而 Unicode 函数是一个单词计数。 有关详细信息，请参阅[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)。

*nMaxExtent*<br/>
指定对字符串进行处理的最大范围（以逻辑单位为单位）。 如果已处理，则会忽略此区。 任何所需排序或标志符号数组的计算仅适用于包含的字符。 仅当在*dwFlags*参数中指定了 GCP_MAXEXTENT 值时，才使用此参数。 当函数处理输入字符串时，只有在总范围尚未超过最大值时，才会将每个字符及其范围添加到输出、范围和其他数组。 达到限制后，处理将停止。

*lpResults*<br/>
指向接收函数结果的[GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw)结构的指针。

dwFlags<br/>
指定如何将字符串处理到所需的数组中。 此参数可以是[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)主题的*dwFlags*节中列出的一个或多个值。

*str*<br/>
指向要处理的[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则返回值为逻辑单元中的字符串的宽度和高度。

如果函数失败，则返回值为零。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)的功能，如 Windows SDK 中所述。

##  <a name="getcharabcwidths"></a>CDC：： GetCharABCWidths

从当前 TrueType 字体检索指定范围内的连续字符的宽度。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>parameters

*nFirstChar*<br/>
指定返回字符宽度的当前字体中的字符范围中的第一个字符。

*nLastChar*<br/>
指定返回字符宽度的当前字体中的字符范围中的最后一个字符。

*lpabc*<br/>
指向在函数返回时接收字符宽度的[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)结构数组。 此数组必须包含至少与*nFirstChar*和*nLastChar*参数所指定范围内的字符数量相同的 `ABC` 结构。

*lpABCF*<br/>
指向应用程序提供的缓冲区，其中包含[ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat)结构的数组，用于在函数返回时接收字符宽度。 此函数返回的宽度采用 IEEE 浮点格式。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

以逻辑单位返回宽度。 只有 TrueType 字体才能完成此函数。

在选择了特定的点大小时，TrueType 光栅化程序提供了 "ABC" 字符间距。 "A" 间距是指在放置字形前添加到当前位置的距离。 "B" 间距是标志符号的黑色部分的宽度。 "C" 间距将添加到当前位置，以考虑标志符号右侧的空白。 总高级宽度由 + B + C 提供。

如果 `GetCharABCWidths` 成员函数为字符检索负的 "A" 或 "C" 宽度，则该字符包括 underhangs 或 overhangs。

若要将 ABC 宽度转换为字体设计单元，应用程序应创建一个其高度（在[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)结构的 `lfHeight` 成员中指定的字体）等于[NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw)结构的 `ntmSizeEM` 成员中存储的值。 （可以通过调用[EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows 函数来检索 `ntmSizeEM` 成员的值。）

默认字符的 ABC 宽度用于当前所选字体范围之外的字符。

若要检索非 TrueType 字体中字符的宽度，应用程序应使用[GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows 函数。

##  <a name="getcharabcwidthsi"></a>CDC：： GetCharABCWidthsI

从当前 TrueType 字体检索指定范围内连续标志符号索引的宽度（以逻辑单位表示）。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>parameters

*giFirst*<br/>
从当前字体指定连续标志符号索引组中的第一个标志符号索引。 仅当*pgi*参数为 NULL 时，才使用此参数。

*cgi*<br/>
指定字形索引的数目。

*pgi*<br/>
指向包含标志符号索引的数组的指针。 如果该值为 NULL，则改为使用*giFirst*参数。 *Cgi*参数指定此数组中标志符号索引的数目。

*lpabc*<br/>
指向接收字符宽度的[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)结构的数组的指针。 此数组必须包含至少与多个 `ABC` 结构，因为存在由*cgi*参数指定的标志符号索引。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi)的功能，如 Windows SDK 中所述。

##  <a name="getcharwidth"></a>CDC：： GetCharWidth

使用 `m_hAttribDC`，从输入设备上下文中检索一组连续字符中各个字符的宽度。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>parameters

*nFirstChar*<br/>
指定当前字体中连续一组字符中的第一个字符。

*nLastChar*<br/>
指定当前字体中连续字符组中的最后一个字符。

*lpBuffer*<br/>
指向一个缓冲区，该缓冲区将接收当前字体中连续一组字符的宽度值。

*lpFloatBuffer*<br/>
指向用于接收字符宽度的缓冲区。 返回的宽度采用32位 IEEE 浮点格式。 （宽度按字符的基准线计量。）

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识字母 "a"，而*nLastChar*标识字母 "z"，则函数将检索所有小写字符的宽度。

函数将值存储在*lpBuffer*所指向的缓冲区中。 此缓冲区必须足够大才能容纳所有宽度。 也就是说，在给定的示例中必须至少有26个条目。

如果连续字符组中的字符不是特定字体中的字符，则会为其分配默认字符的宽度值。

##  <a name="getcharwidthi"></a>CDC：： GetCharWidthI

从当前字体检索指定范围内连续标志符号索引的宽度（以逻辑坐标表示）。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>parameters

*giFirst*<br/>
从当前字体指定连续标志符号索引组中的第一个标志符号索引。 仅当*pgi*参数为 NULL 时，才使用此参数。

*cgi*<br/>
指定字形索引的数目。

*pgi*<br/>
指向包含标志符号索引的数组的指针。 如果该值为 NULL，则改为使用*giFirst*参数。 *Cgi*参数指定此数组中标志符号索引的数目。

*lpBuffer*<br/>
指向接收宽度的缓冲区的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi)的功能，如 Windows SDK 中所述。

##  <a name="getclipbox"></a>CDC：： GetClipBox

检索围绕当前剪辑边界的紧密边框的尺寸。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向要接收矩形尺寸的[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="return-value"></a>返回值

剪辑区域的类型。 可以是以下任一值：

- COMPLEXREGION 剪辑区域的边框重叠。

- 错误：设备上下文无效。

- NULLREGION 剪辑区域为空。

- SIMPLEREGION 剪辑区域没有重叠的边框。

### <a name="remarks"></a>备注

维度将复制到*lpRect*所指向的缓冲区。

##  <a name="getcoloradjustment"></a>CDC：： GetColorAdjustment

检索设备上下文的颜色调整值。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>parameters

*lpColorAdjust*<br/>
指向用于接收颜色调整值的[COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)数据结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getcurrentbitmap"></a>CDC：： GetCurrentBitmap

返回指向当前选定 `CBitmap` 对象的指针。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CBitmap` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可能会返回临时对象。

##  <a name="getcurrentbrush"></a>CDC：： GetCurrentBrush

返回指向当前选定 `CBrush` 对象的指针。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CBrush` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可能会返回临时对象。

##  <a name="getcurrentfont"></a>CDC：： GetCurrentFont

返回指向当前选定 `CFont` 对象的指针。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CFont` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可能会返回临时对象。

##  <a name="getcurrentpalette"></a>CDC：： GetCurrentPalette

返回指向当前选定 `CPalette` 对象的指针。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CPalette` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可能会返回临时对象。

##  <a name="getcurrentpen"></a>CDC：： GetCurrentPen

返回指向当前选定 `CPen` 对象的指针。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CPen` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

此成员函数可能会返回临时对象。

##  <a name="getcurrentposition"></a>CDC：： GetCurrentPosition

检索当前位置（以逻辑坐标表示）。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的当前位置。

### <a name="remarks"></a>备注

当前位置可以设置为 `MoveTo` 成员函数。

##  <a name="getdcbrushcolor"></a>CDC：： GetDCBrushColor

检索当前画笔的颜色。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>返回值

如果该函数成功，则返回值为当前画笔颜色的[COLORREF](/windows/win32/gdi/colorref)值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)的功能，如 Windows SDK 中所述。

##  <a name="getdcpencolor"></a>CDC：： GetDCPenColor

检索当前的钢笔颜色。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>返回值

如果该函数成功，则返回值为当前笔颜色的[COLORREF](/windows/win32/gdi/colorref)值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)，如 Windows SDK 中所述。

##  <a name="getdevicecaps"></a>CDC：： GetDeviceCaps

检索有关显示设备的各种特定于设备的信息。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>parameters

*nIndex*<br/>
指定要返回的信息的类型。 有关值的列表，请参阅 Windows SDK 中的[GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) 。

### <a name="return-value"></a>返回值

如果函数成功，则为所请求的功能的值。

### <a name="example"></a>示例

  请参阅[CPrintDialog：： GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)的示例。

##  <a name="getfontdata"></a>CDC：： GetFontData

从可缩放的字体文件中检索字体指标信息。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>parameters

*dwTable*<br/>
指定要返回的度量值表的名称。 此参数可以是 Microsoft Corporation 发布的 TrueType 字体文件规范中所述的指标表之一。 如果此参数为0，则从字体文件的开头开始检索信息。

*dwOffset*<br/>
指定从表开头开始检索信息的偏移量。 如果此参数为0，则从*dwTable*参数所指定的表的开头检索信息。 如果此值大于或等于表的大小，`GetFontData` 将返回0。

*lpData*<br/>
指向将接收字体信息的缓冲区。 如果此值为 NULL，则函数返回在*dwTable*参数中指定的字体数据所需的缓冲区大小。

*cbData*<br/>
指定要检索的信息的长度（以字节为单位）。 如果此参数为0，则 `GetFontData` 返回在*dwTable*参数中指定的数据的大小。

### <a name="return-value"></a>返回值

如果函数成功，则指定*lpData*所指向的缓冲区中返回的字节数。否则为-1。

### <a name="remarks"></a>备注

通过指定字体文件中的偏移量和要返回的信息的长度来标识要检索的信息。

应用程序有时可以使用 `GetFontData` 成员函数来保存 TrueType 字体和文档。 为此，应用程序将确定是否可以嵌入字体，然后检索整个字体文件，并为*dwTable*、 *dwOffset*和*cbData*参数指定0。

应用程序可以通过检查[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)结构的 `otmfsType` 成员来确定是否可以嵌入字体。 如果设置 `otmfsType` 的第1位，则不允许嵌入字体。 如果第1位为明文，则可以嵌入该字体。 如果设置了 bit 2，则嵌入为只读。

如果应用程序尝试使用此函数来检索非 TrueType 字体的信息，则 `GetFontData` 成员函数将返回-1。

##  <a name="getfontlanguageinfo"></a>CDC：： GetFontLanguageInfo

返回指定显示上下文的当前选定字体的相关信息。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>返回值

返回值标识当前选定字体的特征。 有关可能值的完整列表，请参阅[GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)的功能，如 Windows SDK 中所述。

##  <a name="getglyphoutline"></a>CDC：： GetGlyphOutline

检索当前字体中的轮廓字符的轮廓曲线或位图。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>parameters

*nChar*<br/>
指定要为其返回信息的字符。

*nFormat*<br/>
指定函数返回信息的格式。 可以是以下值之一，也可以是0：

|值|含义|
|-----------|-------------|
|GGO_BITMAP|返回标志符号位图。 当函数返回时， *lpBuffer*所指向的缓冲区包含一个每像素1位的位图，其行从多个字边界开始。|
|GGO_NATIVE|使用设备单位返回光栅化程序本机格式的曲线数据点。 如果指定此值，则将忽略*lpmat2*中指定的任何转换。|

当*nFormat*的值为0时，函数将填充[GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics)结构，但不返回标志符号大纲数据。

*lpgm*<br/>
指向描述字符单元中标志符号位置的 GLYPHMETRICS 结构。

*cbBuffer*<br/>
指定函数为其复制有关大纲字符的信息的缓冲区大小。 如果此值为0，并且*nFormat*参数是 GGO_BITMAP 或 GGO_NATIVE 值，则该函数将返回所需的缓冲区大小。

*lpBuffer*<br/>
指向函数将有关轮廓字符的信息复制到的缓冲区。 如果*nFormat*指定 GGO_NATIVE 值，则以 TTPOLYGONHEADER 和 TTPOLYCURVE 结构的形式复制信息。 如果此值为 NULL，并且*nFormat*是 GGO_BITMAP 或 GGO_NATIVE 值，则该函数将返回所需的缓冲区大小。

*lpmat2*<br/>
指向包含字符的转换矩阵的[MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2)结构。 即使为*nFormat*指定了 GGO_NATIVE 值，此参数也不能为 NULL。

### <a name="return-value"></a>返回值

如果*cbBuffer*为0或*lpBuffer*为 NULL，则检索的信息所需的缓冲区大小（以字节为单位）。 否则，如果函数成功，则该值为正值; 如果出现错误，则为-1。

### <a name="remarks"></a>备注

应用程序可以通过在*lpmat2*指向的结构中指定一个 2 x 2 的变换矩阵来旋转以位图格式检索的字符。

标志符号轮廓作为一系列轮廓返回。 每个轮廓由一个[TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)结构定义，后跟所需的任意多个 `TTPOLYCURVE` 结构。 所有点都作为[POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx)结构返回，表示绝对位置，而不是相对移动。 [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)结构的 `pfxStart` 成员指定的起始点为开始轮廓轮廓的点。 下面的[TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve)结构可以是折线记录或样条记录。 折线记录是一系列的点;点之间绘制的线条描述字符的轮廓。 样条记录表示 TrueType 使用的二次曲线（即，二次 b 样条）。

##  <a name="getgraphicsmode"></a>CDC：： GetGraphicsMode

检索指定设备上下文的当前图形模式。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>返回值

在成功时返回当前图形模式。 有关此方法可以返回值的列表，请参阅[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

失败时返回0。

若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

##  <a name="gethalftonebrush"></a>CDC：： GetHalftoneBrush

调用此成员函数以检索半色调画笔。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CBrush` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

半色调画笔显示了颜色为前景色和背景色以创建抖动模式的像素。 下面是由半色调画笔创建的抖动模式的示例。

![抖动笔描边的详细信息](../../mfc/reference/media/vc318s1.gif "抖动钢笔笔画详细信息")

##  <a name="getkerningpairs"></a>CDC：： GetKerningPairs

检索指定设备上下文中当前选定字体的字符字偶间距对。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>parameters

*nPairs*<br/>
指定*lpkrnpair*指向的[KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair)结构的数量。 函数将不会复制*nPairs*指定的更多字偶间距对。

*lpkrnpair*<br/>
指向当函数返回时接收字偶间距对的 `KERNINGPAIR` 结构的数组。 此数组必须包含*nPairs*指定的最多结构。 如果此参数为 NULL，则该函数将返回该字体的字偶间距对的总数。

### <a name="return-value"></a>返回值

如果函数成功，则指定所检索的字偶间距对的数量，或字体的字偶间距调整总数。 如果函数失败或字体没有字偶间距对，则返回零。

##  <a name="getlayout"></a>CDC：： GetLayout

调用此成员函数来确定设备上下文的文本和图形的布局，如打印机或图元文件。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>返回值

如果成功，则为当前设备上下文的布局标志。 否则，GDI_ERROR。 有关扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。 有关布局标志的列表，请参阅[CDC：： SetLayout](#setlayout)。

### <a name="remarks"></a>备注

默认布局为从左到右。

##  <a name="getmapmode"></a>CDC：： GetMapMode

检索当前映射模式。

```
int GetMapMode() const;
```

### <a name="return-value"></a>返回值

映射模式。

### <a name="remarks"></a>备注

有关映射模式的说明，请参阅 `SetMapMode` 成员函数。

> [!NOTE]
>  如果调用[SetLayout](#setlayout)将 DC 改为从右到左布局，`SetLayout` 会自动将映射模式改为 MM_ISOTROPIC。 因此，对 `GetMapMode` 的任何后续调用都将返回 MM_ISOTROPIC。

##  <a name="getmiterlimit"></a>CDC：： GetMiterLimit

返回设备上下文的斜接限制。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

绘制具有斜切联接的几何线条时使用转角限制。

##  <a name="getnearestcolor"></a>CDC：： GetNearestColor

返回与指定的逻辑颜色最匹配的纯色。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>parameters

*crColor*<br/>
指定要匹配的颜色。

### <a name="return-value"></a>返回值

RGB （红、绿、蓝）颜色值，用于定义与设备可表示的*crColor*值最接近的纯色。

### <a name="remarks"></a>备注

给定的设备必须能够表示此颜色。

##  <a name="getoutlinetextmetrics"></a>CDC：： GetOutlineTextMetrics

检索 TrueType 字体的指标信息。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>parameters

*lpotm*<br/>
指向[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)结构的数组。 如果此参数为 NULL，则函数返回检索到的指标数据所需的缓冲区大小。

*cbData*<br/>
指定返回信息的缓冲区的大小（以字节为单位）。

*lpotm*<br/>
指向 `OUTLINETEXTMETRIC` 结构。 如果此参数为 NULL，则函数返回检索到的指标信息所需的缓冲区大小。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)结构包含与 TrueType 格式一起提供的大多数字体指标信息，包括[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。 `OUTLINETEXTMETRIC` 结构的最后四个成员是指向字符串的指针。 除了其他成员所需的空间外，应用程序还应为这些字符串分配空间。 由于对于字符串大小没有系统强制限制，因此分配内存的最简单方法是通过在第一次调用 `GetOutlineTextMetrics` 函数时为*lpotm*指定 NULL 来检索所需的大小。

##  <a name="getoutputcharwidth"></a>CDC：： GetOutputCharWidth

使用输出设备上下文 `m_hDC`，并从当前字体检索连续字符组中各个字符的宽度。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>parameters

*nFirstChar*<br/>
指定当前字体中连续一组字符中的第一个字符。

*nLastChar*<br/>
指定当前字体中连续字符组中的最后一个字符。

*lpBuffer*<br/>
指向一个缓冲区，该缓冲区将接收当前字体中连续一组字符的宽度值。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

例如，如果*nFirstChar*标识字母 "a"，而*nLastChar*标识字母 "z"，则函数将检索所有小写字符的宽度。

函数将值存储在*lpBuffer*所指向的缓冲区中。 此缓冲区必须足够大才能容纳所有宽度;也就是说，在给定的示例中必须至少有26个条目。

如果连续字符组中的字符不是特定字体中的字符，则会为其分配默认字符的宽度值。

##  <a name="getoutputtabbedtextextent"></a>CDC：： GetOutputTabbedTextExtent

调用此成员函数可使用[m_hDC](#m_hdc)（输出设备上下文）来计算字符串的宽度和高度。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向要测量的字符串。 还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向的[字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定*lpnTabStopPositions*所指向的数组中的制表位位置的数目。

*lpnTabStopPositions*<br/>
指向包含逻辑单元中的制表位位置的整数数组。 制表位必须按递增顺序排序;最小的 x 值应是数组中的第一项。 不允许使用 Back 选项卡。

*str*<br/>
一个 `CString` 对象，它包含要测量的指定字符。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串的尺寸（以逻辑单位为单位）。

### <a name="remarks"></a>备注

如果字符串包含一个或多个制表符，则字符串的宽度将基于*lpnTabStopPositions*指定的制表位。 函数使用当前选定的字体来计算字符串的维度。

当前剪辑区域不会偏移 `GetOutputTabbedTextExtent` 函数返回的宽度和高度。

由于某些设备不会将字符放入常规单元数组（也就是说，它们会对字符进行字偶间距调整），因此字符串中字符的范围总和可能不会等于字符串的范围。

如果*nTabPositions*为0， *lpnTabStopPositions*为 NULL，则选项卡将扩展到8个平均字符宽度。 如果*nTabPositions*为1，则制表位将由数组中第一个值指定的距离分隔到*lpnTabStopPositions*点。 如果*lpnTabStopPositions*指向多个值，则会为数组中的每个值设置一个制表位，直至*nTabPositions*指定的数字为止。

##  <a name="getoutputtextextent"></a>CDC：： GetOutputTextExtent

使用当前字体调用此成员函数以使用输出设备上下文、 [m_hDC](#m_hdc)，并计算文本行的宽度和高度。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向字符串字符串。 还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向的[字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*str*<br/>
一个 `CString` 对象，它包含要测量的指定字符。

### <a name="return-value"></a>返回值

在[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中返回的字符串的尺寸（以逻辑单位为单位）。

### <a name="remarks"></a>备注

当前剪辑区域不会影响 `GetOutputTextExtent`返回的宽度和高度。

由于某些设备不会将字符放入常规单元数组（也就是说，它们执行字偶间距调整），因此字符串中字符的范围的总和可能不会等于字符串的范围。

##  <a name="getoutputtextmetrics"></a>CDC：： GetOutputTextMetrics

使用 `m_hDC`（输出设备上下文）检索当前字体的指标。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>parameters

*lpMetrics*<br/>
指向接收指标的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getpath"></a>CDC：： GetPath

检索定义线条终结点和在设备上下文中选择的路径中找到的曲线的控制点的坐标。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向[点](/windows/win32/api/windef/ns-windef-point)数据结构的数组，或放置直线终结点和曲线控制点的 `CPoint` 对象。

*lpTypes*<br/>
指向放置顶点类型的字节数组。 值为下列值之一：

- PT_MOVETO 指定*lpPoints*中的相应点启动不相交的图形。

- PT_LINETO 指定上一个点， *lpPoints*中的相应点是行的端点。

- PT_BEZIERTO 指定*lpPoints*中的相应点是 Bzier 曲线的控制点或结束点。

PT_BEZIERTO 类型总是以三组出现。 位于它们前面的路径中的点定义 Bzier 曲线的起点。 前两 PT_BEZIERTO 点是控制点，第三个 PT_BEZIERTO 点是终点（如果是硬编码）。

   可以将 PT_LINETO 或 PT_BEZIERTO 类型与以下标志（通过使用按位运算符**或**）组合在一起，以指示相应点为图形中的最后一个点，并且应关闭该图形：

- PT_CLOSEFIGURE 指定在绘制相应的线条或曲线后，图形自动关闭。 通过绘制直线或曲线端点到与最后 PT_MOVETO 相对应的点，闭合图形。

*nCount*<br/>
指定可能放置在*lpPoints*数组中的[点](/windows/win32/api/windef/ns-windef-point)数据结构的总数。 此值必须与*lpTypes*数组中可放置的字节数相同。

### <a name="return-value"></a>返回值

如果*nCount*参数为非零值，则枚举的点数。 如果*nCount*为0，则路径中的总点数（和 `GetPath` 不向缓冲区写入任何内容）。 如果*nCount*为非零值且小于路径中的点数，则返回值为-1。

### <a name="remarks"></a>备注

设备上下文必须包含关闭的路径。 路径的点以逻辑坐标形式返回。 点以设备坐标的形式存储在路径中，因此 `GetPath` 使用当前转换的逆点将点从设备坐标改为逻辑坐标。 在 `GetPath`之前，可以调用 `FlattenPath` 成员函数将路径中的所有曲线转换为行段。

### <a name="example"></a>示例

  请参阅[CDC：： BeginPath](#beginpath)的示例。

##  <a name="getpixel"></a>CDC：： Picture.getpixel

检索*x*和*y*指定的点处像素的 RGB 颜色值。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>parameters

*x*<br/>
指定要检查的点的逻辑 x 坐标。

*y*<br/>
指定要检查的点的逻辑 y 坐标。

*情况*<br/>
指定要检查的点的逻辑 x 和 y 坐标。

### <a name="return-value"></a>返回值

对于每个版本的函数，为给定点颜色的 RGB 颜色值。 如果坐标未在剪辑区域中指定点，则为-1。

### <a name="remarks"></a>备注

点必须位于剪辑区域中。 如果该点不在剪辑区域中，则该函数无效并返回-1。

不是所有的设备都支持 `GetPixel` 函数。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数下的 RC_BITBLT 光栅功能。

`GetPixel` 成员函数有两种形式。 第一种采用两个坐标值;第二种方法是使用[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

##  <a name="getpolyfillmode"></a>CDC：： GetPolyFillMode

检索当前多边形填充模式。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>返回值

如果函数成功，则为当前多边形填充模式：交替或缠绕。

### <a name="remarks"></a>备注

有关多边形填充模式的说明，请参阅 `SetPolyFillMode` 成员函数。

##  <a name="getrop2"></a>CDC：： GetROP2

检索当前的绘制模式。

```
int GetROP2() const;
```

### <a name="return-value"></a>返回值

绘图模式。 有关绘制模式值的列表，请参阅 `SetROP2` 成员函数。

### <a name="remarks"></a>备注

绘制模式指定笔颜色和填充对象的内部如何与显示表面上已有的颜色组合。

##  <a name="getsafehdc"></a>CDC：： GetSafeHdc

调用此成员函数以获取[m_hDC](#m_hdc)输出设备上下文。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>返回值

设备上下文句柄。

### <a name="remarks"></a>备注

此成员函数也可用于 null 指针。

##  <a name="getstretchbltmode"></a>CDC：： GetStretchBltMode

检索当前位图拉伸模式。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>返回值

如果函数成功，则返回值指定当前位图拉伸模式（STRETCH_ANDSCANS、STRETCH_DELETESCANS 或 STRETCH_ORSCANS）。

### <a name="remarks"></a>备注

位图拉伸模式定义了如何从 `StretchBlt` 成员函数拉伸或压缩的位图中删除信息。

STRETCH_ANDSCANS 和 STRETCH_ORSCANS 模式通常用于在单色位图中保留前景像素。 STRETCH_DELETESCANS 模式通常用于保留颜色位图中的颜色。

##  <a name="gettabbedtextextent"></a>CDC：： GetTabbedTextExtent

调用此成员函数可使用[m_hAttribDC](#m_hattribdc)（特性设备上下文）来计算字符串的宽度和高度。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向字符串。 还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定*lpszString*指向的[字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定*lpnTabStopPositions*所指向的数组中的制表位位置的数目。

*lpnTabStopPositions*<br/>
指向包含逻辑单元中的制表位位置的整数数组。 制表位必须按递增顺序排序;最小的 x 值应是数组中的第一项。 不允许使用 Back 选项卡。

*str*<br/>
一个 `CString` 对象，它包含要绘制的指定字符。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串的尺寸（以逻辑单位为单位）。

### <a name="remarks"></a>备注

如果字符串包含一个或多个制表符，则字符串的宽度将基于*lpnTabStopPositions*指定的制表位。 函数使用当前选定的字体来计算字符串的维度。

当前剪辑区域不会偏移 `GetTabbedTextExtent` 函数返回的宽度和高度。

由于某些设备不会将字符放入常规单元数组（也就是说，它们会对字符进行字偶间距调整），因此字符串中字符的范围总和可能不会等于字符串的范围。

如果*nTabPositions*为0， *lpnTabStopPositions*为 NULL，则选项卡将扩展为平均字符宽度的8倍。 如果*nTabPositions*为1，则制表位将由数组中第一个值指定的距离分隔到*lpnTabStopPositions*点。 如果*lpnTabStopPositions*指向多个值，则会为数组中的每个值设置一个制表位，直至*nTabPositions*指定的数字为止。

##  <a name="gettextalign"></a>CDC：： GetTextAlign

检索设备上下文的文本对齐标志的状态。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>返回值

文本对齐标志的状态。 返回值为以下一个或多个值：

- TA_BASELINE 指定边框内 x 轴和所选字体的基线对齐方式。

- TA_BOTTOM 指定 x 轴和边框底部的对齐方式。

- TA_CENTER 指定 y 轴和边框中心的对齐方式。

- TA_LEFT 指定 y 轴和边框左边的对齐方式。

- TA_NOUPDATECP 指定不更新当前位置。

- TA_RIGHT 指定边框和边框右侧的对齐方式。

- TA_TOP 指定 x 轴和边框顶部的对齐方式。

- TA_UPDATECP 指定更新当前位置。

### <a name="remarks"></a>备注

文本对齐标志确定 `TextOut` 和 `ExtTextOut` 成员函数相对于字符串的起始点如何对齐文本字符串。 文本对齐标志不一定是单位标志，并且可能等于0。 若要测试标志是否已设置，应用程序应遵循以下步骤：

1. 对标志及其相关标志应用按位 "或" 运算符，按如下所示进行分组：

    - TA_LEFT、TA_CENTER 和 TA_RIGHT

    - TA_BASELINE、TA_BOTTOM 和 TA_TOP

    - TA_NOUPDATECP 和 TA_UPDATECP

1. 向结果和 `GetTextAlign`的返回值应用按位 "与" 运算符。

1. 测试此结果是否与标志相等。

##  <a name="gettextcharacterextra"></a>CDC：： GetTextCharacterExtra

检索 intercharacter 间距量的当前设置。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>返回值

Intercharacter 间距量。

### <a name="remarks"></a>备注

在将一行文本写入设备上下文时，GDI 将此间距添加到每个字符，包括分隔符字符。

Intercharacter 间距的默认值为0。

##  <a name="gettextcolor"></a>CDC：： GetTextColor

检索当前文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

作为 RGB 颜色值的当前文本颜色。

### <a name="remarks"></a>备注

文本颜色是使用 GDI 文本输出成员函数[TextOut](#textout)、 [ExtTextOut](#exttextout)和[TabbedTextOut](#tabbedtextout)绘制的字符的前景色。

##  <a name="gettextextent"></a>CDC：： GetTextExtent

使用当前字体调用此成员函数来计算文本行的宽度和高度，以确定尺寸。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>parameters

*lpszString*<br/>
指向字符串字符串。 还可以为此参数传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。

*nCount*<br/>
指定字符串中的字符数。

*str*<br/>
一个包含指定字符的 `CString` 对象。

### <a name="return-value"></a>返回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)对象中的字符串的尺寸（以逻辑单位为单位）。

### <a name="remarks"></a>备注

此信息从[m_hAttribDC](#m_hattribdc)的属性设备上下文中检索而来。

默认情况下，`GetTextExtent` 假设其检索维度的文本沿水平线（即，行距为0）设置。 如果创建的字体指定非零行距，则必须显式转换文本角度以获取字符串的尺寸。

当前剪辑区域不会影响 `GetTextExtent`返回的宽度和高度。

由于某些设备不会将字符放入常规单元数组（也就是说，它们执行字偶间距调整），因此字符串中字符的范围的总和可能不会等于字符串的范围。

##  <a name="gettextextentexpointi"></a>CDC：： GetTextExtentExPointI

检索指定字符串中将适合指定空间的字符数，并用其中每个字符的文本范围填充数组。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*pgiIn*<br/>
一个指针，指向要为其检索范围的标志符号索引的数组。

*cgi*<br/>
指定*pgiIn*所指向的数组中的标志符号数。

*nMaxExtent*<br/>
指定带格式的字符串允许的最大宽度（以逻辑单位为单位）。

*lpnFit*<br/>
指向一个整数的指针，该整数接收*nMaxExtent*指定的空间中将容纳的最大字符数的计数。 当*lpnFit*为 NULL 时，将忽略*nMaxExtent* 。

*alpDx*<br/>
一个指针，指向接收部分标志符号范围的整数数组。 数组中的每个元素都提供了标志符号索引数组的开头与*nMaxExtent*所指定空间中的一个标志符号之间的距离（以逻辑单位表示）。 尽管此数组应具有至少与*cgi*指定的标志符号索引数量相同的元素，但函数只使用*lpnFit*指定的多个标志符号索引来填充数组。 如果*lpnDx*为 NULL，则该函数不计算部分字符串宽度。

*lpSize*<br/>
指向一个[大小](/windows/win32/api/windef/ns-windef-size)结构的指针，该结构接收标志符号索引数组的尺寸（以逻辑单元表示）。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)的功能，如 Windows SDK 中所述。

##  <a name="gettextextentpointi"></a>CDC：： GetTextExtentPointI

检索指定标志符号索引数组的宽度和高度。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*pgiIn*<br/>
一个指针，指向要为其检索范围的标志符号索引的数组。

*cgi*<br/>
指定*pgiIn*所指向的数组中的标志符号数。

*lpSize*<br/>
指向一个[大小](/windows/win32/api/windef/ns-windef-size)结构的指针，该结构接收标志符号索引数组的尺寸（以逻辑单元表示）。 此值不能为 NULL。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数模拟函数[GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi)的功能，如 Windows SDK 中所述。

##  <a name="gettextface"></a>CDC：： GetTextFace

调用此成员函数将当前字体的字样名称复制到缓冲区中。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>parameters

*nCount*<br/>
指定缓冲区的大小（以字节为单位）。 如果字样名称长度超过此参数指定的字节数，则将截断名称。

*lpszFacename*<br/>
指向字样名称的缓冲区。

*rString*<br/>
对[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象的引用。

### <a name="return-value"></a>返回值

复制到缓冲区的字节数，不包括终止 null 字符。 如果发生错误，则为0。

### <a name="remarks"></a>备注

字样名称将作为以 null 结尾的字符串复制。

##  <a name="gettextmetrics"></a>CDC：： GetTextMetrics

使用特性设备上下文检索当前字体的指标。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>parameters

*lpMetrics*<br/>
指向接收指标的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)结构。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="getviewportext"></a>CDC：： GetViewportExt

检索设备上下文视区的 x 和 y 范围。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>返回值

作为 `CSize` 对象的 x 和 y 范围（以设备单位表示）。

##  <a name="getviewportorg"></a>CDC：： GetViewportOrg

检索与设备上下文关联的视区的原点的 x 坐标和 y 坐标。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的视区的原点（以设备坐标表示）。

##  <a name="getwindow"></a>CDC：： GetWindow

返回与显示设备上下文关联的窗口。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向 `CWnd` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

这是一个高级函数。 例如，在打印或打印预览时，此成员函数可能不会返回视图窗口。 它始终返回与输出关联的窗口。 使用给定 DC 的输出函数在此窗口中进行绘制。

##  <a name="getwindowext"></a>CDC：： GetWindowExt

检索与设备上下文关联的窗口的 x 和 y 范围。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>返回值

作为 `CSize` 对象的 x 和 y 范围（以逻辑单位表示）。

##  <a name="getwindoworg"></a>CDC：： GetWindowOrg

检索与设备上下文关联的窗口的原点的 x 坐标和 y 坐标。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>返回值

窗口（以逻辑坐标表示）作为 `CPoint` 对象的原点。

##  <a name="getworldtransform"></a>CDC：： GetWorldTransform

检索当前世界空间到页面空间的转换。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>parameters

*rXform*<br/>
对接收当前世界空间到页面空间转换的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构的引用。

### <a name="return-value"></a>返回值

如果成功，则返回一个非零值。

失败时返回0。

若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)。

##  <a name="gradientfill"></a>CDC：： GradientFill

调用此成员函数以用平滑从一侧到另一侧的颜色填充矩形和三角形结构。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>parameters

*pVertices*<br/>
一个指针，指向[TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex)结构的数组，每个结构都定义一个三角形顶点。

*nVertices*<br/>
顶点的数目。

*pMesh*<br/>
三角形模式下[GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle)结构的数组，或以矩形模式[GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect)结构的数组。

*nMeshElements*<br/>
*PMesh*中的元素数（三角形或矩形）。

*dwMode*<br/>
指定渐变填充模式。 有关可能值的列表，请参阅 Windows SDK 中的[GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) 。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅 Windows SDK 中的 `GradientFill`。

##  <a name="graystring"></a>CDC：： GrayString

通过在内存位图中书写文本、使位图变暗，然后将位图复制到显示位置，在给定位置绘制灰显的（灰色）文本。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>parameters

*pBrush*<br/>
标识要用于变暗的画笔（灰色）。

*lpfnOutput*<br/>
指定将绘制字符串的应用程序提供的回调函数的过程实例地址。 有关详细信息，请参阅 Windows `OutputFunc`[回调函数](callback-functions-used-by-mfc.md#graystring)说明。 如果此参数为 NULL，则系统将使用 Windows `TextOut` 函数绘制字符串，而*lpData*将被假定为指向要输出的字符串的长指针。

*lpData*<br/>
指定指向要传递给 output 函数的数据的远端指针。 如果*lpfnOutput*为 NULL，则*lpData*必须是指向要输出字符串的长指针。

*nCount*<br/>
指定要输出的字符数。 如果此参数为0，则 `GrayString` 计算字符串的长度（假定*lpData*是指向字符串的指针）。 如果*nCount*为1，并且*lpfnOutput*指向的函数返回0，则显示图像，但不会显示为灰色。

*x*<br/>
指定包含字符串的矩形的起始位置的逻辑 x 坐标。

*y*<br/>
指定包含字符串的矩形的起始位置的逻辑 y 坐标。

*nWidth*<br/>
指定包含字符串的矩形的宽度（以逻辑单位为单位）。 如果*nWidth*为0，则 `GrayString` 计算区域的宽度，假设*lpData*是指向字符串的指针。

*nHeight*<br/>
指定包含字符串的矩形的高度（以逻辑单位为单位）。 如果*nHeight*为0，则 `GrayString` 计算区域的高度，假设*lpData*是指向字符串的指针。

### <a name="return-value"></a>返回值

如果提取字符串，则为非零; 如果 `TextOut` 函数或应用程序提供的输出函数返回0，则为 0; 如果没有足够的内存来创建用于变暗的内存位图，则为0。

### <a name="remarks"></a>备注

无论选定的画笔和背景如何，函数都将为文本变暗。 `GrayString` 成员函数使用当前选定的字体。 使用此函数之前，必须选择 MM_TEXT 映射模式。

应用程序可以在支持纯灰色颜色的设备上绘制灰显（灰显）的字符串，而无需调用 `GrayString` 成员函数。 系统颜色 COLOR_GRAYTEXT 是用于绘制禁用文本的灰色系统颜色。 应用程序可以调用 `GetSysColor` Windows 函数来检索 COLOR_GRAYTEXT 的颜色值。 如果颜色不是0（黑色），则应用程序可以调用 `SetTextColor` 成员函数将文本颜色设置为颜色值，然后直接绘制字符串。 如果检索的颜色为黑色，则应用程序必须调用 `GrayString` 以使文本变暗（灰色）。

如果*lpfnOutput*为 NULL，则 GDI 将使用 Windows [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw)函数，而*lpData*被假定为要输出的字符的远端指针。 如果 `TextOut` 成员函数无法处理要输出的字符（例如，字符串存储为位图），则应用程序必须提供其自己的输出函数。

另请注意，在返回 Windows 之前，所有回调函数都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

传递给 `GrayString` 的回调函数必须使用 `__stdcall` 调用约定，并且必须使用 `__declspec`导出。

当框架处于预览模式时，对 `GrayString` 成员函数的调用会转换为 `TextOut` 调用，并且不会调用回调函数。

##  <a name="himetrictodp"></a>CDC：： HIMETRICtoDP

在将 HIMETRIC 大小从 OLE 转换为像素时使用此函数。

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

如果设备上下文对象的映射模式为 MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC 或 MM_HIMETRIC，则转换将基于物理英寸的像素数。 如果映射模式是其他非约束模式（例如 MM_TEXT）之一，则转换基于逻辑英寸中的像素数。

##  <a name="himetrictolp"></a>CDC：： HIMETRICtoLP

调用此函数可将 HIMETRIC 单位转换为逻辑单元。

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

当从 OLE 获取 HIMETRIC 大小并希望将其转换为应用程序的自然映射模式时，请使用此函数。

首先，通过将 HIMETRIC 单位转换为像素，然后使用设备上下文的当前映射单位将这些单位转换为逻辑单元来完成转换。 请注意，设备的窗口和视区的范围将影响结果。

##  <a name="intersectcliprect"></a>CDC：： IntersectClipRect

创建新的剪辑区域，方法是：形成当前区域与由*x1*、 *y1*、 *x2*和*y2*指定的矩形的交集。

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定矩形左上角的逻辑 x 坐标。

*y1*<br/>
指定矩形左上角的逻辑 y 坐标。

*x2*<br/>
指定矩形右下角的逻辑 x 坐标。

*y2*<br/>
指定矩形右下角的逻辑 y 坐标。

*lpRect*<br/>
指定矩形。 可以向此参数传递 `CRect` 对象或指向 `RECT` 结构的指针。

### <a name="return-value"></a>返回值

新的剪辑区域的类型。 它可以是下列值之一：

- COMPLEXREGION 新的剪辑区域的边框重叠。

- 错误：设备上下文无效。

- NULLREGION 新的剪辑区域为空。

- SIMPLEREGION 新的剪辑区域没有重叠的边框。

### <a name="remarks"></a>备注

GDI 将所有后续输出都固定在新边界内。 宽度和高度不能超过32767。

##  <a name="invertrect"></a>CDC：： InvertRect

反转给定矩形的内容。

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向包含要反转的矩形的逻辑坐标的 `RECT`。 还可以传递此参数的 `CRect` 对象。

### <a name="remarks"></a>备注

反转是逻辑非运算，并翻转每个像素的位数。 在单色显示时，该函数使白色像素为黑色，黑色像素为白色。 在颜色显示时，反转取决于为显示生成颜色的方式。 用相同的矩形调用两次 `InvertRect` 会将显示还原为其以前的颜色。

如果矩形为空，则不绘制任何内容。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>CDC：： InvertRgn

反转*pRgn*指定的区域中的颜色。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>parameters

*pRgn*<br/>
标识要反转的区域。 区域的坐标是在逻辑单元中指定的。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

在单色显示时，该函数使白色像素为黑色，黑色像素为白色。 在颜色显示时，反转取决于显示颜色的生成方式。

##  <a name="isprinting"></a>CDC：： IsPrinting

确定是否正在使用设备上下文进行打印。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>返回值

如果 `CDC` 对象是打印机 DC，则为非零值;否则为0。

##  <a name="lineto"></a>CDC：： LineTo

绘制从当前位置到*x*和*y* （或*点*）指定的点之间的直线。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定线条的端点的逻辑 x 坐标。

*y*<br/>
指定线条的端点的逻辑 y 坐标。

*情况*<br/>
指定线条的端点。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果绘制线条，则为非零值;否则为0。

### <a name="remarks"></a>备注

用所选笔绘制线条。 当前位置设置为*x*、 *y*或*点*。

### <a name="example"></a>示例

  请参阅[CRect：： CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的示例。

##  <a name="lptodp"></a>CDC：： LPtoDP

将逻辑单元转换为设备单位。

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向点的数组。 数组中的每个点都是一个[点](/windows/win32/api/windef/ns-windef-point)结构或一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*nCount*<br/>
数组中的点数。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于将矩形从逻辑设备映射到设备单位的常见情况。

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

函数将每个点的坐标或大小的维度从 GDI 的逻辑坐标系统映射到设备坐标系统。 转换取决于当前的映射模式以及设备的窗口和视区的源和范围的设置。

点的 x 和 y 坐标为范围为-32768 到32767的2字节有符号整数。 如果映射模式产生的值大于这些限制，则系统会将这些值分别设置为-32768 和32767。

##  <a name="lptohimetric"></a>CDC：： LPtoHIMETRIC

调用此函数可将逻辑单元转换为 HIMETRIC 单元。

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>parameters

*lpSize*<br/>
指向 `SIZE` 结构或 `CSize` 对象。

### <a name="remarks"></a>备注

当你向 OLE 授予 HIMETRIC 大小（从应用程序的自然映射模式转换）时，请使用此函数。 请注意，设备的窗口和视区的范围将影响结果。

通过先使用设备上下文的当前映射单元将逻辑单元转换为像素，然后将这些单位转换为 HIMETRIC 单位来完成转换。

##  <a name="m_hattribdc"></a>CDC：： m_hAttribDC

此 `CDC` 对象的特性设备上下文。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>备注

默认情况下，此设备上下文等于 `m_hDC`。 通常，请求设备上下文中信息的 `CDC` GDI 调用将定向到 `m_hAttribDC`。 有关如何使用这两个设备上下文的详细信息，请参阅[CDC](../../mfc/reference/cdc-class.md)类说明。

##  <a name="m_hdc"></a>CDC：： m_hDC

此 `CDC` 对象的输出设备上下文。

```
HDC m_hDC;
```

### <a name="remarks"></a>备注

默认情况下，`m_hDC` 等于 `m_hAttribDC`，`CDC`包装的其他设备上下文。 通常情况下，创建输出 `CDC` GDI 调用会转向 `m_hDC` 设备上下文。 可以将 `m_hDC` 和 `m_hAttribDC` 初始化为指向不同的设备。 有关如何使用这两个设备上下文的详细信息，请参阅[CDC](../../mfc/reference/cdc-class.md)类说明。

##  <a name="maskblt"></a>CDC：： MaskBlt

使用给定的掩码和光栅操作合并源和目标位图的颜色数据。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定目标矩形左上角的逻辑 x 坐标。

*y*<br/>
指定目标矩形左上角的逻辑 y 坐标。

*nWidth*<br/>
指定目标矩形和源位图的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定目标矩形和源位图的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
标识要从中复制位图的设备上下文。 如果*dwRop*参数指定的光栅操作不包括源，则必须为零。

*xSrc*<br/>
指定源位图左上角的逻辑 x 坐标。

*ySrc*<br/>
指定源位图左上角的逻辑 y 坐标。

*maskBitmap*<br/>
标识与源设备上下文中颜色位图组合在一起的单色掩码位图。

*xMask*<br/>
指定由*maskBitmap*参数指定的掩码位图的水平像素偏移量。

*yMask*<br/>
指定由*maskBitmap*参数指定的掩码位图的垂直像素偏移量。

*dwRop*<br/>
指定前台和后台三元光栅操作代码，该函数使用该代码来控制源数据和目标数据的组合。 后台光栅操作代码存储在此值高位字的高位字节内;前台光栅操作代码存储在此值高位字的低字节内;此值的低位字将被忽略，并且应为零。 宏 MAKEROP4 创建了前台和后台光栅操作代码的组合。 请参阅 "备注" 部分，了解此函数上下文中的前景和背景讨论。 有关常见的光栅操作代码的列表，请参阅 `BitBlt` 成员函数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

*MaskBitmap*指定的掩码中的值为1，表示*dwRop*指定的前台光栅操作代码应应用于该位置。 掩码中的值为0表示*dwRop*指定的后台光栅操作代码应应用于该位置。 如果光栅操作需要源，则掩码矩形必须包含源矩形。 否则，函数将失败。 如果光栅操作不需要源，则掩码矩形必须涵盖目标矩形。 否则，函数将失败。

如果调用此函数时，旋转或切变转换对源设备上下文有效，则会发生错误。 但允许进行其他类型的转换。

如果源、模式和目标位图的颜色格式不同，则此函数将转换模式或源格式，或同时转换两者，以匹配目标格式。 如果掩码位图不是单色位图，则会出现错误。 当记录增强型图元文件时，如果源设备上下文标识增强型图元文件设备上下文，则会发生错误（并且函数返回0）。 并非所有设备都支持 `MaskBlt`。 应用程序应调用 `GetDeviceCaps` 来确定设备是否支持此功能。 如果未提供掩码位图，此函数的行为与使用前台光栅操作代码 `BitBlt`完全相同。 掩码位图中的像素偏移量映射到源设备上下文位图中的点（0，0）。 这适用于掩码位图包含一组掩码的情况;应用程序可以通过调整发送到 `MaskBlt`的像素偏移量和矩形大小，轻松地将其中任何一个应用程序应用于掩码 blitting 任务。

##  <a name="modifyworldtransform"></a>CDC：： ModifyWorldTransform

使用指定模式更改设备上下文的世界转换。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>parameters

*rXform*<br/>
对用于修改给定设备上下文的世界转换的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构的引用。

*iMode*<br/>
指定转换数据修改当前世界转换的方式。 有关此参数可以采用的值的列表，请参阅[ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

### <a name="return-value"></a>返回值

如果成功，则返回一个非零值。

失败时返回0。

若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

##  <a name="moveto"></a>CDC：： MoveTo

将当前位置移动到*x*和*y*指定的点处（或按*点*）。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定新位置的逻辑 x 坐标。

*y*<br/>
指定新位置的逻辑 y 坐标。

*情况*<br/>
指定新位置。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的上一个位置的 x 和 y 坐标。

### <a name="example"></a>示例

  请参阅[CRect：： CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的示例。

##  <a name="offsetcliprgn"></a>CDC：： OffsetClipRgn

按指定的偏移量移动设备上下文的剪辑区域。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定向左或向右移动的逻辑单元数。

*y*<br/>
指定要上移或下移的逻辑单元数。

size<br/>
指定偏移量。

### <a name="return-value"></a>返回值

新区域的类型。 它可以是下列值之一：

- COMPLEXREGION 剪辑区域的边框重叠。

- 错误：设备上下文无效。

- NULLREGION 剪辑区域为空。

- SIMPLEREGION 剪辑区域没有重叠的边框。

### <a name="remarks"></a>备注

函数沿 x*轴和 y 轴沿 y 轴*移动区域*x*单位。

##  <a name="offsetviewportorg"></a>CDC：： OffsetViewportOrg

修改视区原点相对于当前视区原点的坐标。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>parameters

*nWidth*<br/>
指定要添加到当前原点的 x 坐标的设备单位数。

*nHeight*<br/>
指定要添加到当前原点的 y 坐标的设备单位数。

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的上一个视区原点（以设备坐标表示）。

##  <a name="offsetwindoworg"></a>CDC：： OffsetWindowOrg

修改窗口原点相对于当前窗口原点坐标的坐标。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>parameters

*nWidth*<br/>
指定要添加到当前原点的 x 坐标的逻辑单元数。

*nHeight*<br/>
指定要添加到当前原点的 y 坐标的逻辑单元数。

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的上一个窗口原点（以逻辑坐标表示）。

##  <a name="operator_hdc"></a>CDC：： operator HDC

使用此运算符检索 `CDC` 对象的设备上下文句柄。

```
operator HDC() const;
```

### <a name="return-value"></a>返回值

如果成功，则为设备上下文对象的句柄;否则为 NULL。

### <a name="remarks"></a>备注

您可以使用句柄直接调用 Windows Api。

##  <a name="paintrgn"></a>CDC：:P aintRgn

使用当前画笔填充*pRgn*指定的区域。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>parameters

*pRgn*<br/>
标识要填充的区域。 给定区域的坐标是在逻辑单元中指定的。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

##  <a name="patblt"></a>CDC：:P atBlt

在设备上创建位模式。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定要接收模式的矩形的左上角的逻辑 x 坐标。

*y*<br/>
指定要接收模式的矩形的左上角的逻辑 y 坐标。

*nWidth*<br/>
指定要接收模式的矩形的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定要接收模式的矩形的高度（以逻辑单位为单位）。

*dwRop*<br/>
指定光栅操作代码。 光栅操作代码（ROPs）定义 GDI 如何在输出操作中组合涉及当前画笔、可能的源位图和目标位图的颜色。 此参数可以是下列值之一：

- PATCOPY 将模式复制到目标位图。

- PATINVERT 使用布尔 XOR 运算符将目标位图与模式组合在一起。

- DSTINVERT 反转目标位图。

- BLACKNESS 会将所有输出变为黑色。

- WHITENESS 会打开所有输出白色。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

模式是所选画笔和设备上已有模式的组合。 *DwRop*指定的光栅操作代码定义如何组合模式。 为此函数列出的光栅操作是完整256三元光栅操作代码的有限子集;特别是，不能使用引用源的光栅操作代码。

并非所有设备上下文都支持 `PatBlt` 函数。 若要确定设备上下文是否支持 `PatBlt`，请使用 RASTERCAPS 索引调用 `GetDeviceCaps` 成员函数并检查 RC_BITBLT 标志的返回值。

##  <a name="pie"></a>CDC：:P ie

绘制一个扇形，绘制一条椭圆弧，其中心和两个端点按线条联接。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定边框的左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定边框的左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定边框右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定边框右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定圆弧的起点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y3*<br/>
指定圆弧的起点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*四*<br/>
指定弧形终结点的 x 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*y4*<br/>
指定弧形终结点的 y 坐标（以逻辑单位表示）。 此点不必完全位于弧上。

*lpRect*<br/>
指定边框。 可以向此参数传递 `CRect` 对象或指向 `RECT` 结构的指针。

*ptStart*<br/>
指定圆弧的起点。此点不必完全位于弧上。可以为此参数传递[点](/windows/win32/api/windef/ns-windef-point)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

*ptEnd*<br/>
指定弧的终结点。此点不必完全位于弧上。可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

弧线中心是由*x1*、 *y1*、 *X2*和*y2* （或*lpRect*）指定的边框的中心。 圆弧的起始点和结束点由*x3*、 *y3*、 *x4*和*y4* （或通过*ptStart*和*ptEnd*）指定。

弧线用所选笔绘制，以逆时针方向移动。 从每个端点到弧线中心绘制两条额外直线。 用当前画笔填充扇形区区域。 如果*x3*等于*x4* ， *y3*等于*y4*，则结果是一个椭圆，其中单行从椭圆中心到点（ *x3*， *y3*）或（ *x4*， *y4*）。

此函数绘制的图形延伸到，但不包括右坐标和下坐标。 这意味着，图形的高度为*y2* - *y1* ，而该图形的宽度是*x2* - *x1*。 边框的宽度和高度必须大于2个单位且小于32767个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>CDC：:P layMetaFile

在设备上下文上播放指定的元文件的内容。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>parameters

*hMF*<br/>
标识要播放的图元文件。

*hEnhMetaFile*<br/>
标识增强型图元文件。

*lpBounds*<br/>
指向 `RECT` 结构或 `CRect` 对象，该对象包含用于显示图片的边框的坐标。 在逻辑单元中指定坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

可以任意次播放图元文件。

第二个版本的 `PlayMetaFile` 显示存储在给定增强格式图元文件中的图片。 当应用程序调用第二个版本的 `PlayMetaFile`时，Windows 将使用增强型图元文件头中的图片框架将图片映射到*lpBounds*参数指向的矩形。 （在调用 `PlayMetaFile`之前，可以通过在输出设备中设置世界变换来剪切或旋转此图片。）沿矩形边缘的点包括在图片中。 在播放增强型图元文件之前，可以通过在输出设备中定义剪辑区域来裁剪增强型图元文件。

如果增强型图元文件包含可选调色板，则在调用第二个版本的 `PlayMetaFile`之前，应用程序可以通过在输出设备上设置调色板来实现一致的颜色。 若要检索可选调色板，请使用 `GetEnhMetaFilePaletteEntries` Windows 函数。 增强型图元文件可以嵌入到新创建的增强型图元文件中，方法是调用第二个 `PlayMetaFile` 版本，并将源增强型图元文件播放到新增强型图元文件的设备上下文中。

此函数保留输出设备上下文的状态。 此函数将删除在增强型图元文件中创建但未删除的任何对象。 若要停止此函数，应用程序可以从其他线程调用 `CancelDC` Windows 函数以终止操作。 在这种情况下，该函数将返回零。

##  <a name="plgblt"></a>CDC：:P lgBlt

执行从源设备上下文中指定的矩形到给定设备上下文中指定的平行四边形的颜色数据位的位块传输。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>parameters

*lpPoint*<br/>
指向逻辑空间中三个点的数组，该数组标识目标平行四边形的三个角。 源矩形的左上角映射到此数组中的第一个点、此数组中的第二个点的右上角和第三个点的左下角。 源矩形的右下角映射到平行四边形中的隐式第四个点。

*pSrcDC*<br/>
标识源设备上下文。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（以逻辑单位为单位）。

*ySrc*<br/>
指定源矩形左上角的 y 坐标（以逻辑单位表示）。

*nWidth*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*maskBitmap*<br/>
标识用于屏蔽源矩形颜色的可选单色位图。

*xMask*<br/>
指定单色位图左上角的 x 坐标。

*yMask*<br/>
指定单色位图的左上角的 y 坐标。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

如果给定的位掩码句柄标识有效的单色位图，则函数将使用此位图来屏蔽源矩形中颜色数据的位。

平行四边形（D）的第四个顶点是将前三个点（A、B 和 C）视为向量，计算 D = B + C-A。

如果位掩码存在，则掩码中的值1表示应将源像素颜色复制到目标。 掩码中的值为0指示不更改目标像素颜色。

如果掩码矩形小于源和目标矩形，则函数将复制掩码模式。

源设备上下文中允许缩放、转换和反射转换;但是，旋转和切变转换不是。 如果掩码位图不是单色位图，则会出现错误。 目标设备上下文的拉伸模式用于确定如何拉伸或压缩像素（如果需要）。 当记录的是增强型图元文件时，如果源设备上下文标识增强型图元文件设备上下文，则会发生错误。

目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。 如果源转换具有旋转或切变，则返回错误。 如果目标矩形和源矩形不具有相同的颜色格式，`PlgBlt` 将源矩形转换为与目标矩形匹配。 并非所有设备都支持 `PlgBlt`。 有关详细信息，请参阅 `CDC::GetDeviceCaps` 成员函数中 RC_BITBLT 光栅功能的说明。

如果源和目标设备上下文表示不兼容的设备，`PlgBlt` 将返回错误。

##  <a name="polybezier"></a>CDC：:P olyBezier

绘制一个或多个 Bzier 样条。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向一个[点](/windows/win32/api/windef/ns-windef-point)数据结构数组，其中包含样条的终结点和控制点。

*nCount*<br/>
指定*lpPoints*数组中的点数。 此值必须是要绘制的样条数的三倍以上，因为每个 Bzier 样条都需要两个控制点和一个端点，而初始样条需要另一个起点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数通过使用由*lpPoints*参数指定的终结点和控制点来绘制立方 Bzier 样条。 通过使用第二个点和第三个点作为控制点，从第一个点到第四个点绘制第一个样条。 序列中的每个后续样条只需要三个点：前一条样条的终点用作起点，序列中的下两个点是控制点，第三个是终点。

当前位置既不由 `PolyBezier` 函数使用，也不会进行更新。 图形未填充。 此函数使用当前笔绘制线条。

##  <a name="polybezierto"></a>CDC：:P olyBezierTo

绘制一个或多个 Bzier 样条。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向包含终结点和控制点的[点](/windows/win32/api/windef/ns-windef-point)数据结构数组。

*nCount*<br/>
指定*lpPoints*数组中的点数。 此值必须是要绘制的样条数的三倍，因为每个 Bzier 样条都需要两个控制点和一个终点。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数通过使用*lpPoints*参数指定的控制点来绘制立方 Bzier 样条。 使用前两个点作为控制点，将第一个样条从当前位置绘制到第三个点。 对于每个后续样条，该函数只需要三个点，并使用上一样条的终点作为下一条曲线的起点。 `PolyBezierTo` 将当前位置移到最后一个 Bzier 样条的终点。 图形未填充。 此函数使用当前笔绘制线条。

### <a name="example"></a>示例

  请参阅[CDC：： BeginPath](#beginpath)的示例。

##  <a name="polydraw"></a>CDC：:P olyDraw

绘制一组直线段和 Bzier 样条。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向一个[点](/windows/win32/api/windef/ns-windef-point)数据结构数组，其中包含每个线段的端点以及每个 Bzier 样条的端点和控制点。

*lpTypes*<br/>
指向一个数组，该数组指定*lpPoints*数组中的每个点的使用方式。 可以是下列值之一：

- PT_MOVETO 指定此点启动不相交的图形。 此点将成为新的当前位置。

- PT_LINETO 指定要将直线从当前位置绘制到此点，然后该点将成为新的当前位置。

- PT_BEZIERTO 指定该点是 Bzier 样条的控制点或结束点。

PT_BEZIERTO 类型总是以三组出现。 当前位置定义了 Bzier 样条的起点。 前两个 PT_BEZIERTO 点为控制点，第三个 PT_BEZIERTO 点为结束点。 结束点将成为新的当前位置。 如果没有三个连续的 PT_BEZIERTO 点，则会产生错误。

   可以使用按位运算符将 PT_LINETO 或 PT_BEZIERTO 类型与以下常量组合，或指示相应点为图形中的最后一个点，并关闭该图形：

- PT_CLOSEFIGURE 指定在完成此点的 PT_LINETO 或 PT_BEZIERTO 类型后，图形自动关闭。 将从该点到最近的 PT_MOVETO 或 `MoveTo` 点绘制线条。

   使用按位 "**或**" 运算符，将此标志与直线的 PT_LINETO 类型或 Bzier 样条的 PT_BEZIERTO 类型。 当前位置设置为右行的结束点。

*nCount*<br/>
指定*lpPoints*数组中的总点数，与*lpTypes*数组中的字节数相同。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此函数可用于绘制不相交的数字，以代替对 `CDC::MoveTo`、`CDC::LineTo`和 `CDC::PolyBezierTo` 成员函数的连续调用。 使用当前笔绘制线条和样条，而不填充图。 如果通过调用 `CDC::BeginPath` 成员函数启动了一个活动路径，`PolyDraw` 会将添加到该路径。 *LpPoints*数组和*lpTypes*中包含的点指示每个点是 `CDC::MoveTo`、`CDC::LineTo`还是 `CDC::BezierTo` 操作的一部分。 还可以关闭数字。 此函数更新当前位置。

### <a name="example"></a>示例

  请参阅[CDC：： BeginPath](#beginpath)的示例。

##  <a name="polygon"></a>CDC：:P olygon

使用当前笔绘制包含由两个或多个点（顶点）连接的多边形的多边形。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向指定多边形顶点的点的数组。 数组中的每个点都是 `POINT` 结构或 `CPoint` 对象。

*nCount*<br/>
指定数组中的顶点数目。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

系统会根据需要，通过从最后一个顶点到第一个顶点绘制线条来自动关闭多边形。

当前多边形填充模式可以通过使用 `GetPolyFillMode` 和 `SetPolyFillMode` 成员函数来检索或设置。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>CDC：:P olyline

绘制一组连线段，连接*lpPoints*指定的点。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向要连接的 `POINT` 结构或 `CPoint` 对象的数组。

*nCount*<br/>
指定数组中的点数。 此值必须至少为2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前笔从第一个点到后续点之间绘制线条。 与 `LineTo` 成员函数不同，`Polyline` 函数既不使用也不更新当前位置。

有关详细信息，请参阅 Windows SDK 中的[折线](/windows/win32/api/wingdi/nf-wingdi-polyline)。

##  <a name="polylineto"></a>CDC：:P olylineTo

绘制一条或多条直线。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向包含直线顶点的[点](/windows/win32/api/windef/ns-windef-point)数据结构数组。

*nCount*<br/>
指定数组中的点数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前笔从当前位置到*lpPoints*参数指定的第一个点绘制线条。 对于每个附加行，函数将从上一行的结束点绘制到*lpPoints*指定的下一个点。 `PolylineTo` 将当前位置移到最后一行的结束点。 如果此函数绘制的线段形成闭合图形，则不填充图形。

##  <a name="polypolygon"></a>CDC：:P olyPolygon

创建两个或多个使用当前多边形填充模式填充的多边形。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向 `POINT` 结构或定义多边形顶点的 `CPoint` 对象的数组。

*lpPolyCounts*<br/>
指向一个整数数组，其中每个整数指定*lpPoints*数组中某个多边形的点数。

*nCount*<br/>
*LpPolyCounts*数组中的项数。 此数值指定要绘制的多边形的数目。 此值必须至少为2。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

多边形可能不连续或重叠。

对 `PolyPolygon` 函数的调用中指定的每个多边形都必须关闭。 与 `Polygon` 成员函数创建的多边形不同，由 `PolyPolygon` 创建的多边形不会自动关闭。

函数创建两个或多个多边形。 若要创建一个多边形，应用程序应使用 `Polygon` 成员函数。

当前多边形填充模式可以通过使用 `GetPolyFillMode` 和 `SetPolyFillMode` 成员函数来检索或设置。

##  <a name="polypolyline"></a>CDC：:P olyPolyline

绘制多个连接的线段序列。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>parameters

*lpPoints*<br/>
指向包含折线顶点的结构的数组。 折线是连续指定的。

*lpPolyPoints*<br/>
指向一个变量数组，该数组指定*lpPoints*数组中对应多边形的点数。 每个条目都必须大于或等于2。

*nCount*<br/>
指定*lpPolyPoints*数组中的总计数。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前笔绘制行段。 不填充由段构成的数字。 当前位置不被此函数使用或更新。

##  <a name="ptvisible"></a>CDC：:P tVisible

确定给定点是否在设备上下文的剪辑区域内。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>parameters

*x*<br/>
指定点的逻辑 x 坐标。

*y*<br/>
指定点的逻辑 y 坐标。

*情况*<br/>
指定要在逻辑坐标中检查的点。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果指定点在剪辑区域内，则为非零值;否则为0。

##  <a name="queryabort"></a>CDC：： QueryAbort

为打印应用程序调用由[SetAbortProc](#setabortproc)成员函数安装的中止函数，并查询打印是否应终止。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>返回值

如果打印应继续或没有中止过程，则返回值为非零值。 如果打印作业应终止，则为0。 返回值由 abort 函数提供。

##  <a name="realizepalette"></a>CDC：： RealizePalette

将当前逻辑调色板中的项映射到系统调色板。

```
UINT RealizePalette();
```

### <a name="return-value"></a>返回值

指示逻辑调色板中有多少条目映射到系统调色板中的不同条目。 这表示自上次实现逻辑调色板以来，此函数重新映射以适应系统调色板中的更改的条目数。

### <a name="remarks"></a>备注

逻辑调色板作为颜色密集型应用程序与系统之间的缓冲，使应用程序可以根据需要使用任意数量的颜色，而不会干扰自身显示的颜色或其他窗口显示的颜色。

当某个窗口具有输入焦点并 `RealizePalette`调用时，Windows 将确保该窗口将显示所有请求的颜色，最多可在屏幕上同时提供最大数目。 Windows 还会通过将其与可用颜色进行匹配来显示在窗口的调色板中找不到的颜色。

此外，Windows 将调用函数的非活动窗口所请求的颜色与可用颜色完全匹配。 这可以显著减少非活动窗口中显示的颜色更改。

##  <a name="rectangle"></a>CDC：： Rectangle

使用当前笔绘制矩形。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定矩形右下角的 y 坐标（以逻辑单位表示）。

*lpRect*<br/>
指定逻辑单元中的矩形。 可以向此参数传递 `CRect` 对象或指向 `RECT` 结构的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前画笔填充矩形的内部。

该矩形的最大扩展为，但不包括右坐标和下坐标。 这意味着矩形的高度为*y2* - *y1* ，矩形的宽度是*x2* - *x1*。 矩形的宽度和高度必须大于2个单位且小于32767个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>CDC：： RectVisible

确定给定矩形的任何部分是否位于显示上下文的剪辑区域内。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
指向 `RECT` 结构或包含指定矩形的逻辑坐标的 `CRect` 对象。

### <a name="return-value"></a>返回值

如果给定矩形的任何部分位于剪辑区域内，则为非零值;否则为0。

##  <a name="releaseattribdc"></a>CDC：： ReleaseAttribDC

调用此成员函数以将 `m_hAttribDC` 设置为 NULL。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>备注

这不会导致 `Detach`。 仅输出设备上下文附加到 `CDC` 的对象，并且只有它可以分离。

##  <a name="releaseoutputdc"></a>CDC：： ReleaseOutputDC

调用此成员函数以将 `m_hDC` 成员设置为 NULL。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>备注

当输出设备上下文附加到 `CDC` 对象时，无法调用此成员函数。 使用 `Detach` 成员函数分离输出设备上下文。

##  <a name="resetdc"></a>CDC：： ResetDC

调用此成员函数以更新由 `CDC` 对象包装的设备上下文。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>parameters

*lpDevMode*<br/>
指向 Windows `DEVMODE` 结构的指针。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文根据 Windows `DEVMODE` 结构中指定的信息进行更新。 此成员函数仅重置属性设备上下文。

当窗口处理 `WM_DEVMODECHANGE` 消息时，应用程序通常会使用 `ResetDC` 成员函数。 在打印文档时，还可以使用此成员函数更改纸张方向或纸张箱。

不能使用此成员函数更改驱动程序名称、设备名称或输出端口。 当用户更改端口连接或设备名称时，必须删除原始设备上下文，并使用新信息创建新的设备上下文。

在调用此成员函数之前，必须确保已在设备上下文中选择的所有对象（除了股票对象）已被选定。

##  <a name="restoredc"></a>CDC：： RestoreDC

将设备上下文还原到由*nSavedDC*标识的以前的状态。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>parameters

*nSavedDC*<br/>
指定要还原的设备上下文。 它可以是上一个 `SaveDC` 函数调用返回的值。 如果*nSavedDC*为-1，则将还原最近保存的设备上下文。

### <a name="return-value"></a>返回值

如果已还原指定的上下文，则为非零值;否则为0。

### <a name="remarks"></a>备注

`RestoreDC` 通过从以前对 `SaveDC` 成员函数的调用创建的堆栈中弹出状态信息来还原设备上下文。

堆栈可包含多个设备上下文的状态信息。 如果*nSavedDC*指定的上下文不在堆栈顶部，`RestoreDC` 会删除*nSavedDC*指定的设备上下文与堆栈顶部之间的所有状态信息。 删除的信息将丢失。

##  <a name="roundrect"></a>CDC：： RoundRect

使用当前笔绘制带有圆角的矩形。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>parameters

*x1*<br/>
指定矩形左上角的 x 坐标（以逻辑单位表示）。

*y1*<br/>
指定矩形左上角的 y 坐标（以逻辑单位表示）。

*x2*<br/>
指定矩形右下角的 x 坐标（以逻辑单位表示）。

*y2*<br/>
指定矩形右下角的 y 坐标（以逻辑单位表示）。

*x3*<br/>
指定用于绘制圆角的椭圆的宽度（以逻辑单位表示）。

*y3*<br/>
指定用于绘制圆角的椭圆的高度（以逻辑单位表示）。

*lpRect*<br/>
指定逻辑单元中的边框。 可以向此参数传递 `CRect` 对象或指向 `RECT` 结构的指针。

*情况*<br/>
*点*的 x 坐标指定用来绘制圆角的椭圆的宽度（以逻辑单位表示）。 *Point*的 y 坐标指定用来绘制圆角的椭圆的高度（以逻辑单位表示）。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

使用当前画笔填充矩形的内部。

此函数绘制的图形延伸到，但不包括右坐标和下坐标。 这意味着，图形的高度为*y2* - *y1* ，而该图形的宽度是*x2* - *x1*。 边框的高度和宽度必须大于2个单位且小于32767个单位。

### <a name="example"></a>示例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>CDC：： SaveDC

通过将状态信息（如剪辑区域、选定对象和映射模式）复制到 Windows 维护的上下文堆栈，保存设备上下文的当前状态。

```
virtual int SaveDC();
```

### <a name="return-value"></a>返回值

一个整数，用于标识保存的设备上下文。 如果发生错误，则为0。 此返回值可用于通过调用 `RestoreDC`来还原设备上下文。

### <a name="remarks"></a>备注

稍后可以使用 `RestoreDC`还原已保存的设备上下文。

`SaveDC` 可以任意多次使用来保存任意数量的设备上下文状态。

##  <a name="scaleviewportext"></a>CDC：： ScaleViewportExt

相对于当前值修改视区区区。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>parameters

*xNum*<br/>
指定当前 x 范围的相乘量。

*xDenom*<br/>
指定将当前 x 范围与*xNum*参数的值相乘所得的结果量。

*yNum*<br/>
指定当前的 y 范围要相乘的量。

*yDenom*<br/>
指定将当前 y 范围与*yNum*参数的值相乘所得的结果量。

### <a name="return-value"></a>返回值

上一个视区区区区（以设备单位）为 `CSize` 对象。

### <a name="remarks"></a>备注

公式按如下方式编写：

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

通过将当前区与给定的分子相乘，然后除以给定的分母，来计算新的视区区区数。

##  <a name="scalewindowext"></a>CDC：： ScaleWindowExt

修改相对于当前值的窗口区区。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>parameters

*xNum*<br/>
指定当前 x 范围的相乘量。

*xDenom*<br/>
指定将当前 x 范围与*xNum*参数的值相乘所得的结果量。

*yNum*<br/>
指定当前的 y 范围要相乘的量。

*yDenom*<br/>
指定将当前 y 范围与*yNum*参数的值相乘所得的结果量。

### <a name="return-value"></a>返回值

前面的窗口区（以逻辑单位）为 `CSize` 对象。

### <a name="remarks"></a>备注

公式按如下方式编写：

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

通过将当前区与给定的分子相乘，然后除以给定的分母来计算新的窗口范围。

##  <a name="scrolldc"></a>CDC：： ScrollDC

水平和垂直滚动位矩形。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>parameters

*dx*<br/>
指定水平滚动单元的数目。

*dy*<br/>
指定垂直滚动单元的数目。

*lpRectScroll*<br/>
指向 `RECT` 结构或包含滚动矩形坐标的 `CRect` 对象。

*lpRectClip*<br/>
指向 `RECT` 结构或包含剪辑矩形坐标的 `CRect` 对象。 如果此矩形小于*lpRectScroll*所指向的原始矩形，则只会在较小的矩形中滚动。

*pRgnUpdate*<br/>
标识滚动过程所发现的区域。 `ScrollDC` 函数定义此区域;它不一定是矩形。

*lpRectUpdate*<br/>
指向 `RECT` 结构或 `CRect` 对象，该对象接收限定滚动更新区域的矩形的坐标。 这是需要重新绘制的最大矩形区域。 当函数返回时，结构或对象中的值将处于工作区坐标中，而不考虑给定设备上下文的映射模式。

### <a name="return-value"></a>返回值

如果执行滚动，则为非零值;否则为0。

### <a name="remarks"></a>备注

如果*lpRectUpdate*为 NULL，则 Windows 不会计算更新矩形。 如果*pRgnUpdate*和*LPRECTUPDATE*都为 NULL，则 Windows 不会计算更新区域。 如果*pRgnUpdate*不为 NULL，则 Windows 将假定其包含滚动过程（由 `ScrollDC` 成员函数定义）所发现的区域的有效指针。 如果需要，可以将*lpRectUpdate*中返回的更新区域传递到 `CWnd::InvalidateRgn`。

当需要滚动窗口的整个工作区时，应用程序应使用 `CWnd` 类的 `ScrollWindow` 成员函数。 否则，应使用 `ScrollDC`。

##  <a name="selectclippath"></a>CDC：： SelectClipPath

选择当前路径作为设备上下文的剪辑区域，使用指定的模式将新的区域与任何现有的剪辑区域相结合。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>parameters

*nMode*<br/>
指定使用路径的方式。 允许以下值：

- RGN_AND 新的剪辑区域包含当前剪辑区域和当前路径的交集（重叠区域）。

- RGN_COPY 新的剪辑区域为当前路径。

- RGN_DIFF 新的剪辑区域包含当前剪辑区域的区域，并且排除当前路径中的区域。

- RGN_OR 新的剪辑区域包含当前剪辑区域和当前路径的联合（组合区域）。

- RGN_XOR 新的剪辑区域包括当前剪辑区域和当前路径的联合，但没有重叠区域。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

标识的设备上下文必须包含关闭的路径。

##  <a name="selectcliprgn"></a>CDC：： SelectClipRgn

选择给定区域作为设备上下文的当前剪辑区域。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>parameters

*pRgn*<br/>
标识要选择的区域。

- 对于此函数的第一个版本，如果此值为 NULL，则会选择整个工作区，并且仍会将输出剪切到窗口中。

- 对于此函数的第二个版本，只有在指定了 RGN_COPY 模式时，此句柄才能为 NULL。

*nMode*<br/>
指定要执行的操作。 它必须是下列值之一：

- RGN_AND 新的剪辑区域合并了当前剪辑区域和由*pRgn*标识的区域的重叠区域。

- RGN_COPY 新的剪辑区域是*pRgn*标识的区域的副本。 此功能与 `SelectClipRgn`的第一个版本是相同的。 如果由*pRgn*标识的区域为 NULL，则新的剪辑区域将成为默认剪辑区域（NULL 区域）。

- RGN_DIFF 新的剪辑区域将当前剪辑区域中的区域与从*pRgn*标识的区域中排除的区域合并在一起。

- RGN_OR 新的剪辑区域合并了当前剪辑区域和由*pRgn*标识的区域。

- RGN_XOR 新的剪辑区域合并了当前剪辑区域和由*pRgn*标识的区域，但不包括任何重叠区域。

### <a name="return-value"></a>返回值

区域的类型。 可以是以下任一值：

- COMPLEXREGION 新的剪辑区域的边框重叠。

- 错误设备上下文或区域无效。

- NULLREGION 新的剪辑区域为空。

- SIMPLEREGION 新的剪辑区域没有重叠的边框。

### <a name="remarks"></a>备注

仅使用所选区域的副本。 可以为任意数量的其他设备上下文选择区域本身，也可以将其删除。

函数假定给定区域的坐标是在设备单位中指定的。 某些打印机设备支持比图形输出更高的分辨率文本输出，以保留表达文本指标所需的精度。 这些设备以较高的分辨率（即文本单位）报告设备单位。 然后，这些设备将调整图形的坐标，使多个报告的设备单位仅映射到1个图形单元。 应始终使用文本单位调用 `SelectClipRgn` 函数。

必须对 GDI 中的图形对象进行缩放的应用程序才能使用 GETSCALINGFACTOR 打印机 escape 来确定缩放系数。 此缩放因子会影响剪裁。 如果使用区域来剪裁图形，则 GDI 会将坐标除以缩放系数。 如果使用区域来剪裁文本，则 GDI 不进行缩放调整。 缩放系数1会使坐标除以 2;缩放系数2将使坐标除以 4;依此类推。

##  <a name="selectobject"></a>CDC：： SelectObject

在设备上下文中选择一个对象。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>parameters

*pPen*<br/>
指向要选择的[CPen](../../mfc/reference/cpen-class.md)对象的指针。

*pBrush*<br/>
指向要选择的[CBrush](../../mfc/reference/cbrush-class.md)对象的指针。

*pFont*<br/>
指向要选择的[CFont](../../mfc/reference/cfont-class.md)对象的指针。

*pBitmap*<br/>
指向要选择的[CBitmap](../../mfc/reference/cbitmap-class.md)对象的指针。

*pRgn*<br/>
指向要选择的[CRgn](../../mfc/reference/crgn-class.md)对象的指针。

*pObject*<br/>
指向要选择的[CGdiObject](../../mfc/reference/cgdiobject-class.md)对象的指针。

### <a name="return-value"></a>返回值

指向要替换的对象的指针。 这是一个指针，指向从 `CGdiObject`派生的某个类的对象，例如 `CPen`，具体取决于所使用的函数的版本。 如果出现错误，则返回值为 NULL。 此函数可能返回指向临时对象的指针。 此临时对象只在处理一条 Windows 消息期间有效。 有关详细信息，请参阅 `CGdiObject::FromHandle`。

采用 region 参数的成员函数版本与 `SelectClipRgn` 成员函数执行相同的任务。 其返回值可以是下列任意值：

- COMPLEXREGION 新的剪辑区域的边框重叠。

- 错误设备上下文或区域无效。

- NULLREGION 新的剪辑区域为空。

- SIMPLEREGION 新的剪辑区域没有重叠的边框。

### <a name="remarks"></a>备注

类 `CDC` 为特定类型的 GDI 对象（包括笔、画笔、字体、位图和区域）提供了五个专用版本。 新选定的对象将替换相同类型的上一个对象。 例如，如果 `SelectObject` 的通用版本的*pObject*指向[CPen](../../mfc/reference/cpen-class.md)对象，则该函数会将当前笔替换为*pObject*指定的笔。

应用程序一次只能选择一个位图到内存设备上下文中，而只选择一个内存设备上下文。 位图的格式必须是单色或与设备上下文兼容;否则，`SelectObject` 将返回错误。

对于 Windows 3.1 和更高版本，无论是否在图元文件中使用，`SelectObject` 函数都返回相同的值。 在以前版本的 Windows 中，`SelectObject` 返回一个成功的非零值，如果在图元文件中使用，则返回0。

##  <a name="selectpalette"></a>CDC：： SelectPalette

选择*pPalette*指定的逻辑调色板作为设备上下文的选定调色板对象。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>parameters

*pPalette*<br/>
标识要选择的逻辑调色板。 此调色板必须已使用 `CPalette` 成员函数[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)创建。

*bForceBackground*<br/>
指定是否强制将逻辑调色板作为背景调色板。 如果*bForceBackground*为非零，则所选调色板始终为背景调色板，无论窗口是否具有输入焦点。 如果*bForceBackground*为0，并且设备上下文附加到窗口，则当窗口具有输入焦点时，逻辑调色板是前台调色板。

### <a name="return-value"></a>返回值

指向 `CPalette` 对象的指针，该对象标识逻辑调色板替换为*pPalette*指定的调色板。 如果出现错误，则为 NULL。

### <a name="remarks"></a>备注

新调色板将成为 GDI 所使用的调色板对象，以控制设备上下文中显示的颜色并替换之前的调色板。

应用程序可以选择一个逻辑调色板到多个设备上下文。 但是，对逻辑调色板的更改将影响为其选择的所有设备上下文。 如果应用程序在多个设备上下文中选择了一个调色板，则设备上下文必须都属于同一个物理设备。

##  <a name="selectstockobject"></a>CDC：： SelectStockObject

选择一个[CGdiObject](../../mfc/reference/cgdiobject-class.md)对象，该对象对应于其中一个预定义的股票笔、画笔或字体。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>parameters

*nIndex*<br/>
指定所需的 stock 对象的类型。 可以为下列值之一：

- BLACK_BRUSH 黑色画笔。

- DKGRAY_BRUSH 深灰色画笔。

- GRAY_BRUSH 灰色画笔。

- HOLLOW_BRUSH 空心画笔。

- LTGRAY_BRUSH 浅灰色画笔。

- NULL_BRUSH Null 画笔。

- WHITE_BRUSH 白色画笔。

- BLACK_PEN 黑色笔。

- Null 笔 NULL_PEN。

- WHITE_PEN 白一笔。

- ANSI_FIXED_FONT ANSI 固定系统字体。

- ANSI_VAR_FONT ANSI 可变系统字体。

- 与设备相关的 DEVICE_DEFAULT_FONT 字体。

- OEM_FIXED_FONT OEM 相关的固定字体。

- SYSTEM_FONT 系统字体。 默认情况下，Windows 使用系统字体来绘制菜单、对话框控件和其他文本。 不过，最好不要依靠 SYSTEM_FONT 获取对话框和窗口使用的字体。 相反，请将 `SystemParametersInfo` 函数与 SPI_GETNONCLIENTMETRICS 参数一起使用以检索当前字体。 `SystemParametersInfo` 将考虑当前主题，并为标题、菜单和消息对话框提供字体信息。

- SYSTEM_FIXED_FONT Windows 版本3.0 之前使用的固定宽度系统字体。 此对象可与早期版本的 Windows 兼容。

- DEFAULT_PALETTE 默认调色板。 此调色板包含系统调色板中的20个静态颜色。

### <a name="return-value"></a>返回值

一个指针，指向在函数成功时被替换的 `CGdiObject` 对象。 指向的实际对象是[CPen](../../mfc/reference/cpen-class.md)、 [CBrush](../../mfc/reference/cbrush-class.md)或[CFont](../../mfc/reference/cfont-class.md)对象。 如果调用失败，则返回值为 NULL。

##  <a name="setabortproc"></a>CDC：： SetAbortProc

为打印作业安装中止过程。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>parameters

*lpfn*<br/>
指向要作为中止过程安装的 abort 函数的指针。 有关回调函数的详细信息，请参阅[CDC：： SetAbortProc 的回调函数](callback-functions-used-by-mfc.md#setabortproc)。

### <a name="return-value"></a>返回值

指定 `SetAbortProc` 函数的结果。 下面的某些值比其他值更有可能。

- SP_ERROR 常规错误。

- SP_OUTOFDISK 没有足够的磁盘空间可用于后台处理，且没有更多的可用空间。

- SP_OUTOFMEMORY 没有足够的内存可用于后台处理。

- SP_USERABORT 用户通过打印管理器结束了作业。

### <a name="remarks"></a>备注

如果应用程序允许在后台处理过程中取消打印作业，则必须在使用[StartDoc](#startdoc)成员函数启动打印作业之前设置 abort 函数。 打印管理器在后台处理期间调用 abort 函数以允许应用程序取消打印作业或处理磁盘空间不足的情况。 如果未设置任何中止函数，则在没有足够的磁盘空间用于后台处理时，打印作业将失败。

请注意，Microsoft 视觉对象C++的功能简化了传递到 `SetAbortProc`的回调函数的创建。 传递给 `EnumObjects` 成员函数的地址是一个指针，指向使用 `__declspec(dllexport)` 和 `__stdcall` 调用约定导出的函数。

你还不必在应用程序的模块定义文件的**导出**语句中导出函数名称。 可以改用**导出**函数修饰符，如下所示

**BOOL 回调导出**AFunction （ **HDC**，`int` **）;**

如果为，则导致编译器发出适当的导出记录以便按名称导出，而无需使用别名。 这适用于大多数需求。 对于某些特殊情况，如按序号导出函数或为导出提供别名时，仍需要在模块定义文件中使用**导出**语句。

回调注册接口现在是类型安全的（必须传入一个函数指针，该指针指向特定回调的正确函数类型）。

另请注意，在返回 Windows 之前，所有回调函数都必须捕获 Microsoft Foundation 异常，因为异常不能跨回调边界引发。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。

##  <a name="setarcdirection"></a>CDC：： SetArcDirection

设置要用于弧线和矩形函数的绘制方向。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>parameters

*nArcDirection*<br/>
指定新的弧线方向。 此参数可以是下列值之一：

- 逆时针绘制的 AD_COUNTERCLOCKWISE 数字。

- 顺时针绘制的 AD_CLOCKWISE 图。

### <a name="return-value"></a>返回值

如果成功，则指定旧的弧线方向;否则为0。

### <a name="remarks"></a>备注

默认方向是逆时针。 `SetArcDirection` 函数指定以下函数的绘制方向：

|Arc|饼图|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>CDC：： SetAttribDC

调用此函数可设置特性设备上下文，`m_hAttribDC`。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>parameters

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

此成员函数不会将设备上下文附加到 `CDC` 的对象。 仅输出设备上下文附加到 `CDC` 对象。

##  <a name="setbkcolor"></a>CDC：： SetBkColor

将当前背景色设置为指定颜色。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>parameters

*crColor*<br/>
指定新的背景色。

### <a name="return-value"></a>返回值

作为 RGB 颜色值的上一背景色。 如果发生错误，则返回值为0x80000000。

### <a name="remarks"></a>备注

如果背景模式不透明，系统将使用背景色填充样式线中的间隙、画笔中阴影线之间的间隔以及字符单元中的背景。 在颜色和单色设备上下文之间转换位图时，系统还使用背景色。

如果设备无法显示指定的颜色，系统会将背景色设置为最接近的物理颜色。

##  <a name="setbkmode"></a>CDC：： SetBkMode

设置后台模式。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>parameters

*nBkMode*<br/>
指定要设置的模式。 此参数可以是下列值之一：

- 在绘制文本、阴影画笔或笔之前，不透明背景将用当前背景色填充。 这是默认的后台模式。

- 透明背景在绘制之前不会更改。

### <a name="return-value"></a>返回值

上一后台模式。

### <a name="remarks"></a>备注

背景模式定义系统是否在绘制文本、阴影画笔或不是实线的任何笔样式之前删除绘图图面上的现有背景色。

### <a name="example"></a>示例

  请参阅[CWnd：： OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)的示例。

##  <a name="setboundsrect"></a>CDC：： SetBoundsRect

控制指定设备上下文的边界矩形信息的累计。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>parameters

*lpRectBounds*<br/>
指向 `RECT` 结构或用于设置边框的 `CRect` 对象。 在逻辑坐标中给出了矩形尺寸。 此参数可以为 NULL。

*flag*<br/>
指定新矩形将如何与累计矩形组合。 此参数可以是下列值的组合：

- DCB_ACCUMULATE 将*lpRectBounds*指定的矩形添加到边框（使用矩形 union 运算）。

- DCB_DISABLE 关闭边界堆积。

- DCB_ENABLE 开启边界累积。 （边界累积的默认设置为 "已禁用"。）

### <a name="return-value"></a>返回值

如果函数成功，则为边框的当前状态。 与*标志*一样，返回值可以是**DCB_** 值的组合：

- DCB_ACCUMULATE 边框不为空。 此值将始终设置。

- DCB_DISABLE 界限累积为 off。

- DCB_ENABLE 界限累积为 on。

### <a name="remarks"></a>备注

Windows 可以为所有绘图操作维护一个边框。 应用程序可以查询和重置此矩形。 绘图边界对使位图缓存失效的情况非常有用。

##  <a name="setbrushorg"></a>CDC：： SetBrushOrg

指定 GDI 将分配给应用程序在设备上下文中选择的下一个画笔的原点。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定新原点的 x 坐标（以设备单位为单位）。 此值必须在0-7 的范围内。

*y*<br/>
指定新原点的 y 坐标（以设备单位为单位）。 此值必须在0-7 的范围内。

*情况*<br/>
指定新原点的 x 坐标和 y 坐标。 每个值都必须在0-7 范围内。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

画笔的上一个原点（以设备单位为单位）。

### <a name="remarks"></a>备注

画笔原点的默认坐标为（0，0）。 若要更改画笔的原点，请调用 `CBrush` 对象的 `UnrealizeObject` 函数，调用 `SetBrushOrg`，然后调用 `SelectObject` 成员函数以便在设备上下文中选择画笔。

不要将 `SetBrushOrg` 与 stock `CBrush` 对象一起使用。

##  <a name="setcoloradjustment"></a>CDC：： SetColorAdjustment

使用指定的值设置设备上下文的颜色调整值。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>parameters

*lpColorAdjust*<br/>
指向包含颜色调整值的[COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)数据结构。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

颜色调整值用于调整设置半色调模式时调用 `CDC::StretchBlt` 成员函数的源位图的输入颜色。

##  <a name="setdcbrushcolor"></a>CDC：： SetDCBrushColor

将当前设备上下文（DC）画笔颜色设置为指定的颜色值。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>parameters

*crColor*<br/>
指定新的画笔颜色。

### <a name="return-value"></a>返回值

如果该函数成功，则返回值将上一个 DC 画笔颜色指定为 COLORREF 值。

如果函数失败，则返回值为 CLR_INVALID。

### <a name="remarks"></a>备注

此方法模拟函数[SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor)的功能，如 Windows SDK 中所述。

##  <a name="setdcpencolor"></a>CDC：： SetDCPenColor

将当前设备上下文（DC）笔颜色设置为指定的颜色值。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>parameters

*crColor*<br/>
指定新的笔颜色。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

此成员函数使用 Win32 函数[SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)，如 Windows SDK 中所述。

##  <a name="setgraphicsmode"></a>CDC：： SetGraphicsMode

为指定的设备上下文设置图形模式。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>parameters

*iMode*<br/>
指定图形模式。 有关此参数可以采用的值的列表，请参阅[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

### <a name="return-value"></a>返回值

如果成功，则返回旧的图形模式。

失败时返回0。 若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

##  <a name="setlayout"></a>CDC：： SetLayout

调用此成员函数可将设备上下文的文本和图形的布局从右到左更改为区域性（如阿拉伯语和希伯来语）的标准布局。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>parameters

*dwLayout*<br/>
设备上下文布局和位图控件标志。 它可以是下列值的组合。

|值|含义|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|对[cdc：： BitBlt](#bitblt)和[Cdc：： StretchBlt](#stretchblt)调用禁用任何反射。|
|LAYOUT_RTL|将默认水平布局设置为从右到左。|
|LAYOUT_LTR|将默认布局设置为从左到右。|

### <a name="return-value"></a>返回值

如果成功，则为先前布局的设备上下文。

如果失败，GDI_ERROR。 若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

通常情况下，不会为窗口调用 `SetLayout`。 而是通过设置[扩展的窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)（如 WS_EX_RTLREADING）来控制窗口中的从右到左布局。 设备上下文（如打印机或图元文件）不会继承此布局。 为从右到左布局设置设备上下文的唯一方法是调用 `SetLayout`。

如果调用**SetLayout （LAYOUT_RTL** ），`SetLayout` 会自动将映射模式改为 MM_ISOTROPIC。 因此，对[GetMapMode](#getmapmode)的后续调用将返回 MM_ISOTROPIC 而不是 MM_TEXT。

在某些情况下，例如，对于许多位图，可能需要保留从左到右的布局。 在这些情况下，通过调用 `BitBlt` 或 `StretchBlt`来呈现图像，然后将*dwLayout*的位图控件标志设置为 "LAYOUT_BITMAPORIENTATIONPRESERVED"。

更改带有 LAYOUT_RTL 标志的布局后，通常会反转指定向右或向左的标志。 为避免混淆，你可能需要为标准标志定义替换名称。 有关建议的备用标志名称的列表，请参阅 Windows SDK 中的[SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) 。

##  <a name="setmapmode"></a>CDC：： SetMapMode

设置映射模式。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>parameters

*nMapMode*<br/>
指定新的映射模式。 它可以是下列值之一：

- MM_ANISOTROPIC 逻辑单元将转换为任意单元，且具有任意规模的轴。 将映射模式设置为 MM_ANISOTROPIC 不会更改当前窗口或视区设置。 若要更改单位、方向和缩放，请调用[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成员函数。

- MM_HIENGLISH 每个逻辑单元均转换为0.001 英寸。 正 x 向右;正 y 向上。

- MM_HIMETRIC 每个逻辑单元均转换为0.01 毫米。 正 x 向右;正 y 向上。

- MM_ISOTROPIC 逻辑单元转换为具有相同缩放轴的任意单位;即，沿 x 轴的1个单位等于沿 y 轴的1个单位。 使用 "`SetWindowExt`" 和 "`SetViewportExt` 成员函数" 指定所需的单位和轴的方向。 GDI 根据需要进行调整，以确保 x 和 y 单位保持相同的大小。

- MM_LOENGLISH 每个逻辑单元均转换为0.01 英寸。 正 x 向右;正 y 向上。

- MM_LOMETRIC 每个逻辑单元均转换为0.1 毫米。 正 x 向右;正 y 向上。

- MM_TEXT 每个逻辑单元均转换为1个设备像素。 正 x 向右;正 y 为关闭状态。

- MM_TWIPS 每个逻辑单元都转换为点的1/20。 （由于点为1/72 英寸，twip 为1/1440 英寸。）正 x 向右;正 y 向上。

### <a name="return-value"></a>返回值

以前的映射模式。

### <a name="remarks"></a>备注

映射模式定义用于将逻辑单元转换为设备单位的度量单位;它还定义设备的 x 轴和 y 轴的方向。 GDI 使用映射模式将逻辑坐标转换为适当的设备坐标。 MM_TEXT 模式允许应用程序以设备像素为单位工作，其中1个单位等于1个像素。 像素的物理大小因设备而异。

"MM_HIENGLISH"、"MM_HIMETRIC"、"MM_LOENGLISH"、"MM_LOMETRIC" 和 "MM_TWIPS" 模式适用于必须以物理意义单位（如英寸或毫米）绘制的应用程序。 MM_ISOTROPIC 模式确保了1:1 纵横比，这在保持图像的准确形状非常重要时非常有用。 MM_ANISOTROPIC 模式允许单独调整 x 和 y 坐标。

> [!NOTE]
>  如果调用[SetLayout](#setlayout)将 DC （设备上下文）更改为从右到左布局，`SetLayout` 会自动将映射模式更改为 MM_ISOTROPIC。

### <a name="example"></a>示例

  请参阅[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的示例。

##  <a name="setmapperflags"></a>CDC：： SetMapperFlags

更改字体映射器在将逻辑字体转换为物理字体时使用的方法。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>parameters

*dwFlag*<br/>
指定字体映射器是否尝试将字体的高度和宽度与设备匹配。 ASPECT_FILTERING 此值时，映射器将仅选择其 x 高宽比与指定设备的 y 高宽比完全匹配的字体。

### <a name="return-value"></a>返回值

字体映射器标志的上一个值。

### <a name="remarks"></a>备注

应用程序可以使用 `SetMapperFlags` 使字体映射器尝试仅选择与指定设备的纵横比完全匹配的物理字体。

仅使用光栅字体的应用程序可以使用 `SetMapperFlags` 函数，以确保字体映射器所选的字体在指定的设备上有吸引力且可读。 使用可缩放（TrueType）字体的应用程序通常不使用 `SetMapperFlags`。

如果任何物理字体都没有与逻辑字体中的规范匹配的纵横比，则 GDI 将选择新的纵横比，并选择与此新纵横比匹配的字体。

##  <a name="setmiterlimit"></a>CDC：： SetMiterLimit

设置设备上下文的斜切联接长度的限制。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>parameters

*fMiterLimit*<br/>
指定设备上下文的新斜接限制。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

斜接长度定义为从联接内的线条壁的交点到联接外的线条壁的交点的距离。 斜接限制是斜接长度与线条宽度之间允许的最大值。 默认的斜接限制为10.0。

##  <a name="setoutputdc"></a>CDC：： SetOutputDC

调用此成员函数可设置输出设备上下文，`m_hDC`。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>parameters

*hDC*<br/>
Windows 设备上下文。

### <a name="remarks"></a>备注

仅当尚未将设备上下文附加到 `CDC` 对象时，才能调用此成员函数。 此成员函数将 `m_hDC` 设置，但不会将设备上下文附加到 `CDC` 对象。

##  <a name="setpixel"></a>CDC：： SetPixel

将指定点处的像素设置为*crColor*指定的最接近的颜色。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定要设置的点的逻辑 x 坐标。

*y*<br/>
指定要设置的点的逻辑 y 坐标。

*crColor*<br/>
COLORREF RGB 值，指定用于绘制点的颜色。 有关此值的说明，请参阅 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

*情况*<br/>
指定要设置的点的逻辑 x 和 y 坐标。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

实际绘制点的颜色的 RGB 值。 如果使用该颜色的近似值，此值可以与*crColor*指定的值不同。 如果函数失败（如果点在剪辑区域外），则返回值为-1。

### <a name="remarks"></a>备注

点必须位于剪辑区域中。 如果该点不在剪辑区域中，则该函数不执行任何操作。

不是所有的设备都支持 `SetPixel` 函数。 若要确定设备是否支持 `SetPixel`，请使用 RASTERCAPS 索引调用 `GetDeviceCaps` 成员函数并检查 RC_BITBLT 标志的返回值。

##  <a name="setpixelv"></a>CDC：： SetPixelV

将指定坐标处的像素设置为指定颜色最近的近似值。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>parameters

*x*<br/>
以逻辑单位指定要设置的点的 x 坐标。

*y*<br/>
指定要设置的点的 y 坐标（以逻辑单位表示）。

*crColor*<br/>
指定用于绘制点的颜色。

*情况*<br/>
指定要设置的点的逻辑 x 和 y 坐标。 可以为此参数传递[POINT](/windows/win32/api/windef/ns-windef-point)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

点必须位于剪辑区域和设备图面的可见部分中。 并非所有设备都支持成员函数。 有关详细信息，请参阅 `CDC::GetDeviceCaps` 成员函数中的 RC_BITBLT 功能。 `SetPixelV` 比 `SetPixel` 快，因为它不需要返回实际绘制的点的颜色值。

##  <a name="setpolyfillmode"></a>CDC：： SetPolyFillMode

设置多边形填充模式。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>parameters

*nPolyFillMode*<br/>
指定新的填充模式。 此值可以是 "替换" 或 "缠绕"。 Windows 中设置的默认模式是 "备用"。

### <a name="return-value"></a>返回值

如果成功，则为上一填充模式;否则为0。

### <a name="remarks"></a>备注

当多边形填充模式为备用模式时，系统将在每个扫描行上填充奇数个和偶数个多边形边之间的区域。 也就是说，系统在第三方和第四方之间填充区域，依此类推。 此模式是默认模式。

当缠绕多边形填充模式时，系统将使用绘制图形的方向来确定是否填充区域。 多边形中的每个线段以顺时针方向或逆时针方向绘制。 每当从封闭区域绘制到图形外的虚线通过顺时针直线段时，计数就会增加。 当直线经过逆时针线段时，计数将减少。 如果行到达图形外，则会填充该区域。

##  <a name="setrop2"></a>CDC：： SetROP2

设置当前的绘制模式。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>parameters

*nDrawMode*<br/>
指定新的绘制模式。 可以是以下任一值：

- R2_BLACK 像素始终为黑色。

- R2_WHITE 像素始终为白色。

- R2_NOP 像素保持不变。

- R2_NOT 像素是屏幕颜色的反转。

- R2_COPYPEN 像素是笔颜色。

- R2_NOTCOPYPEN 像素是笔颜色的反转。

- R2_MERGEPENNOT 像素是笔颜色和屏幕颜色（最后一个像素 = （不是屏幕像素）或笔）的反转的组合。

- R2_MASKPENNOT 像素是笔和屏幕反转（最终像素 = （不是屏幕像素）和笔）共有的颜色的组合。

- R2_MERGENOTPEN 像素是屏幕颜色和画笔颜色（最终像素 = （不是笔）或屏幕像素）的组合。

- R2_MASKNOTPEN 像素是屏幕和笔反转（最后一个像素 = （不是笔）和屏幕像素）共有的颜色的组合。

- R2_MERGEPEN 像素是笔颜色和屏幕颜色（最终像素 = 笔或屏幕像素）的组合。

- R2_NOTMERGEPEN 像素是 R2_MERGEPEN 颜色（最后一个像素 = 不是（笔或屏幕像素））的反转。

- R2_MASKPEN 像素是笔和屏幕共有的颜色（最终像素 = 笔和屏幕像素）的组合。

- R2_NOTMASKPEN 像素是 R2_MASKPEN 颜色（最后一个像素 = 非（笔和屏幕像素））的反转。

- R2_XORPEN 像素是笔或屏幕中的颜色的组合，但不在两者（最后一个像素 = 笔 XOR 屏幕像素）中。

- R2_NOTXORPEN 像素是 R2_XORPEN 颜色（最后一个像素 = 非（笔 XOR 屏幕像素））的反转。

### <a name="return-value"></a>返回值

先前的绘制模式。

它可以是 Windows SDK 中给定的任何值。

### <a name="remarks"></a>备注

绘制模式指定笔颜色和填充对象的内部如何与显示表面上已有的颜色组合。

绘图模式仅适用于光栅设备;它不适用于向量设备。 绘制模式是二进制光栅操作代码，表示两个变量的所有可能的布尔组合，使用二元运算符 AND、OR 和 XOR （异或），而一元运算则不是。

##  <a name="setstretchbltmode"></a>CDC：： SetStretchBltMode

为 `StretchBlt` 成员函数设置位图拉伸模式。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>parameters

*nStretchMode*<br/>
指定拉伸模式。 可以是以下任一值：

|值|说明|
|-----------|-----------------|
|BLACKONWHITE|使用消除和现有像素的颜色值执行布尔和运算。 如果位图是单色位图，此模式将以白色像素为代价保留黑色像素。|
|COLORONCOLOR|删除像素。 此模式删除所有消除的像素行，而不会尝试保留其信息。|
|色|将源矩形中的像素映射到目标矩形中的像素块。 目标像素块上的平均颜色约为源像素的颜色。|
||设置半色调拉伸模式后，应用程序必须调用 Win32 函数[SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex)来设置画笔原点。 如果无法执行此操作，则会发生画笔未对齐。|
|STRETCH_ANDSCANS|**Windows 95/98**：与 BLACKONWHITE 相同|
|STRETCH_DELETESCANS|**Windows 95/98**：与 COLORONCOLOR 相同|
|STRETCH_HALFTONE|**Windows 95/98**：与半色调相同。|
|STRETCH_ORSCANS|**Windows 95/98**：与 WHITEONBLACK 相同|
|WHITEONBLACK|使用已消除像素和现有像素的颜色值执行布尔或运算。 如果位图是单色位图，此模式将以黑色像素为代价保留白色像素。|

### <a name="return-value"></a>返回值

以前的拉伸模式。 它可以是 STRETCH_ANDSCANS、STRETCH_DELETESCANS 或 STRETCH_ORSCANS。

### <a name="remarks"></a>备注

位图拉伸模式定义了如何从使用函数压缩的位图中删除信息。

BLACKONWHITE （STRETCH_ANDSCANS）和 WHITEONBLACK （STRETCH_ORSCANS）模式通常用于在单色位图中保留前景像素。 COLORONCOLOR （STRETCH_DELETESCANS）模式通常用于保留颜色位图中的颜色。

半色调模式比其他三种模式需要更多的源映像处理;它比其他设备慢，但会生成更高质量的图像。 另请注意，在设置半色调模式后，必须调用 `SetBrushOrgEx`，以避免画笔未对齐。

其他拉伸模式也可能可用，具体取决于设备驱动程序的功能。

##  <a name="settextalign"></a>CDC：： SetTextAlign

设置文本对齐标志。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>parameters

*nFlags*<br/>
指定文本对齐标志。 标志指定用于限定文本的点和矩形之间的关系。 点可以是当前位置，也可以是文本输出函数指定的坐标。 限定文本的矩形由文本字符串中的相邻字符单元格定义。 *NFlags*参数可以是以下三个类别中的一个或多个标志。 仅从每个类别中选择一个标志。 第一种类别影响 x 方向中的文本对齐方式：

- TA_CENTER 将点与边框的水平中心对齐。

- TA_LEFT 将点与边框的左边对齐。 这是默认设置。

- TA_RIGHT 将点与边框的右侧对齐。

第二个类别影响 y 方向的文本对齐方式：

- TA_BASELINE 将该点与所选字体的基准线对齐。

- TA_BOTTOM 将点与边框的底部对齐。

- TA_TOP 将点与边框的顶部对齐。 这是默认设置。

第三个类别确定在写入文本时是否更新当前位置：

- TA_NOUPDATECP 不会在每次调用文本输出函数后更新当前位置。 这是默认设置。

- TA_UPDATECP 更新每次调用文本输出函数后的当前 x 位置。 新位置位于文本边界矩形的右边。 设置此标志时，将忽略在对 `TextOut` 成员函数的调用中指定的坐标。

### <a name="return-value"></a>返回值

如果成功，则为以前的文本对齐设置。 低序位字节包含水平设置，高序位字节包含垂直设置;否则为0。

### <a name="remarks"></a>备注

当在显示或设备上定位文本字符串时，`TextOut` 和 `ExtTextOut` 成员函数将使用这些标志。 标志指定特定点和限定文本的矩形之间的关系。 此点的坐标作为参数传递给 `TextOut` 成员函数。 限定文本的矩形由文本字符串中的相邻字符单元格构成。

##  <a name="settextcharacterextra"></a>CDC：： SetTextCharacterExtra

设置 intercharacter 间距量。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>parameters

*nCharExtra*<br/>
指定要添加到每个字符的额外空间量（以逻辑单位为单位）。 如果未 `MM_TEXT`当前映射模式，则将转换*nCharExtra*并将其舍入到最接近的像素。

### <a name="return-value"></a>返回值

上一个 intercharacter 间距的量。

### <a name="remarks"></a>备注

在将一行文本写入设备上下文时，GDI 将此间距添加到每个字符，包括分隔符字符。 Intercharacter 间距的默认值为0。

##  <a name="settextcolor"></a>CDC：： SetTextColor

将文本颜色设置为指定颜色。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>parameters

*crColor*<br/>
指定文本的颜色作为 RGB 颜色值。

### <a name="return-value"></a>返回值

之前文本颜色的 RGB 值。

### <a name="remarks"></a>备注

在将文本写入此设备上下文以及在颜色和单色设备上下文之间转换位图时，系统将使用此文本颜色。

如果设备不能表示指定的颜色，系统会将文本颜色设置为最接近的物理颜色。 字符的背景色由 `SetBkColor` 和 `SetBkMode` 成员函数指定。

### <a name="example"></a>示例

  请参阅[CWnd：： OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)的示例。

##  <a name="settextjustification"></a>CDC：： SetTextJustification

向字符串中的分隔字符添加空格。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>parameters

*nBreakExtra*<br/>
指定要添加到文本行的总额外空间（以逻辑单位为单位）。 如果未 `MM_TEXT`当前映射模式，则此参数指定的值将转换为当前映射模式并舍入到最近的设备单元。

*nBreakCount*<br/>
指定行中的分隔字符数。

### <a name="return-value"></a>返回值

如果函数成功，则为; 否则为。否则为0。

### <a name="remarks"></a>备注

应用程序可以使用 `GetTextMetrics` 成员函数检索字体的分行符。

调用 `SetTextJustification` 成员函数后，对文本输出函数的调用（如 `TextOut`）将在指定的分行字符数之间平均分配指定的额外空间。 换行符通常是空格字符（ASCII 32），但也可以通过字体定义为其他字符。

成员函数 `GetTextExtent` 通常与 `SetTextJustification`一起使用。 `GetTextExtent` 计算在对齐前给定行的宽度。 应用程序可以通过在对齐后从字符串的宽度减去 `GetTextExtent` 返回的值来确定要在*nBreakExtra*参数中指定的空间量。

`SetTextJustification` 函数可用于将包含多个运行的行与不同的字体对齐。 在这种情况下，必须通过分别对齐和书写每个运行来以逐段方式创建行。

因为在对齐期间可能会出现舍入错误，所以系统会保留定义当前错误的运行错误术语。 对齐包含多个运行的行时，在计算下一个运行的范围时，`GetTextExtent` 会自动使用此错误字词。 这允许文本输出函数将错误混合到新的运行中。

对齐每个行后，必须清除此错误词，以防将其合并到下一行。 可以通过调用*nBreakExtra*设置为0的 `SetTextJustification` 来清除该字词。

##  <a name="setviewportext"></a>CDC：： SetViewportExt

设置设备上下文视区的 x 和 y 范围。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>parameters

*cx*<br/>
指定视区的 x 范围（在设备单位中）。

*cy*<br/>
指定视区的 y 范围（在设备单位中）。

size<br/>
指定视区的 x 和 y 范围（在设备单位中）。

### <a name="return-value"></a>返回值

作为[CSize](../../atl-mfc-shared/reference/csize-class.md)对象的视区的以前的范围。 出现错误时，返回的 `CSize` 对象的 x 坐标和 y 坐标都设置为0。

### <a name="remarks"></a>备注

视区和设备上下文窗口一起定义了 GDI 映射在逻辑坐标系中的点如何指向实际设备的坐标系统中的点。 换言之，它们定义了如何将逻辑坐标转换为设备坐标。

设置以下映射模式时，将忽略对 `SetWindowExt` 和 `SetViewportExt` 的调用：

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

设置 MM_ISOTROPIC 模式时，应用程序必须在调用 `SetViewportExt`之前调用 `SetWindowExt` 成员函数。

### <a name="example"></a>示例

  请参阅[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的示例。

##  <a name="setviewportorg"></a>CDC：： SetViewportOrg

设置设备上下文的视区原点。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定视区原点的 x 坐标（以设备单位为单位）。 该值必须在设备坐标系统范围内。

*y*<br/>
指定视区原点的 y 坐标（以设备单位为单位）。 该值必须在设备坐标系统范围内。

*情况*<br/>
指定视区的原点。 值必须在设备坐标系统范围内。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的视区的上一个原点（以设备坐标表示）。

### <a name="remarks"></a>备注

视区和设备上下文窗口一起定义了 GDI 映射在逻辑坐标系中的点如何指向实际设备的坐标系统中的点。 换言之，它们定义了如何将逻辑坐标转换为设备坐标。

视区原点标记设备坐标系统中的点，GDI 将窗口源（由 `SetWindowOrg` 成员函数指定的逻辑坐标系统中的点）映射到该系统。 GDI 按照将窗口原点映射到视区原点所需的相同过程来映射所有其他点。 例如，位于窗口原点附近点附近的所有点都将位于视区原点附近的点。 同样，通过窗口原点的行中的所有点都将位于穿过视区原点的行中。

### <a name="example"></a>示例

  请参阅[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的示例。

##  <a name="setwindowext"></a>CDC：： SetWindowExt

设置与设备上下文关联的窗口的 x 和 y 范围。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>parameters

*cx*<br/>
指定窗口的 x 范围（以逻辑单位为单位）。

*cy*<br/>
指定窗口的 y 范围（以逻辑单位为单位）。

size<br/>
指定窗口的 x 和 y 范围（以逻辑单位为单位）。

### <a name="return-value"></a>返回值

窗口的以前的范围（以逻辑单位为单位），它是一个 `CSize` 对象。 如果发生错误，则返回的 `CSize` 对象的 x 坐标和 y 坐标都设置为0。

### <a name="remarks"></a>备注

该窗口与设备上下文视区一起定义了如何将逻辑坐标系统中的点映射到设备坐标系统中的点。

如果设置了以下映射模式，则将忽略对 `SetWindowExt` 和 `SetViewportExt` 函数的调用：

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

设置 MM_ISOTROPIC 模式时，应用程序必须在调用 `SetViewportExt`之前调用 `SetWindowExt` 成员函数。

### <a name="example"></a>示例

  请参阅[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的示例。

##  <a name="setwindoworg"></a>CDC：： SetWindowOrg

设置设备上下文的窗口源。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定窗口的新原点的逻辑 x 坐标。

*y*<br/>
指定窗口的新原点的逻辑 y 坐标。

*情况*<br/>
指定窗口的新原点的逻辑坐标。 可以为此参数传递 `POINT` 结构或 `CPoint` 对象。

### <a name="return-value"></a>返回值

作为 `CPoint` 对象的窗口的上一页。

### <a name="remarks"></a>备注

该窗口与设备上下文视区一起定义了如何将逻辑坐标系统中的点映射到设备坐标系统中的点。

窗口源在逻辑坐标系中标记 GDI 将视区的位置（由 `SetWindowOrg` 函数指定的设备坐标系统中的一个点）。 GDI 按照将窗口原点映射到视区原点所需的相同过程来映射所有其他点。 例如，位于窗口原点附近点附近的所有点都将位于视区原点附近的点。 同样，通过窗口原点的行中的所有点都将位于穿过视区原点的行中。

##  <a name="setworldtransform"></a>CDC：： SetWorldTransform

为指定的设备上下文设置世界空间和页面空间之间的二维线性转换。 此转换可用于缩放、旋转、切变或转换图形输出。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>parameters

*rXform*<br/>
对包含转换数据的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)结构的引用。

### <a name="return-value"></a>返回值

如果成功，则返回一个非零值。

失败时返回0。

若要获取扩展的错误信息，请调用[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>备注

此方法包装 Windows GDI 函数[SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)。

##  <a name="startdoc"></a>CDC：： StartDoc

通知设备驱动程序，新的打印作业正在启动，并且所有后续 `StartPage` 和 `EndPage` 调用都应在同一作业下进行后台处理，直到发生 `EndDoc` 调用。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>parameters

*lpDocInfo*<br/>
指向一个[DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow)结构，该结构包含文档文件的名称和输出文件的名称。

*lpszDocName*<br/>
指向包含文档文件名称的字符串的指针。

### <a name="return-value"></a>返回值

如果函数成功，则返回值大于零。 此值是文档的打印作业标识符。

如果函数失败，则返回值小于或等于零。

### <a name="remarks"></a>备注

这可确保超过一页的文档不会与其他作业交错。

对于 Windows 版本3.1 及更高版本，此函数取代了 STARTDOC 打印机转义。 使用此函数可确保包含多页的文档不会与其他打印作业交错。

不应在图元文件中使用 `StartDoc`。

### <a name="example"></a>示例

此代码段获取默认打印机，打开打印作业，并使用 "Hello，World！" 。 由于此代码打印的文本未缩放到打印机的逻辑单元，因此输出文本的大小可能是不可读的。 CDC 缩放函数（如 `SetMapMode`、`SetViewportOrg`和 `SetWindowExt`）可用于修复缩放。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>CDC：： StartPage

调用此成员函数以准备要接收数据的打印机驱动程序。

```
int StartPage();
```

### <a name="return-value"></a>返回值

如果函数成功，则大于或等于 0; 如果发生错误，则大于等于0。

### <a name="remarks"></a>备注

`StartPage` 取代了 NEWFRAME 和 BANDINFO 转义。

有关打印调用序列的概述，请参阅[StartDoc](#startdoc)成员函数。

系统在调用 `StartPage` 和 `EndPage`之间禁用 `ResetDC` 成员函数。

### <a name="example"></a>示例

  请参阅[CDC：： StartDoc](#startdoc)的示例。

##  <a name="stretchblt"></a>CDC：： StretchBlt

将位图从源矩形复制到目标矩形，必要时可拉伸或压缩位图以符合目标矩形的尺寸。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定目标矩形左上角的 x 坐标（使用逻辑单位）。

*y*<br/>
指定目标矩形左上角的 y 坐标（使用逻辑单位）。

*nWidth*<br/>
指定目标矩形的宽度（使用逻辑单位）。

*nHeight*<br/>
指定目标矩形的高度（使用逻辑单位）。

*pSrcDC*<br/>
指定源设备上下文。

*xSrc*<br/>
指定源矩形左上角的 x 坐标（使用逻辑单位）。

*ySrc*<br/>
指定源矩形左上角的 y 坐标（使用逻辑单位）。

*nSrcWidth*<br/>
指定源矩形的宽度（使用逻辑单位）。

*nSrcHeight*<br/>
指定源矩形的高度（使用逻辑单位）。

*dwRop*<br/>
指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、可能的源位图和目标位图的输出操作中的颜色。 该参数可能是下列值之一：

- BLACKNESS 会将所有输出变为黑色。

- DSTINVERT 反转目标位图。

- MERGECOPY 使用布尔值和运算符组合模式和源位图。

- MERGEPAINT 使用布尔或运算符将反转的源位图与目标位图组合在一起。

- NOTSRCCOPY 将反转的源位图复制到目标。

- NOTSRCERASE 使用布尔或运算符反转组合目标和源位图的结果。

- PATCOPY 将模式复制到目标位图。

- PATINVERT 使用布尔 XOR 运算符将目标位图与模式组合在一起。

- PATPAINT 使用布尔或运算符将反转的源位图与模式组合在一起。 使用布尔 OR 运算符合并该操作的结果与目标位图。

- SRCAND 使用布尔值和运算符组合目标和源位图的像素。

- SRCCOPY 将源位图复制到目标位图。

- SRCERASE 使用布尔和运算符反转目标位图，并将结果与源位图组合在一起。

- SRCINVERT 使用布尔 XOR 运算符组合目标和源位图的像素。

- SRCPAINT 使用布尔或运算符组合目标和源位图的像素。

- WHITENESS 会打开所有输出白色。

### <a name="return-value"></a>返回值

如果绘制出位图，则为非 0；否则为 0。

### <a name="remarks"></a>备注

该函数使用目标设备上下文的拉伸模式（由 `SetStretchBltMode` 设置）确定如何拉伸或压缩位图。

`StretchBlt` 函数将位图从*pSrcDC*给定的源设备移动到目标设备，该设备上下文对象由其成员函数调用。 *XSrc*、 *ySrc*、 *nSrcWidth*和*nSrcHeight*参数定义了源矩形的左上角和尺寸。 *X*、 *y*、 *nWidth*和*nHeight*参数指定了目标矩形的左上角和尺寸。 *DwRop*指定的光栅操作定义了源位图和目标设备上已经存在的位的组合方式。

如果*nSrcWidth*和*nWidth*或*nSrcHeight*和*nHeight*参数的符号不同，则 `StretchBlt` 函数将创建位图的镜像。 如果*nSrcWidth*和*nWidth*具有不同的符号，则该函数将沿 x 轴创建位图的镜像。 如果*nSrcHeight*和*nHeight*具有不同的符号，则该函数将沿 y 轴创建位图的镜像。

`StretchBlt` 函数将在内存中拉伸或压缩源位图，然后将结果复制到目标。 如果一个模式将与该结果合并，则合并操作会等到拉伸的源位图复制到目标后执行。 如果使用画笔，则为在目标设备上下文中选择的画笔。 目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。

如果目标位图、源位图和模式位图没有相同的颜色格式，`StretchBlt` 将转换源位图和模式位图，以与目标位图匹配。 在转换中将使用目标设备上下文的前景色和背景色。

如果 `StretchBlt` 必须将单色位图转换为彩色，则会将白色位 (1) 设置为背景色，黑色位 (0) 设置为前景色。 若要将彩色位图转换为单色，它会将与背景色匹配的像素设置为白色 (1)，其他所有像素设置为黑色 (0)。 在转换中将使用彩色设备上下文的前景色和背景色。

不是所有的设备都支持 `StretchBlt` 函数。 若要确定设备是否支持 `StretchBlt`，请使用 RASTERCAPS 索引调用 `GetDeviceCaps` 成员函数并检查 RC_STRETCHBLT 标志的返回值。

##  <a name="strokeandfillpath"></a>CDC：： StrokeAndFillPath

关闭路径中的任何打开的图形，使用当前笔对路径轮廓进行描边，并使用当前画笔填充其内部。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含关闭的路径。 `StrokeAndFillPath` 成员函数具有与关闭路径中的所有开放图形相同的效果，并分别对该路径进行描边和填充路径，只不过填充的区域不会与描边区域重叠，即使笔是宽的也是如此。

##  <a name="strokepath"></a>CDC：： StrokePath

使用当前笔呈现指定的路径。

```
BOOL StrokePath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

设备上下文必须包含关闭的路径。

##  <a name="tabbedtextout"></a>CDC：： TabbedTextOut

调用此成员函数以在指定位置写入一个字符串，将选项卡展开为在制表位的数组中指定的值。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定字符串的起始点的逻辑 x 坐标。

*y*<br/>
指定字符串的起始点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。 可以向此参数传递指向字符数组或[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象的指针。

*nCount*<br/>
指定*lpszString*指向的[字符串的长度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定制表位位置数组中的值的数目。

*lpnTabStopPositions*<br/>
指向包含制表位位置（在逻辑单元中）的数组。 制表位必须按递增顺序排序;最小的 x 值应是数组中的第一项。

*nTabOrigin*<br/>
指定从中展开选项卡（在逻辑单元中）的起始位置的 x 坐标。

*str*<br/>
一个包含指定字符的 `CString` 对象。

### <a name="return-value"></a>返回值

作为 `CSize` 对象的字符串（以逻辑单位表示）的维度。

### <a name="remarks"></a>备注

文本以当前所选的字体书写。 如果*nTabPositions*为0， *lpnTabStopPositions*为 NULL，则选项卡将扩展为平均字符宽度的8倍。

如果*nTabPositions*为1，则制表位由*lpnTabStopPositions*数组中第一个值指定的距离隔开。 如果*lpnTabStopPositions*数组包含多个值，则将为数组中的每个值设置一个制表位，直至*nTabPositions*指定的数字为止。 *NTabOrigin*参数允许应用程序在单个行中多次调用 `TabbedTextOut` 函数。 如果应用程序每次将*nTabOrigin*设置为相同的值，则该应用程序多次调用该函数，则该函数将展开与*nTabOrigin*指定的位置相关的所有选项卡。

默认情况下，函数不使用或更新当前位置。 如果应用程序在调用函数时需要更新当前位置，则应用程序可以调用[SetTextAlign](#settextalign)成员函数，并将*nFlags*设置为 TA_UPDATECP。 设置此标志后，Windows 将忽略对 `TabbedTextOut`的后续调用的*x*和*y*参数，而改用当前位置。

##  <a name="textout"></a>CDC：： TextOut

使用当前选定的字体在指定位置写入字符串。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>parameters

*x*<br/>
指定文本起点的逻辑 x 坐标。

*y*<br/>
指定文本起点的逻辑 y 坐标。

*lpszString*<br/>
指向要绘制的字符串。

*nCount*<br/>
指定字符串中的字符数。

*str*<br/>
包含要绘制的字符的 `CString` 对象。

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

字符原点位于字符单元格的左上角。 默认情况下，函数不使用或更新当前位置。

如果应用程序在调用 `TextOut`时需要更新当前位置，则应用程序可以调用 `SetTextAlign` 成员函数，并将*nFlags*设置为 TA_UPDATECP。 设置此标志后，Windows 将忽略对 `TextOut`的后续调用的*x*和*y*参数，而改用当前位置。

### <a name="example"></a>示例

  请参阅[CDC：： BeginPath](#beginpath)的示例。

##  <a name="transparentblt"></a>CDC：： TransparentBlt

调用此成员函数以将颜色数据的位块（对应于指定源设备上下文中的像素矩形）传输到目标设备上下文。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>parameters

*xDest*<br/>
指定目标矩形左上角的 x 坐标（以逻辑单位表示）。

*yDest*<br/>
指定目标矩形左上角的 y 坐标（以逻辑单位表示）。

*nDestWidth*<br/>
指定目标矩形的宽度（以逻辑单位为单位）。

*nDestHeight*<br/>
指定目标矩形的高度（以逻辑单位为单位）。

*pSrcDC*<br/>
指向源设备上下文的指针。

*xSrc*<br/>
指定源矩形的 x 坐标（以逻辑单位为单位）。

*ySrc*<br/>
指定源矩形的 y 坐标（以逻辑单位为单位）。

*nSrcWidth*<br/>
指定源矩形的宽度（以逻辑单位为单位）。

*nSrcHeight*<br/>
指定源矩形的高度（以逻辑单位为单位）。

*clrTransparent*<br/>
要视为透明的源位图中的 RGB 颜色。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

`TransparentBlt` 允许透明度;也就是说， *clrTransparent*指示的 RGB 颜色对于传输是透明的。

有关详细信息，请参阅 Windows SDK 中的[TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) 。

##  <a name="updatecolors"></a>CDC：： UpdateColors

通过将工作区中的当前颜色与系统调色板逐像素匹配，更新设备上下文的工作区。

```
void UpdateColors();
```

### <a name="remarks"></a>备注

当系统调色板发生更改时，具有已实现逻辑调色板的非活动窗口可能会调用 `UpdateColors` 作为重绘其工作区的替代方法。

有关使用调色板的详细信息，请参阅 Windows SDK 中的[UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) 。

`UpdateColors` 成员函数通常比重绘区域更快地更新工作区。 但是，因为函数在系统调色板更改之前基于每个像素的颜色执行颜色转换，所以每次调用此函数都会导致某些颜色精度丢失。

##  <a name="widenpath"></a>CDC：： WidenPath

如果使用当前选择的笔在设备上下文中绘制路径，则将当前路径重新定义为要绘制的区域。

```
BOOL WidenPath();
```

### <a name="return-value"></a>返回值

如果该函数成功，则为非 0；否则为 0。

### <a name="remarks"></a>备注

仅当当前笔是 `CreatePen` 成员函数的第二个版本创建的几何笔时，或者如果使用 `CreatePen` 的第一个版本创建了笔，并且具有宽度（单位为大于1），则此功能成功。 设备上下文必须包含关闭的路径。 路径中的任何 Bzier 曲线都转换为逼近成一条直线的直线序列。 因此，在调用 `WidenPath` 后，路径中不会保留 Bzier 曲线。

## <a name="see-also"></a>另请参阅

[CObject 类](../../mfc/reference/cobject-class.md)<br/>
[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC 类](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC 类](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC 类](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC 类](../../mfc/reference/cmetafiledc-class.md)
